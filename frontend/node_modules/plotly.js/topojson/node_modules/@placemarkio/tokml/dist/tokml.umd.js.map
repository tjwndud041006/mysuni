{"version":3,"file":"tokml.umd.js","sources":["../node_modules/.pnpm/unist-builder@3.0.1/node_modules/unist-builder/lib/index.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/util-escape.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/name.js","../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/value.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/element.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/text.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/instruction.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/cdata.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/one.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/comment.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/doctype.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/raw.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/index.js","../node_modules/.pnpm/xastscript@3.1.1/node_modules/xastscript/lib/index.js","../lib/index.ts"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @typedef {Array<Node> | string} ChildrenOrValue\n *   List to use as `children` or value to use as `value`.\n *\n * @typedef {Record<string, unknown>} Props\n *   Other fields to add to the node.\n */\n\n/**\n * Build a node.\n *\n * @param type\n *   Node type.\n * @param props\n *   Fields assigned to node.\n * @param value\n *   Children of node or value of `node` (cast to string).\n * @returns\n *   Built node.\n */\nexport const u =\n  /**\n   * @type {(\n   *   (<T extends string>(type: T) => {type: T}) &\n   *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\n   *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\n   *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\n   *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\n   *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\n   * )}\n   */\n  (\n    /**\n     * @param {string} type\n     * @param {Props | ChildrenOrValue | null | undefined} [props]\n     * @param {ChildrenOrValue | null | undefined} [value]\n     * @returns {Node}\n     */\n    function (type, props, value) {\n      /** @type {Node} */\n      const node = {type: String(type)}\n\n      if (\n        (value === undefined || value === null) &&\n        (typeof props === 'string' || Array.isArray(props))\n      ) {\n        value = props\n      } else {\n        Object.assign(node, props)\n      }\n\n      if (Array.isArray(value)) {\n        // @ts-expect-error: create a parent.\n        node.children = value\n      } else if (value !== undefined && value !== null) {\n        // @ts-expect-error: create a literal.\n        node.value = String(value)\n      }\n\n      return node\n    }\n  )\n","/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","import {stringifyEntitiesLight} from 'stringify-entities'\n\n// eslint-disable-next-line no-control-regex\nconst noncharacter = /[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g\n\n/**\n * Escape a string.\n *\n * @param {string} value\n *   Raw string.\n * @param {Array<string>} subset\n *   Characters to escape.\n * @param {RegExp | null | undefined} [unsafe]\n *   Regex to scope `subset` to.\n * @returns {string}\n *   Escaped string.\n */\nexport function escape(value, subset, unsafe) {\n  const result = clean(value)\n\n  return unsafe ? result.replace(unsafe, encode) : encode(result)\n\n  /**\n   * Actually escape characters.\n   *\n   * @param {string} value\n   *   Raw value.\n   * @returns {string}\n   *   Copy of `value`, escaped.\n   */\n  function encode(value) {\n    return stringifyEntitiesLight(value, {subset})\n  }\n}\n\n/**\n * Remove non-characters.\n *\n * @param {string} value\n *   Raw value.\n * @returns {string}\n *   Copy of `value` with non-characters removed.\n */\nfunction clean(value) {\n  return String(value || '').replace(noncharacter, '')\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n","import {escape} from './util-escape.js'\n\nconst subset = ['\\t', '\\n', ' ', '\"', '&', \"'\", '/', '<', '=', '>']\n\n/**\n * Encode a node name.\n *\n * @param {string} value\n *   Raw name.\n * @returns {string}\n *   Escaped name.\n */\nexport function name(value) {\n  return escape(value, subset)\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('./index.js').State} State\n */\n\nimport {ccount} from 'ccount'\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize an attribute value.\n *\n * @param {string} value\n *   Raw attribute value.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized attribute value.\n */\nexport function value(value, state) {\n  const result = String(value)\n  let quote = state.options.quote || '\"'\n\n  if (state.options.quoteSmart) {\n    const other = quote === '\"' ? \"'\" : '\"'\n\n    if (ccount(result, quote) > ccount(result, other)) {\n      quote = other\n    }\n  }\n\n  return quote + escape(result, ['<', '&', quote]) + quote\n}\n","/**\n * @typedef {import('xast').Element} Element\n * @typedef {import('./index.js').State} State\n */\n\nimport {all} from './one.js'\nimport {name} from './name.js'\nimport {value} from './value.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Serialize an element.\n *\n * @param {Element} node\n *   xast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function element(node, state) {\n  const nodeName = name(node.name)\n  const content = all(node, state)\n  const attributes = node.attributes || {}\n  const close = content ? false : state.options.closeEmptyElements\n  /** @type {Array<string>} */\n  const attrs = []\n  /** @type {string} */\n  let key\n\n  for (key in attributes) {\n    if (own.call(attributes, key)) {\n      const result = attributes[key]\n\n      if (result !== null && result !== undefined) {\n        attrs.push(name(key) + '=' + value(result, state))\n      }\n    }\n  }\n\n  return (\n    '<' +\n    nodeName +\n    (attrs.length === 0 ? '' : ' ' + attrs.join(' ')) +\n    (close ? (state.options.tightClose ? '' : ' ') + '/' : '') +\n    '>' +\n    content +\n    (close ? '' : '</' + nodeName + '>')\n  )\n}\n","/**\n * @typedef {import('xast').Text} Text\n * @typedef {import('./index.js').Raw} Raw\n */\n\nimport {escape} from './util-escape.js'\n\nconst subset = ['&', '<']\n\n/**\n * Serialize a text.\n *\n * @param {Text | Raw} node\n *   xast text node (or raw).\n * @returns {string}\n *   Serialized XML.\n */\nexport function text(node) {\n  return escape(node.value, subset)\n}\n","/**\n * @typedef {import('xast').Instruction} Instruction\n */\n\nimport {escape} from './util-escape.js'\nimport {name} from './name.js'\n\nconst unsafe = /\\?>/g\nconst subset = ['>']\n\n/**\n * Serialize an instruction.\n *\n * @param {Instruction} node\n *   xast instruction node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function instruction(node) {\n  const nodeName = name(node.name) || 'x'\n  const result = escape(node.value, subset, unsafe)\n  return '<?' + nodeName + (result ? ' ' + result : '') + '?>'\n}\n","/**\n * @typedef {import('xast').Cdata} Cdata\n */\n\nimport {escape} from './util-escape.js'\n\nconst unsafe = /]]>/g\nconst subset = ['>']\n\n/**\n * Serialize a CDATA section.\n *\n * @param {Cdata} node\n *   xast cdata node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function cdata(node) {\n  return '<![CDATA[' + escape(node.value, subset, unsafe) + ']]>'\n}\n","/**\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').RootChildMap} RootChildMap\n * @typedef {import('./index.js').State} State\n */\n\n/**\n * @typedef {Root | RootChildMap[keyof RootChildMap]} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {Parent['children'][number]} Child\n */\n\nimport {element} from './element.js'\nimport {text} from './text.js'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {instruction} from './instruction.js'\nimport {cdata} from './cdata.js'\nimport {raw} from './raw.js'\n\nconst own = {}.hasOwnProperty\n\nconst handlers = {\n  root: all,\n  element,\n  text,\n  comment,\n  doctype,\n  instruction,\n  cdata,\n  raw\n}\n\n/**\n * Serialize a node.\n *\n * @param {Node} node\n *   xast node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function one(node, state) {\n  const type = node && node.type\n\n  if (!type) {\n    throw new Error('Expected node, not `' + node + '`')\n  }\n\n  if (!own.call(handlers, type)) {\n    throw new Error('Cannot compile unknown node `' + type + '`')\n  }\n\n  const handle = handlers[type]\n  // @ts-expect-error hush, node matches `type`.\n  const result = handle(node, state)\n\n  return result\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @param {Parent} parent\n *   xast parent node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function all(parent, state) {\n  /** @type {Array<Child>} */\n  const children = (parent && parent.children) || []\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < children.length) {\n    results[index] = one(children[index], state)\n  }\n\n  return results.join('')\n}\n","/**\n * @typedef {import('xast').Comment} Comment\n */\n\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   xast comment node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function comment(node) {\n  return '<!--' + escape(node.value, ['-']) + '-->'\n}\n","/**\n * @typedef {import('xast').Doctype} Doctype\n * @typedef {import('./index.js').State} State\n */\n\nimport {name} from './name.js'\nimport {value} from './value.js'\n\n/**\n * Serialize a doctype.\n *\n * @param {Doctype} node\n *   xast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function doctype(node, state) {\n  const nodeName = name(node.name)\n  const pub = node.public\n  const sys = node.system\n  let result = '<!DOCTYPE'\n\n  if (nodeName !== '') {\n    result += ' ' + nodeName\n  }\n\n  if (pub) {\n    result += ' PUBLIC ' + value(pub, state)\n  } else if (sys) {\n    result += ' SYSTEM'\n  }\n\n  if (sys) {\n    result += ' ' + value(sys, state)\n  }\n\n  return result + '>'\n}\n","/**\n * @typedef {import('./index.js').Raw} Raw\n * @typedef {import('./index.js').State} State\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a (non-standard) raw.\n *\n * @param {Raw} node\n *   xast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function raw(node, state) {\n  return state.options.allowDangerousXml ? node.value : text(node)\n}\n","/**\n * @typedef {import('xast').Literal} Literal\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').RootChildMap} RootChildMap\n */\n\n/**\n * @typedef {Literal & {type: 'raw'}} Raw\n * @typedef {Root | RootChildMap[keyof RootChildMap]} Node\n *\n * @typedef {'\"' | \"'\"} Quote\n *   XML quotes for attribute values.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [allowDangerousXml=false]\n *   Allow `raw` nodes and insert them as raw XML.\n *\n *   When `false`, `Raw` nodes are encoded.\n *\n *   > ‚ö†Ô∏è **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [closeEmptyElements=false]\n *   Close elements without any content with slash (`/`) on the opening tag\n *   instead of an end tag: `<circle />` instead of `<circle></circle>`.\n *\n *   See `tightClose` to control whether a space is used before the slash.\n * @property {Quote | null | undefined} [quote='\"']\n *   Preferred quote to use.\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes.\n * @property {boolean | null | undefined} [tightClose=false]\n *   Do not use an extra space when closing self-closing elements: `<circle/>`\n *   instead of `<circle />`.\n *\n *   > üëâ **Note**: only used if `closeEmptyElements: true`.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Options} options\n *   Configuration.\n */\n\nimport {one} from './one.js'\n\n/**\n * Serialize a xast tree to XML.\n *\n * @param {Node | Array<Node>} tree\n *   xast node(s) to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {string}\n *   Serialized XML.\n */\nexport function toXml(tree, options) {\n  /** @type {State} */\n  const state = {options: options || {}}\n\n  // Make sure the quote is valid.\n  if (\n    typeof state.options.quote === 'string' &&\n    state.options.quote !== '\"' &&\n    state.options.quote !== \"'\"\n  ) {\n    throw new Error(\n      'Invalid quote `' + state.options.quote + '`, expected `\\'` or `\"`'\n    )\n  }\n\n  /** @type {Node} */\n  // @ts-expect-error Assume no `root` in `node`.\n  const node = Array.isArray(tree) ? {type: 'root', children: tree} : tree\n\n  return one(node, state)\n}\n","/**\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').Element} Element\n */\n\n/**\n * @typedef {Root['children'][number]} Content\n * @typedef {Content | Root} Node\n *   Any concrete `xast` node.\n *\n * @typedef {Root | Element} Result\n *   Result from a `x` call.\n *\n * @typedef {string | number | boolean | null | undefined} Value\n *   Attribute value\n * @typedef {{[attribute: string]: Value}} Attributes\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Node | PrimitiveChild | ArrayChild} Child\n *   Acceptable child value.\n *\n * @typedef {import('./jsx-classic.js').Element} x.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} x.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} x.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} x.JSX.ElementChildrenAttribute\n */\n\n/**\n * Create XML trees in xast.\n *\n * @param name\n *   Qualified name.\n *\n *   Case sensitive and can contain a namespace prefix (such as `rdf:RDF`).\n *   When string, an `Element` is built.\n *   When nullish, a `Root` is built instead.\n * @param attributes\n *   Attributes of the element.\n * @param children\n *   Children of the node.\n * @returns\n *   `Element` or `Root`.\n */\nexport const x =\n  /**\n   * @type {{\n   *   (): Root\n   *   (name: null | undefined, ...children: Array<Child>): Root\n   *   (name: string, attributes?: Attributes, ...children: Array<Child>): Element\n   *   (name: string, ...children: Array<Child>): Element\n   * }}\n   */\n  (\n    /**\n     * @param {string | null | undefined} [name]\n     * @param {Attributes | Child | null | undefined} [attributes]\n     * @param {Array<Child>} children\n     * @returns {Result}\n     */\n    function (name, attributes, ...children) {\n      let index = -1\n      /** @type {Result} */\n      let node\n\n      if (name === undefined || name === null) {\n        node = {type: 'root', children: []}\n        // @ts-expect-error Root builder doesn‚Äôt accept attributes.\n        children.unshift(attributes)\n      } else if (typeof name === 'string') {\n        node = {type: 'element', name, attributes: {}, children: []}\n\n        if (isAttributes(attributes)) {\n          /** @type {string} */\n          let key\n\n          for (key in attributes) {\n            // Ignore nullish and NaN values.\n            if (\n              attributes[key] !== undefined &&\n              attributes[key] !== null &&\n              (typeof attributes[key] !== 'number' ||\n                !Number.isNaN(attributes[key]))\n            ) {\n              // @ts-expect-error Pretty sure we just set it.\n              node.attributes[key] = String(attributes[key])\n            }\n          }\n        } else {\n          children.unshift(attributes)\n        }\n      } else {\n        throw new TypeError('Expected element name, got `' + name + '`')\n      }\n\n      // Handle children.\n      while (++index < children.length) {\n        addChild(node.children, children[index])\n      }\n\n      return node\n    }\n  )\n\n/**\n * Add children.\n *\n * @param {Array<Child>} nodes\n *   List of nodes.\n * @param {Child} value\n *   Child.\n * @returns {void}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new TypeError('Expected node, nodes, string, got `' + value + '`')\n  }\n}\n\n/**\n * Check if `value` is `Attributes`.\n *\n * @param {Attributes | Child} value\n *   Value.\n * @returns {value is Attributes}\n *   Whether `value` is `Attributes`.\n */\nfunction isAttributes(value) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  return true\n}\n","import type { Folder, Root } from \"@tmcw/togeojson\";\nimport type { Feature, FeatureCollection, Geometry, Position } from \"geojson\";\nimport { u } from \"unist-builder\";\nimport type { Element } from \"xast\";\nimport { toXml } from \"xast-util-to-xml\";\nimport { x } from \"xastscript\";\n\ntype F = Feature<Geometry | null>;\n\nconst BR = u(\"text\", \"\\n\");\nconst TAB = u(\"text\", \"  \");\n\ntype Literal = typeof BR;\n\n/**\n * Convert nested folder structure to KML. This expects\n * input that follows the same patterns as [toGeoJSON](https://github.com/placemark/togeojson)'s\n * kmlWithFolders method: a tree of folders and features,\n * starting with a root element.\n */\nexport function foldersToKML(root: Root): string {\n\treturn toXml(\n\t\tu(\"root\", [\n\t\t\tx(\n\t\t\t\t\"kml\",\n\t\t\t\t{ xmlns: \"http://www.opengis.net/kml/2.2\" },\n\t\t\t\tx(\n\t\t\t\t\t\"Document\",\n\t\t\t\t\troot.children.flatMap((child) => convertChild(child)),\n\t\t\t\t),\n\t\t\t),\n\t\t]),\n\t);\n}\n\n/**\n * Convert a GeoJSON FeatureCollection to a string of\n * KML data.\n */\nexport function toKML(\n\tfeatureCollection: FeatureCollection<Geometry | null>,\n): string {\n\treturn toXml(\n\t\tu(\"root\", [\n\t\t\tx(\n\t\t\t\t\"kml\",\n\t\t\t\t{ xmlns: \"http://www.opengis.net/kml/2.2\" },\n\t\t\t\tx(\n\t\t\t\t\t\"Document\",\n\t\t\t\t\tfeatureCollection.features.flatMap((feature) =>\n\t\t\t\t\t\tconvertFeature(feature),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t]),\n\t);\n}\n\nfunction convertChild(child: F | Folder) {\n\tswitch (child.type) {\n\t\tcase \"Feature\":\n\t\t\treturn convertFeature(child);\n\t\tcase \"folder\":\n\t\t\treturn convertFolder(child);\n\t}\n}\n\nfunction convertFolder(folder: Folder): Array<Literal | Element> {\n\tconst id = [\"string\", \"number\"].includes(typeof folder.meta.id)\n\t\t? {\n\t\t\t\tid: String(folder.meta.id),\n\t\t\t}\n\t\t: {};\n\treturn [\n\t\tBR,\n\t\tx(\"Folder\", id, [\n\t\t\tBR,\n\t\t\t...folderMeta(folder.meta),\n\t\t\tBR,\n\t\t\tTAB,\n\t\t\t...folder.children.flatMap((child) => convertChild(child)),\n\t\t]),\n\t];\n}\n\nconst META_PROPERTIES = [\n\t\"address\",\n\t\"description\",\n\t\"name\",\n\t\"open\",\n\t\"visibility\",\n\t\"phoneNumber\",\n] as const;\n\nfunction folderMeta(meta: Folder[\"meta\"]): Element[] {\n\treturn META_PROPERTIES.filter((p) => meta[p] !== undefined).map((p) => {\n\t\treturn x(p, [u(\"text\", String(meta[p]))]);\n\t});\n}\n\nfunction convertFeature(feature: F) {\n\tconst { id } = feature;\n\tconst idMember = [\"string\", \"number\"].includes(typeof id)\n\t\t? {\n\t\t\t\tid: id,\n\t\t\t}\n\t\t: {};\n\treturn [\n\t\tBR,\n\t\tx(\"Placemark\", idMember, [\n\t\t\tBR,\n\t\t\t...propertiesToTags(feature.properties),\n\t\t\tBR,\n\t\t\tTAB,\n\t\t\t...(feature.geometry ? [convertGeometry(feature.geometry)] : []),\n\t\t]),\n\t];\n}\n\nfunction join(position: Position): string {\n\treturn `${position[0]},${position[1]}`;\n}\n\nfunction coord1(coordinates: Position): Element {\n\treturn x(\"coordinates\", [u(\"text\", join(coordinates))]);\n}\n\nfunction coord2(coordinates: Position[]): Element {\n\treturn x(\"coordinates\", [u(\"text\", coordinates.map(join).join(\"\\n\"))]);\n}\n\nfunction valueToString(value: any): string {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn value;\n\t\t}\n\t\tcase \"boolean\":\n\t\tcase \"number\": {\n\t\t\treturn String(value);\n\t\t}\n\t\tcase \"object\": {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(value);\n\t\t\t} catch (e) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nfunction maybeCData(value: any) {\n\tif (\n\t\tvalue &&\n\t\ttypeof value === \"object\" &&\n\t\t\"@type\" in value &&\n\t\tvalue[\"@type\"] === \"html\" &&\n\t\t\"value\" in value &&\n\t\ttypeof value.value === \"string\"\n\t) {\n\t\treturn u(\"cdata\", value.value);\n\t}\n\n\treturn valueToString(value);\n}\n\nfunction propertiesToTags(properties: Feature[\"properties\"]): Element[] {\n\tif (!properties) return [];\n\tconst { name, description, visibility, ...otherProperties } = properties;\n\n\treturn [\n\t\tname && x(\"name\", [u(\"text\", valueToString(name))]),\n\t\tdescription && x(\"description\", [u(\"text\", maybeCData(description))]),\n\t\tvisibility !== undefined &&\n\t\t\tx(\"visibility\", [u(\"text\", visibility ? \"1\" : \"0\")]),\n\t\tx(\n\t\t\t\"ExtendedData\",\n\t\t\tObject.entries(otherProperties).flatMap(([name, value]) => [\n\t\t\t\tBR,\n\t\t\t\tTAB,\n\t\t\t\tx(\"Data\", { name: name }, [\n\t\t\t\t\tx(\"value\", [\n\t\t\t\t\t\tu(\n\t\t\t\t\t\t\t\"text\",\n\t\t\t\t\t\t\ttypeof value === \"string\" ? value : JSON.stringify(value),\n\t\t\t\t\t\t),\n\t\t\t\t\t]),\n\t\t\t\t]),\n\t\t\t]),\n\t\t),\n\t].filter(Boolean);\n}\n\nconst linearRing = (ring: Position[]): Element =>\n\tx(\"LinearRing\", [coord2(ring)]);\n\nfunction convertMultiPoint(geometry: GeoJSON.MultiPoint): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\nfunction convertMultiLineString(geometry: GeoJSON.MultiLineString): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"LineString\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\n\nfunction convertMultiPolygon(geometry: GeoJSON.MultiPolygon): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"Polygon\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\n\nfunction convertPolygon(geometry: GeoJSON.Polygon): Element {\n\tconst [outerBoundary, ...innerRings] = geometry.coordinates;\n\treturn x(\"Polygon\", [\n\t\tBR,\n\t\tx(\"outerBoundaryIs\", [BR, TAB, linearRing(outerBoundary)]),\n\t\t...innerRings.flatMap((innerRing) => [\n\t\t\tBR,\n\t\t\tx(\"innerBoundaryIs\", [BR, TAB, linearRing(innerRing)]),\n\t\t]),\n\t]);\n}\n\nfunction convertGeometry(geometry: Geometry): Element {\n\tswitch (geometry.type) {\n\t\tcase \"Point\":\n\t\t\treturn x(\"Point\", [coord1(geometry.coordinates)]);\n\t\tcase \"MultiPoint\":\n\t\t\treturn convertMultiPoint(geometry);\n\t\tcase \"LineString\":\n\t\t\treturn x(\"LineString\", [coord2(geometry.coordinates)]);\n\t\tcase \"MultiLineString\":\n\t\t\treturn convertMultiLineString(geometry);\n\t\tcase \"Polygon\":\n\t\t\treturn convertPolygon(geometry);\n\t\tcase \"MultiPolygon\":\n\t\t\treturn convertMultiPolygon(geometry);\n\t\tcase \"GeometryCollection\":\n\t\t\treturn x(\n\t\t\t\t\"MultiGeometry\",\n\t\t\t\tgeometry.geometries.flatMap((geometry) => [\n\t\t\t\t\tBR,\n\t\t\t\t\tconvertGeometry(geometry),\n\t\t\t\t]),\n\t\t\t);\n\t}\n}\n"],"names":["u","type","props","value","node","String","Array","isArray","Object","assign","children","defaultSubsetRegex","surrogatePairsRegex","controlCharactersRegex","regexEscapeRegex","subsetToRegexCache","WeakMap","core","options","replace","subset","cached","get","groups","index","length","push","RegExp","join","charactersToExpression","set","charactersToExpressionCached","basic","escapeOnly","pair","all","format","charCodeAt","character","formatBasic","code","toString","toUpperCase","noncharacter","escape","unsafe","result","clean","encode","stringifyEntitiesLight","name","ccount","source","TypeError","count","indexOf","state","quote","quoteSmart","other","own","hasOwnProperty","text","handlers","root","element","nodeName","content","attributes","close","closeEmptyElements","attrs","key","call","tightClose","comment","doctype","pub","public","sys","system","instruction","cdata","raw","allowDangerousXml","one","Error","handle","parent","results","toXml","tree","x","unshift","isAttributes","undefined","Number","isNaN","addChild","nodes","BR","TAB","convertChild","child","convertFeature","folder","id","includes","meta","folderMeta","flatMap","convertFolder","META_PROPERTIES","filter","p","map","feature","idMember","propertiesToTags","properties","geometry","convertGeometry","position","coord2","coordinates","valueToString","JSON","stringify","e","maybeCData","description","visibility","otherProperties","entries","Boolean","linearRing","ring","convertMultiPoint","convertMultiLineString","outerBoundary","innerRings","innerRing","convertPolygon","convertMultiPolygon","geometries","xmlns","featureCollection","features"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}