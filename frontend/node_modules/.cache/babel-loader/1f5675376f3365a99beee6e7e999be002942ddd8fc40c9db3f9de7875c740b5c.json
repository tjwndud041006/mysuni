{"ast":null,"code":"'use strict';\n\n//Parse method copied from https://github.com/brianc/node-postgres\n//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)\n//MIT License\n\n//parses a connection string\nfunction parse(str, options = {}) {\n  //unix socket\n  if (str.charAt(0) === '/') {\n    const config = str.split(' ');\n    return {\n      host: config[0],\n      database: config[1]\n    };\n  }\n\n  // Check for empty host in URL\n\n  const config = {};\n  let result;\n  let dummyHost = false;\n  if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {\n    // Ensure spaces are encoded as %20\n    str = encodeURI(str).replace(/%25(\\d\\d)/g, '%$1');\n  }\n  try {\n    try {\n      result = new URL(str, 'postgres://base');\n    } catch (e) {\n      // The URL is invalid so try again with a dummy host\n      result = new URL(str.replace('@/', '@___DUMMY___/'), 'postgres://base');\n      dummyHost = true;\n    }\n  } catch (err) {\n    // Remove the input from the error message to avoid leaking sensitive information\n    err.input && (err.input = '*****REDACTED*****');\n  }\n\n  // We'd like to use Object.fromEntries() here but Node.js 10 does not support it\n  for (const entry of result.searchParams.entries()) {\n    config[entry[0]] = entry[1];\n  }\n  config.user = config.user || decodeURIComponent(result.username);\n  config.password = config.password || decodeURIComponent(result.password);\n  if (result.protocol == 'socket:') {\n    config.host = decodeURI(result.pathname);\n    config.database = result.searchParams.get('db');\n    config.client_encoding = result.searchParams.get('encoding');\n    return config;\n  }\n  const hostname = dummyHost ? '' : result.hostname;\n  if (!config.host) {\n    // Only set the host if there is no equivalent query param.\n    config.host = decodeURIComponent(hostname);\n  } else if (hostname && /^%2f/i.test(hostname)) {\n    // Only prepend the hostname to the pathname if it is not a URL encoded Unix socket host.\n    result.pathname = hostname + result.pathname;\n  }\n  if (!config.port) {\n    // Only set the port if there is no equivalent query param.\n    config.port = result.port;\n  }\n  const pathname = result.pathname.slice(1) || null;\n  config.database = pathname ? decodeURI(pathname) : null;\n  if (config.ssl === 'true' || config.ssl === '1') {\n    config.ssl = true;\n  }\n  if (config.ssl === '0') {\n    config.ssl = false;\n  }\n  if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {\n    config.ssl = {};\n  }\n\n  // Only try to load fs if we expect to read from the disk\n  const fs = config.sslcert || config.sslkey || config.sslrootcert ? require('fs') : null;\n  if (config.sslcert) {\n    config.ssl.cert = fs.readFileSync(config.sslcert).toString();\n  }\n  if (config.sslkey) {\n    config.ssl.key = fs.readFileSync(config.sslkey).toString();\n  }\n  if (config.sslrootcert) {\n    config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();\n  }\n  if (options.useLibpqCompat && config.uselibpqcompat) {\n    throw new Error('Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.');\n  }\n  if (config.uselibpqcompat === 'true' || options.useLibpqCompat) {\n    switch (config.sslmode) {\n      case 'disable':\n        {\n          config.ssl = false;\n          break;\n        }\n      case 'prefer':\n        {\n          config.ssl.rejectUnauthorized = false;\n          break;\n        }\n      case 'require':\n        {\n          if (config.sslrootcert) {\n            // If a root CA is specified, behavior of `sslmode=require` will be the same as that of `verify-ca`\n            config.ssl.checkServerIdentity = function () {};\n          } else {\n            config.ssl.rejectUnauthorized = false;\n          }\n          break;\n        }\n      case 'verify-ca':\n        {\n          if (!config.ssl.ca) {\n            throw new Error('SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.');\n          }\n          config.ssl.checkServerIdentity = function () {};\n          break;\n        }\n      case 'verify-full':\n        {\n          break;\n        }\n    }\n  } else {\n    switch (config.sslmode) {\n      case 'disable':\n        {\n          config.ssl = false;\n          break;\n        }\n      case 'prefer':\n      case 'require':\n      case 'verify-ca':\n      case 'verify-full':\n        {\n          break;\n        }\n      case 'no-verify':\n        {\n          config.ssl.rejectUnauthorized = false;\n          break;\n        }\n    }\n  }\n  return config;\n}\n\n// convert pg-connection-string ssl config to a ClientConfig.ConnectionOptions\nfunction toConnectionOptions(sslConfig) {\n  const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {\n    // we explicitly check for undefined and null instead of `if (value)` because some\n    // options accept falsy values. Example: `ssl.rejectUnauthorized = false`\n    if (value !== undefined && value !== null) {\n      c[key] = value;\n    }\n    return c;\n  }, {});\n  return connectionOptions;\n}\n\n// convert pg-connection-string config to a ClientConfig\nfunction toClientConfig(config) {\n  const poolConfig = Object.entries(config).reduce((c, [key, value]) => {\n    if (key === 'ssl') {\n      const sslConfig = value;\n      if (typeof sslConfig === 'boolean') {\n        c[key] = sslConfig;\n      }\n      if (typeof sslConfig === 'object') {\n        c[key] = toConnectionOptions(sslConfig);\n      }\n    } else if (value !== undefined && value !== null) {\n      if (key === 'port') {\n        // when port is not specified, it is converted into an empty string\n        // we want to avoid NaN or empty string as a values in ClientConfig\n        if (value !== '') {\n          const v = parseInt(value, 10);\n          if (isNaN(v)) {\n            throw new Error(`Invalid ${key}: ${value}`);\n          }\n          c[key] = v;\n        }\n      } else {\n        c[key] = value;\n      }\n    }\n    return c;\n  }, {});\n  return poolConfig;\n}\n\n// parses a connection string into ClientConfig\nfunction parseIntoClientConfig(str) {\n  return toClientConfig(parse(str));\n}\nmodule.exports = parse;\nparse.parse = parse;\nparse.toClientConfig = toClientConfig;\nparse.parseIntoClientConfig = parseIntoClientConfig;","map":{"version":3,"names":["parse","str","options","charAt","config","split","host","database","result","dummyHost","test","encodeURI","replace","URL","e","err","input","entry","searchParams","entries","user","decodeURIComponent","username","password","protocol","decodeURI","pathname","get","client_encoding","hostname","port","slice","ssl","sslcert","sslkey","sslrootcert","sslmode","fs","require","cert","readFileSync","toString","key","ca","useLibpqCompat","uselibpqcompat","Error","rejectUnauthorized","checkServerIdentity","toConnectionOptions","sslConfig","connectionOptions","Object","reduce","c","value","undefined","toClientConfig","poolConfig","v","parseInt","isNaN","parseIntoClientConfig","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg-connection-string/index.js"],"sourcesContent":["'use strict'\n\n//Parse method copied from https://github.com/brianc/node-postgres\n//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)\n//MIT License\n\n//parses a connection string\nfunction parse(str, options = {}) {\n  //unix socket\n  if (str.charAt(0) === '/') {\n    const config = str.split(' ')\n    return { host: config[0], database: config[1] }\n  }\n\n  // Check for empty host in URL\n\n  const config = {}\n  let result\n  let dummyHost = false\n  if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {\n    // Ensure spaces are encoded as %20\n    str = encodeURI(str).replace(/%25(\\d\\d)/g, '%$1')\n  }\n\n  try {\n    try {\n      result = new URL(str, 'postgres://base')\n    } catch (e) {\n      // The URL is invalid so try again with a dummy host\n      result = new URL(str.replace('@/', '@___DUMMY___/'), 'postgres://base')\n      dummyHost = true\n    }\n  } catch (err) {\n    // Remove the input from the error message to avoid leaking sensitive information\n    err.input && (err.input = '*****REDACTED*****')\n  }\n\n  // We'd like to use Object.fromEntries() here but Node.js 10 does not support it\n  for (const entry of result.searchParams.entries()) {\n    config[entry[0]] = entry[1]\n  }\n\n  config.user = config.user || decodeURIComponent(result.username)\n  config.password = config.password || decodeURIComponent(result.password)\n\n  if (result.protocol == 'socket:') {\n    config.host = decodeURI(result.pathname)\n    config.database = result.searchParams.get('db')\n    config.client_encoding = result.searchParams.get('encoding')\n    return config\n  }\n  const hostname = dummyHost ? '' : result.hostname\n  if (!config.host) {\n    // Only set the host if there is no equivalent query param.\n    config.host = decodeURIComponent(hostname)\n  } else if (hostname && /^%2f/i.test(hostname)) {\n    // Only prepend the hostname to the pathname if it is not a URL encoded Unix socket host.\n    result.pathname = hostname + result.pathname\n  }\n  if (!config.port) {\n    // Only set the port if there is no equivalent query param.\n    config.port = result.port\n  }\n\n  const pathname = result.pathname.slice(1) || null\n  config.database = pathname ? decodeURI(pathname) : null\n\n  if (config.ssl === 'true' || config.ssl === '1') {\n    config.ssl = true\n  }\n\n  if (config.ssl === '0') {\n    config.ssl = false\n  }\n\n  if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {\n    config.ssl = {}\n  }\n\n  // Only try to load fs if we expect to read from the disk\n  const fs = config.sslcert || config.sslkey || config.sslrootcert ? require('fs') : null\n\n  if (config.sslcert) {\n    config.ssl.cert = fs.readFileSync(config.sslcert).toString()\n  }\n\n  if (config.sslkey) {\n    config.ssl.key = fs.readFileSync(config.sslkey).toString()\n  }\n\n  if (config.sslrootcert) {\n    config.ssl.ca = fs.readFileSync(config.sslrootcert).toString()\n  }\n\n  if (options.useLibpqCompat && config.uselibpqcompat) {\n    throw new Error('Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.')\n  }\n\n  if (config.uselibpqcompat === 'true' || options.useLibpqCompat) {\n    switch (config.sslmode) {\n      case 'disable': {\n        config.ssl = false\n        break\n      }\n      case 'prefer': {\n        config.ssl.rejectUnauthorized = false\n        break\n      }\n      case 'require': {\n        if (config.sslrootcert) {\n          // If a root CA is specified, behavior of `sslmode=require` will be the same as that of `verify-ca`\n          config.ssl.checkServerIdentity = function () {}\n        } else {\n          config.ssl.rejectUnauthorized = false\n        }\n        break\n      }\n      case 'verify-ca': {\n        if (!config.ssl.ca) {\n          throw new Error(\n            'SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.'\n          )\n        }\n        config.ssl.checkServerIdentity = function () {}\n        break\n      }\n      case 'verify-full': {\n        break\n      }\n    }\n  } else {\n    switch (config.sslmode) {\n      case 'disable': {\n        config.ssl = false\n        break\n      }\n      case 'prefer':\n      case 'require':\n      case 'verify-ca':\n      case 'verify-full': {\n        break\n      }\n      case 'no-verify': {\n        config.ssl.rejectUnauthorized = false\n        break\n      }\n    }\n  }\n\n  return config\n}\n\n// convert pg-connection-string ssl config to a ClientConfig.ConnectionOptions\nfunction toConnectionOptions(sslConfig) {\n  const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {\n    // we explicitly check for undefined and null instead of `if (value)` because some\n    // options accept falsy values. Example: `ssl.rejectUnauthorized = false`\n    if (value !== undefined && value !== null) {\n      c[key] = value\n    }\n\n    return c\n  }, {})\n\n  return connectionOptions\n}\n\n// convert pg-connection-string config to a ClientConfig\nfunction toClientConfig(config) {\n  const poolConfig = Object.entries(config).reduce((c, [key, value]) => {\n    if (key === 'ssl') {\n      const sslConfig = value\n\n      if (typeof sslConfig === 'boolean') {\n        c[key] = sslConfig\n      }\n\n      if (typeof sslConfig === 'object') {\n        c[key] = toConnectionOptions(sslConfig)\n      }\n    } else if (value !== undefined && value !== null) {\n      if (key === 'port') {\n        // when port is not specified, it is converted into an empty string\n        // we want to avoid NaN or empty string as a values in ClientConfig\n        if (value !== '') {\n          const v = parseInt(value, 10)\n          if (isNaN(v)) {\n            throw new Error(`Invalid ${key}: ${value}`)\n          }\n\n          c[key] = v\n        }\n      } else {\n        c[key] = value\n      }\n    }\n\n    return c\n  }, {})\n\n  return poolConfig\n}\n\n// parses a connection string into ClientConfig\nfunction parseIntoClientConfig(str) {\n  return toClientConfig(parse(str))\n}\n\nmodule.exports = parse\n\nparse.parse = parse\nparse.toClientConfig = toClientConfig\nparse.parseIntoClientConfig = parseIntoClientConfig\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}