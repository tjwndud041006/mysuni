{"ast":null,"code":"// transformations to make on our lexicon\nexport default {\n  // add plural forms of singular nouns\n  Singular: (word, lex, methods, model) => {\n    let already = model.one.lexicon;\n    let plural = methods.two.transform.noun.toPlural(word, model);\n    if (!already[plural]) {\n      lex[plural] = lex[plural] || 'Plural';\n    }\n  },\n  // 'lawyer', 'manager' plural forms\n  Actor: (word, lex, methods, model) => {\n    let already = model.one.lexicon;\n    let plural = methods.two.transform.noun.toPlural(word, model);\n    if (!already[plural]) {\n      lex[plural] = lex[plural] || ['Plural', 'Actor'];\n    }\n  },\n  // superlative/ comparative forms for adjectives\n  Comparable: (word, lex, methods, model) => {\n    let already = model.one.lexicon;\n    let {\n      toSuperlative,\n      toComparative\n    } = methods.two.transform.adjective;\n    // fast -> fastest\n    let sup = toSuperlative(word, model);\n    if (!already[sup]) {\n      lex[sup] = lex[sup] || 'Superlative';\n    }\n    // fast -> faster\n    let comp = toComparative(word, model);\n    if (!already[comp]) {\n      lex[comp] = lex[comp] || 'Comparative';\n    }\n    // overwrite\n    lex[word] = 'Adjective';\n  },\n  // 'german' -> 'germans'\n  Demonym: (word, lex, methods, model) => {\n    let plural = methods.two.transform.noun.toPlural(word, model);\n    lex[plural] = lex[plural] || ['Demonym', 'Plural'];\n  },\n  // conjugate all forms of these verbs\n  Infinitive: (word, lex, methods, model) => {\n    let already = model.one.lexicon;\n    let all = methods.two.transform.verb.conjugate(word, model);\n    Object.entries(all).forEach(a => {\n      if (!already[a[1]] && !lex[a[1]] && a[0] !== 'FutureTense') {\n        lex[a[1]] = a[0];\n      }\n    });\n  },\n  // 'walk up' should conjugate, too\n  PhrasalVerb: (word, lex, methods, model) => {\n    let already = model.one.lexicon;\n    lex[word] = ['PhrasalVerb', 'Infinitive'];\n    let _multi = model.one._multiCache;\n    let [inf, rest] = word.split(' ');\n    // add root verb\n    if (!already[inf]) {\n      lex[inf] = lex[inf] || 'Infinitive';\n    }\n    // conjugate it\n    let all = methods.two.transform.verb.conjugate(inf, model);\n    delete all.FutureTense;\n    Object.entries(all).forEach(a => {\n      // not 'walker up', or 'had taken up'\n      if (a[0] === 'Actor' || a[1] === '') {\n        return;\n      }\n      // add the root verb, alone\n      if (!lex[a[1]] && !already[a[1]]) {\n        lex[a[1]] = a[0];\n      }\n      _multi[a[1]] = 2;\n      let str = a[1] + ' ' + rest;\n      lex[str] = lex[str] || [a[0], 'PhrasalVerb'];\n    });\n  },\n  // expand 'million'\n  Multiple: (word, lex) => {\n    lex[word] = ['Multiple', 'Cardinal'];\n    // 'millionth'\n    lex[word + 'th'] = ['Multiple', 'Ordinal'];\n    // 'millionths'\n    lex[word + 'ths'] = ['Multiple', 'Fraction'];\n  },\n  // expand number-words\n  Cardinal: (word, lex) => {\n    lex[word] = ['TextValue', 'Cardinal'];\n  },\n  // 'millionth'\n  Ordinal: (word, lex) => {\n    lex[word] = ['TextValue', 'Ordinal'];\n    lex[word + 's'] = ['TextValue', 'Fraction'];\n  },\n  // 'thames'\n  Place: (word, lex) => {\n    lex[word] = ['Place', 'ProperNoun'];\n  },\n  // 'ontario'\n  Region: (word, lex) => {\n    lex[word] = ['Region', 'ProperNoun'];\n  }\n};","map":{"version":3,"names":["Singular","word","lex","methods","model","already","one","lexicon","plural","two","transform","noun","toPlural","Actor","Comparable","toSuperlative","toComparative","adjective","sup","comp","Demonym","Infinitive","all","verb","conjugate","Object","entries","forEach","a","PhrasalVerb","_multi","_multiCache","inf","rest","split","FutureTense","str","Multiple","Cardinal","Ordinal","Place","Region"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/methods/expand/byTag.js"],"sourcesContent":["// transformations to make on our lexicon\nexport default {\n  // add plural forms of singular nouns\n  Singular: (word, lex, methods, model) => {\n    let already = model.one.lexicon\n    let plural = methods.two.transform.noun.toPlural(word, model)\n    if (!already[plural]) {\n      lex[plural] = lex[plural] || 'Plural'\n    }\n  },\n  // 'lawyer', 'manager' plural forms\n  Actor: (word, lex, methods, model) => {\n    let already = model.one.lexicon\n    let plural = methods.two.transform.noun.toPlural(word, model)\n    if (!already[plural]) {\n      lex[plural] = lex[plural] || ['Plural', 'Actor']\n    }\n  },\n\n  // superlative/ comparative forms for adjectives\n  Comparable: (word, lex, methods, model) => {\n    let already = model.one.lexicon\n    let { toSuperlative, toComparative } = methods.two.transform.adjective\n    // fast -> fastest\n    let sup = toSuperlative(word, model)\n    if (!already[sup]) {\n      lex[sup] = lex[sup] || 'Superlative'\n    }\n    // fast -> faster\n    let comp = toComparative(word, model)\n    if (!already[comp]) {\n      lex[comp] = lex[comp] || 'Comparative'\n    }\n    // overwrite\n    lex[word] = 'Adjective'\n  },\n\n  // 'german' -> 'germans'\n  Demonym: (word, lex, methods, model) => {\n    let plural = methods.two.transform.noun.toPlural(word, model)\n    lex[plural] = lex[plural] || ['Demonym', 'Plural']\n  },\n\n  // conjugate all forms of these verbs\n  Infinitive: (word, lex, methods, model) => {\n    let already = model.one.lexicon\n    let all = methods.two.transform.verb.conjugate(word, model)\n    Object.entries(all).forEach(a => {\n      if (!already[a[1]] && !lex[a[1]] && a[0] !== 'FutureTense') {\n        lex[a[1]] = a[0]\n      }\n    })\n  },\n\n  // 'walk up' should conjugate, too\n  PhrasalVerb: (word, lex, methods, model) => {\n    let already = model.one.lexicon\n    lex[word] = ['PhrasalVerb', 'Infinitive']\n    let _multi = model.one._multiCache\n    let [inf, rest] = word.split(' ')\n    // add root verb\n    if (!already[inf]) {\n      lex[inf] = lex[inf] || 'Infinitive'\n    }\n    // conjugate it\n    let all = methods.two.transform.verb.conjugate(inf, model)\n    delete all.FutureTense\n    Object.entries(all).forEach(a => {\n      // not 'walker up', or 'had taken up'\n      if (a[0] === 'Actor' || a[1] === '') {\n        return\n      }\n      // add the root verb, alone\n      if (!lex[a[1]] && !already[a[1]]) {\n        lex[a[1]] = a[0]\n      }\n      _multi[a[1]] = 2\n      let str = a[1] + ' ' + rest\n      lex[str] = lex[str] || [a[0], 'PhrasalVerb']\n    })\n  },\n\n  // expand 'million'\n  Multiple: (word, lex) => {\n    lex[word] = ['Multiple', 'Cardinal']\n    // 'millionth'\n    lex[word + 'th'] = ['Multiple', 'Ordinal']\n    // 'millionths'\n    lex[word + 'ths'] = ['Multiple', 'Fraction']\n  },\n  // expand number-words\n  Cardinal: (word, lex) => {\n    lex[word] = ['TextValue', 'Cardinal']\n  },\n\n  // 'millionth'\n  Ordinal: (word, lex) => {\n    lex[word] = ['TextValue', 'Ordinal']\n    lex[word + 's'] = ['TextValue', 'Fraction']\n  },\n  // 'thames'\n  Place: (word, lex) => {\n    lex[word] = ['Place', 'ProperNoun']\n  },\n  // 'ontario'\n  Region: (word, lex) => {\n    lex[word] = ['Region', 'ProperNoun']\n  },\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}