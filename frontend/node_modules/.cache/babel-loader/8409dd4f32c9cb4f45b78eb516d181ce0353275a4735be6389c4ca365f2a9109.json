{"ast":null,"code":"const isMulti = / /;\nconst addChunk = function (term, tag) {\n  if (tag === 'Noun') {\n    term.chunk = tag;\n  }\n  if (tag === 'Verb') {\n    term.chunk = tag;\n  }\n};\nconst tagTerm = function (term, tag, tagSet, isSafe) {\n  // does it already have this tag?\n  if (term.tags.has(tag) === true) {\n    return null;\n  }\n  // allow this shorthand in multiple-tag strings\n  if (tag === '.') {\n    return null;\n  }\n  // don't overwrite any tags, if term is frozen\n  if (term.frozen === true) {\n    isSafe = true;\n  }\n  // for known tags, do logical dependencies first\n  let known = tagSet[tag];\n  if (known) {\n    // first, we remove any conflicting tags\n    if (known.not && known.not.length > 0) {\n      for (let o = 0; o < known.not.length; o += 1) {\n        // if we're in tagSafe, skip this term.\n        if (isSafe === true && term.tags.has(known.not[o])) {\n          return null;\n        }\n        term.tags.delete(known.not[o]);\n      }\n    }\n    // add parent tags\n    if (known.parents && known.parents.length > 0) {\n      for (let o = 0; o < known.parents.length; o += 1) {\n        term.tags.add(known.parents[o]);\n        addChunk(term, known.parents[o]);\n      }\n    }\n  }\n  // finally, add our tag\n  term.tags.add(tag);\n  // now it's dirty?\n  term.dirty = true;\n  // add a chunk too, if it's easy\n  addChunk(term, tag);\n  return true;\n};\n\n// support '#Noun . #Adjective' syntax\nconst multiTag = function (terms, tagString, tagSet, isSafe) {\n  let tags = tagString.split(isMulti);\n  terms.forEach((term, i) => {\n    let tag = tags[i];\n    if (tag) {\n      tag = tag.replace(/^#/, '');\n      tagTerm(term, tag, tagSet, isSafe);\n    }\n  });\n};\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\n\n// verbose-mode tagger debuging\nconst log = (terms, tag, reason = '') => {\n  const yellow = str => '\\x1b[33m\\x1b[3m' + str + '\\x1b[0m';\n  const i = str => '\\x1b[3m' + str + '\\x1b[0m';\n  let word = terms.map(t => {\n    return t.text || '[' + t.implicit + ']';\n  }).join(' ');\n  if (typeof tag !== 'string' && tag.length > 2) {\n    tag = tag.slice(0, 2).join(', #') + ' +'; //truncate the list of tags\n  }\n  tag = typeof tag !== 'string' ? tag.join(', #') : tag;\n  console.log(` ${yellow(word).padEnd(24)} \\x1b[32m→\\x1b[0m #${tag.padEnd(22)}  ${i(reason)}`); // eslint-disable-line\n};\n\n// add a tag to all these terms\nconst setTag = function (terms, tag, world = {}, isSafe, reason) {\n  const tagSet = world.model.one.tagSet || {};\n  if (!tag) {\n    return;\n  }\n  // some logging for debugging\n  const env = typeof process === 'undefined' || !process.env ? self.env || {} : process.env;\n  if (env && env.DEBUG_TAGS) {\n    log(terms, tag, reason);\n  }\n  if (isArray(tag) === true) {\n    tag.forEach(tg => setTag(terms, tg, world, isSafe));\n    return;\n  }\n  if (typeof tag !== 'string') {\n    console.warn(`compromise: Invalid tag '${tag}'`); // eslint-disable-line\n    return;\n  }\n  tag = tag.trim();\n  // support '#Noun . #Adjective' syntax\n  if (isMulti.test(tag)) {\n    multiTag(terms, tag, tagSet, isSafe);\n    return;\n  }\n  tag = tag.replace(/^#/, '');\n  // let set = false\n  for (let i = 0; i < terms.length; i += 1) {\n    tagTerm(terms[i], tag, tagSet, isSafe);\n  }\n};\nexport default setTag;","map":{"version":3,"names":["isMulti","addChunk","term","tag","chunk","tagTerm","tagSet","isSafe","tags","has","frozen","known","not","length","o","delete","parents","add","dirty","multiTag","terms","tagString","split","forEach","i","replace","isArray","arr","Object","prototype","toString","call","log","reason","yellow","str","word","map","t","text","implicit","join","slice","console","padEnd","setTag","world","model","one","env","process","self","DEBUG_TAGS","tg","warn","trim","test"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/tag/methods/setTag.js"],"sourcesContent":["const isMulti = / /\n\nconst addChunk = function (term, tag) {\n  if (tag === 'Noun') {\n    term.chunk = tag\n  }\n  if (tag === 'Verb') {\n    term.chunk = tag\n  }\n}\n\nconst tagTerm = function (term, tag, tagSet, isSafe) {\n  // does it already have this tag?\n  if (term.tags.has(tag) === true) {\n    return null\n  }\n  // allow this shorthand in multiple-tag strings\n  if (tag === '.') {\n    return null\n  }\n  // don't overwrite any tags, if term is frozen\n  if (term.frozen === true) {\n    isSafe = true\n  }\n  // for known tags, do logical dependencies first\n  let known = tagSet[tag]\n  if (known) {\n    // first, we remove any conflicting tags\n    if (known.not && known.not.length > 0) {\n      for (let o = 0; o < known.not.length; o += 1) {\n        // if we're in tagSafe, skip this term.\n        if (isSafe === true && term.tags.has(known.not[o])) {\n          return null\n        }\n        term.tags.delete(known.not[o])\n      }\n    }\n    // add parent tags\n    if (known.parents && known.parents.length > 0) {\n      for (let o = 0; o < known.parents.length; o += 1) {\n        term.tags.add(known.parents[o])\n        addChunk(term, known.parents[o])\n      }\n    }\n  }\n  // finally, add our tag\n  term.tags.add(tag)\n  // now it's dirty?\n  term.dirty = true\n  // add a chunk too, if it's easy\n  addChunk(term, tag)\n  return true\n}\n\n// support '#Noun . #Adjective' syntax\nconst multiTag = function (terms, tagString, tagSet, isSafe) {\n  let tags = tagString.split(isMulti)\n  terms.forEach((term, i) => {\n    let tag = tags[i]\n    if (tag) {\n      tag = tag.replace(/^#/, '')\n      tagTerm(term, tag, tagSet, isSafe)\n    }\n  })\n}\n\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\n// verbose-mode tagger debuging\nconst log = (terms, tag, reason = '') => {\n  const yellow = str => '\\x1b[33m\\x1b[3m' + str + '\\x1b[0m'\n  const i = str => '\\x1b[3m' + str + '\\x1b[0m'\n  let word = terms\n    .map(t => {\n      return t.text || '[' + t.implicit + ']'\n    })\n    .join(' ')\n  if (typeof tag !== 'string' && tag.length > 2) {\n    tag = tag.slice(0, 2).join(', #') + ' +' //truncate the list of tags\n  }\n  tag = typeof tag !== 'string' ? tag.join(', #') : tag\n  console.log(` ${yellow(word).padEnd(24)} \\x1b[32m→\\x1b[0m #${tag.padEnd(22)}  ${i(reason)}`) // eslint-disable-line\n}\n\n// add a tag to all these terms\nconst setTag = function (terms, tag, world = {}, isSafe, reason) {\n  const tagSet = world.model.one.tagSet || {}\n  if (!tag) {\n    return\n  }\n  // some logging for debugging\n  const env = typeof process === 'undefined' || !process.env ? self.env || {} : process.env\n  if (env && env.DEBUG_TAGS) {\n    log(terms, tag, reason)\n  }\n  if (isArray(tag) === true) {\n    tag.forEach(tg => setTag(terms, tg, world, isSafe))\n    return\n  }\n  if (typeof tag !== 'string') {\n    console.warn(`compromise: Invalid tag '${tag}'`) // eslint-disable-line\n    return\n  }\n  tag = tag.trim()\n  // support '#Noun . #Adjective' syntax\n  if (isMulti.test(tag)) {\n    multiTag(terms, tag, tagSet, isSafe)\n    return\n  }\n  tag = tag.replace(/^#/, '')\n  // let set = false\n  for (let i = 0; i < terms.length; i += 1) {\n    tagTerm(terms[i], tag, tagSet, isSafe)\n  }\n}\nexport default setTag\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}