{"ast":null,"code":"/* jscpd:ignore-start */\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n'use strict';\n\nfunction peg$subclass(child, parent) {\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = 'SyntaxError';\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\npeg$subclass(peg$SyntaxError, Error);\npeg$SyntaxError.buildMessage = function (expected, found) {\n  const DESCRIBE_EXPECTATION_FNS = {\n    literal: function (expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n    class: function (expectation) {\n      let escapedParts = '';\n      let i;\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n      }\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';\n    },\n    any: function (expectation) {\n      return 'any character';\n    },\n    end: function (expectation) {\n      return 'end of input';\n    },\n    other: function (expectation) {\n      return expectation.description;\n    }\n  };\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n  function literalEscape(s) {\n    return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n      return '\\\\x0' + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return '\\\\x' + hex(ch);\n    });\n  }\n  function classEscape(s) {\n    return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n      return '\\\\x0' + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return '\\\\x' + hex(ch);\n    });\n  }\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n  function describeExpected(expected) {\n    const descriptions = new Array(expected.length);\n    let i;\n    let j;\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n    descriptions.sort();\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1];\n      default:\n        return descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1];\n    }\n  }\n  function describeFound(found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input';\n  }\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';\n};\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n  const peg$FAILED = {};\n  const peg$startRuleFunctions = {\n    transformation_rule: peg$parsetransformation_rule\n  };\n  let peg$startRuleFunction = peg$parsetransformation_rule;\n  const peg$c0 = function (c1, c2, pred, pars) {\n    let result = null;\n\n    // Construct rule\n    if (pars.length === 1) {\n      result = new TransformationRule(c1, c2, pred, pars[0]);\n    } else {\n      if (pars.length === 2) {\n        result = new TransformationRule(c1, c2, pred, pars[0], pars[1]);\n      } else {\n        result = new TransformationRule(c1, c2, pred);\n      }\n    }\n    return result;\n  };\n  const peg$c1 = /^[!-~\\xA1-\\xFF]/;\n  const peg$c2 = peg$classExpectation([['!', '~'], ['\\xA1', '\\xFF']], false, false);\n  const peg$c3 = function (characters) {\n    let s = '';\n    for (let i = 0; i < characters.length; i++) {\n      s += characters[i];\n    }\n    return s;\n  };\n  const peg$c4 = '*';\n  const peg$c5 = peg$literalExpectation('*', false);\n  const peg$c6 = function (wc) {\n    return wc;\n  };\n  const peg$c7 = '\\r\\n';\n  const peg$c8 = peg$literalExpectation('\\r\\n', false);\n  const peg$c9 = '\\n';\n  const peg$c10 = peg$literalExpectation('\\n', false);\n  const peg$c11 = '\\r';\n  const peg$c12 = peg$literalExpectation('\\r', false);\n  const peg$c13 = '//';\n  const peg$c14 = peg$literalExpectation('//', false);\n  const peg$c15 = peg$anyExpectation();\n  const peg$c16 = ' ';\n  const peg$c17 = peg$literalExpectation(' ', false);\n  const peg$c18 = '\\t';\n  const peg$c19 = peg$literalExpectation('\\t', false);\n  let peg$currPos = 0;\n  let peg$savedPos = 0;\n  const peg$posDetailsCache = [{\n    line: 1,\n    column: 1\n  }];\n  let peg$maxFailPos = 0;\n  let peg$maxFailExpected = [];\n  let peg$silentFails = 0;\n  let peg$result;\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".');\n    }\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n  }\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildSimpleError(message, location);\n  }\n  function peg$literalExpectation(text, ignoreCase) {\n    return {\n      type: 'literal',\n      text: text,\n      ignoreCase: ignoreCase\n    };\n  }\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return {\n      type: 'class',\n      parts: parts,\n      inverted: inverted,\n      ignoreCase: ignoreCase\n    };\n  }\n  function peg$anyExpectation() {\n    return {\n      type: 'any'\n    };\n  }\n  function peg$endExpectation() {\n    return {\n      type: 'end'\n    };\n  }\n  function peg$otherExpectation(description) {\n    return {\n      type: 'other',\n      description: description\n    };\n  }\n  function peg$computePosDetails(pos) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n        p++;\n      }\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n  function peg$computeLocation(startPos, endPos) {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) {\n      return;\n    }\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n    peg$maxFailExpected.push(expected);\n  }\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n  }\n  function peg$parsetransformation_rule() {\n    let s0, s1, s2, s3, s4, s5;\n    s0 = peg$currPos;\n    s1 = peg$parsecategory1();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseidentifier();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseidentifier();\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parsecategory1() {\n    let s0;\n    s0 = peg$parsewild_card();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseidentifier();\n    }\n    return s0;\n  }\n  function peg$parseidentifier() {\n    let s0, s1, s2;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c1.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c2);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c2);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c3(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parsewild_card() {\n    let s0, s1, s2;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c5);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseEOL() {\n    let s0;\n    if (input.substr(peg$currPos, 2) === peg$c7) {\n      s0 = peg$c7;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c8);\n      }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c9;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c10);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c11;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c12);\n          }\n        }\n      }\n    }\n    return s0;\n  }\n  function peg$parseComment() {\n    let s0, s1, s2, s3, s4, s5;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c13) {\n      s1 = peg$c13;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c14);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseEOL();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c15);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseEOL();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c15);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseEOL();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseEOI();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseS() {\n    let s0, s1;\n    s0 = [];\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c19);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseEOL();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c17);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c19);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOL();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseComment();\n          }\n        }\n      }\n    }\n    return s0;\n  }\n  function peg$parseS_no_eol() {\n    let s0, s1;\n    s0 = [];\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c19);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c17);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c19);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n    return s0;\n  }\n  function peg$parseEOI() {\n    let s0, s1;\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c15);\n      }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = void 0;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  var TransformationRule = require('./TransformationRule');\n  peg$result = peg$startRuleFunction();\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n  }\n}\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n/* jscpd:ignore-end */","map":{"version":3,"names":["peg$subclass","child","parent","ctor","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","i","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","describeExpectation","type","describeExpected","descriptions","j","sort","slice","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","transformation_rule","peg$parsetransformation_rule","peg$startRuleFunction","peg$c0","c1","c2","pred","pars","result","TransformationRule","peg$c1","peg$c2","peg$classExpectation","peg$c3","characters","peg$c4","peg$c5","peg$literalExpectation","peg$c6","wc","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$anyExpectation","peg$c16","peg$c17","peg$c18","peg$c19","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","substring","peg$computeLocation","peg$buildStructuredError","peg$otherExpectation","error","peg$buildSimpleError","ignoreCase","peg$endExpectation","peg$computePosDetails","pos","details","p","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","push","s0","s1","s2","s3","s4","s5","peg$parsecategory1","peg$parseidentifier","peg$parsewild_card","test","charAt","peg$parseS_no_eol","peg$parseEOL","substr","peg$parseComment","peg$parseEOI","peg$parseS","require","module","exports","SyntaxError","parse"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/brill_pos_tagger/lib/TF_Parser.js"],"sourcesContent":["/* jscpd:ignore-start */\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n'use strict'\n\nfunction peg$subclass (child, parent) {\n  function ctor () { this.constructor = child }\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor()\n}\n\nfunction peg$SyntaxError (message, expected, found, location) {\n  this.message = message\n  this.expected = expected\n  this.found = found\n  this.location = location\n  this.name = 'SyntaxError'\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError)\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error)\n\npeg$SyntaxError.buildMessage = function (expected, found) {\n  const DESCRIBE_EXPECTATION_FNS = {\n    literal: function (expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"'\n    },\n\n    class: function (expectation) {\n      let escapedParts = ''\n      let i\n\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts += expectation.parts[i] instanceof Array\n          ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])\n          : classEscape(expectation.parts[i])\n      }\n\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'\n    },\n\n    any: function (expectation) {\n      return 'any character'\n    },\n\n    end: function (expectation) {\n      return 'end of input'\n    },\n\n    other: function (expectation) {\n      return expectation.description\n    }\n  }\n\n  function hex (ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase()\n  }\n\n  function literalEscape (s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch) })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch) })\n  }\n\n  function classEscape (s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g, '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch) })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch) })\n  }\n\n  function describeExpectation (expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)\n  }\n\n  function describeExpected (expected) {\n    const descriptions = new Array(expected.length)\n    let i; let j\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i])\n    }\n\n    descriptions.sort()\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i]\n          j++\n        }\n      }\n      descriptions.length = j\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0]\n\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1]\n\n      default:\n        return descriptions.slice(0, -1).join(', ') +\n          ', or ' +\n          descriptions[descriptions.length - 1]\n    }\n  }\n\n  function describeFound (found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input'\n  }\n\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.'\n}\n\nfunction peg$parse (input, options) {\n  options = options !== void 0 ? options : {}\n\n  const peg$FAILED = {}\n\n  const peg$startRuleFunctions = { transformation_rule: peg$parsetransformation_rule }\n  let peg$startRuleFunction = peg$parsetransformation_rule\n\n  const peg$c0 = function (c1, c2, pred, pars) {\n    let result = null\n\n    // Construct rule\n    if (pars.length === 1) {\n      result = new TransformationRule(c1, c2, pred, pars[0])\n    } else {\n      if (pars.length === 2) {\n        result = new TransformationRule(c1, c2, pred, pars[0], pars[1])\n      } else {\n        result = new TransformationRule(c1, c2, pred)\n      }\n    }\n    return (result)\n  }\n  const peg$c1 = /^[!-~\\xA1-\\xFF]/\n  const peg$c2 = peg$classExpectation([['!', '~'], ['\\xA1', '\\xFF']], false, false)\n  const peg$c3 = function (characters) {\n    let s = ''\n    for (let i = 0; i < characters.length; i++) {\n      s += characters[i]\n    }\n    return (s)\n  }\n  const peg$c4 = '*'\n  const peg$c5 = peg$literalExpectation('*', false)\n  const peg$c6 = function (wc) {\n    return (wc)\n  }\n  const peg$c7 = '\\r\\n'\n  const peg$c8 = peg$literalExpectation('\\r\\n', false)\n  const peg$c9 = '\\n'\n  const peg$c10 = peg$literalExpectation('\\n', false)\n  const peg$c11 = '\\r'\n  const peg$c12 = peg$literalExpectation('\\r', false)\n  const peg$c13 = '//'\n  const peg$c14 = peg$literalExpectation('//', false)\n  const peg$c15 = peg$anyExpectation()\n  const peg$c16 = ' '\n  const peg$c17 = peg$literalExpectation(' ', false)\n  const peg$c18 = '\\t'\n  const peg$c19 = peg$literalExpectation('\\t', false)\n\n  let peg$currPos = 0\n  let peg$savedPos = 0\n  const peg$posDetailsCache = [{ line: 1, column: 1 }]\n  let peg$maxFailPos = 0\n  let peg$maxFailExpected = []\n  let peg$silentFails = 0\n\n  let peg$result\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".')\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule]\n  }\n\n  function text () {\n    return input.substring(peg$savedPos, peg$currPos)\n  }\n\n  function location () {\n    return peg$computeLocation(peg$savedPos, peg$currPos)\n  }\n\n  function expected (description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    )\n  }\n\n  function error (message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location)\n  }\n\n  function peg$literalExpectation (text, ignoreCase) {\n    return { type: 'literal', text: text, ignoreCase: ignoreCase }\n  }\n\n  function peg$classExpectation (parts, inverted, ignoreCase) {\n    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase }\n  }\n\n  function peg$anyExpectation () {\n    return { type: 'any' }\n  }\n\n  function peg$endExpectation () {\n    return { type: 'end' }\n  }\n\n  function peg$otherExpectation (description) {\n    return { type: 'other', description: description }\n  }\n\n  function peg$computePosDetails (pos) {\n    let details = peg$posDetailsCache[pos]; let p\n\n    if (details) {\n      return details\n    } else {\n      p = pos - 1\n      while (!peg$posDetailsCache[p]) {\n        p--\n      }\n\n      details = peg$posDetailsCache[p]\n      details = {\n        line: details.line,\n        column: details.column\n      }\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++\n          details.column = 1\n        } else {\n          details.column++\n        }\n\n        p++\n      }\n\n      peg$posDetailsCache[pos] = details\n      return details\n    }\n  }\n\n  function peg$computeLocation (startPos, endPos) {\n    const startPosDetails = peg$computePosDetails(startPos)\n    const endPosDetails = peg$computePosDetails(endPos)\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    }\n  }\n\n  function peg$fail (expected) {\n    if (peg$currPos < peg$maxFailPos) { return }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos\n      peg$maxFailExpected = []\n    }\n\n    peg$maxFailExpected.push(expected)\n  }\n\n  function peg$buildSimpleError (message, location) {\n    return new peg$SyntaxError(message, null, null, location)\n  }\n\n  function peg$buildStructuredError (expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    )\n  }\n\n  function peg$parsetransformation_rule () {\n    let s0, s1, s2, s3, s4, s5\n\n    s0 = peg$currPos\n    s1 = peg$parsecategory1()\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier()\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier()\n        if (s3 !== peg$FAILED) {\n          s4 = []\n          s5 = peg$parseidentifier()\n          while (s5 !== peg$FAILED) {\n            s4.push(s5)\n            s5 = peg$parseidentifier()\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0\n            s1 = peg$c0(s1, s2, s3, s4)\n            s0 = s1\n          } else {\n            peg$currPos = s0\n            s0 = peg$FAILED\n          }\n        } else {\n          peg$currPos = s0\n          s0 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parsecategory1 () {\n    let s0\n\n    s0 = peg$parsewild_card()\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseidentifier()\n    }\n\n    return s0\n  }\n\n  function peg$parseidentifier () {\n    let s0, s1, s2\n\n    s0 = peg$currPos\n    s1 = []\n    if (peg$c1.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos)\n      peg$currPos++\n    } else {\n      s2 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c2) }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2)\n        if (peg$c1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos)\n          peg$currPos++\n        } else {\n          s2 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c2) }\n        }\n      }\n    } else {\n      s1 = peg$FAILED\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol()\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0\n        s1 = peg$c3(s1)\n        s0 = s1\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parsewild_card () {\n    let s0, s1, s2\n\n    s0 = peg$currPos\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c4\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c5) }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol()\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0\n        s1 = peg$c6(s1)\n        s0 = s1\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parseEOL () {\n    let s0\n\n    if (input.substr(peg$currPos, 2) === peg$c7) {\n      s0 = peg$c7\n      peg$currPos += 2\n    } else {\n      s0 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c8) }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c9\n        peg$currPos++\n      } else {\n        s0 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c10) }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c11\n          peg$currPos++\n        } else {\n          s0 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c12) }\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseComment () {\n    let s0, s1, s2, s3, s4, s5\n\n    s0 = peg$currPos\n    if (input.substr(peg$currPos, 2) === peg$c13) {\n      s1 = peg$c13\n      peg$currPos += 2\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c14) }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = []\n      s3 = peg$currPos\n      s4 = peg$currPos\n      peg$silentFails++\n      s5 = peg$parseEOL()\n      peg$silentFails--\n      if (s5 === peg$FAILED) {\n        s4 = void 0\n      } else {\n        peg$currPos = s4\n        s4 = peg$FAILED\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos)\n          peg$currPos++\n        } else {\n          s5 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c15) }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5]\n          s3 = s4\n        } else {\n          peg$currPos = s3\n          s3 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s3\n        s3 = peg$FAILED\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3)\n        s3 = peg$currPos\n        s4 = peg$currPos\n        peg$silentFails++\n        s5 = peg$parseEOL()\n        peg$silentFails--\n        if (s5 === peg$FAILED) {\n          s4 = void 0\n        } else {\n          peg$currPos = s4\n          s4 = peg$FAILED\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos)\n            peg$currPos++\n          } else {\n            s5 = peg$FAILED\n            if (peg$silentFails === 0) { peg$fail(peg$c15) }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5]\n            s3 = s4\n          } else {\n            peg$currPos = s3\n            s3 = peg$FAILED\n          }\n        } else {\n          peg$currPos = s3\n          s3 = peg$FAILED\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseEOL()\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseEOI()\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3]\n          s0 = s1\n        } else {\n          peg$currPos = s0\n          s0 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parseS () {\n    let s0, s1\n\n    s0 = []\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c17) }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c19) }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseEOL()\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment()\n        }\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1)\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c17) }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18\n          peg$currPos++\n        } else {\n          s1 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c19) }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOL()\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseComment()\n          }\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseS_no_eol () {\n    let s0, s1\n\n    s0 = []\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c17) }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c19) }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment()\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1)\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c17) }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18\n          peg$currPos++\n        } else {\n          s1 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c19) }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment()\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseEOI () {\n    let s0, s1\n\n    s0 = peg$currPos\n    peg$silentFails++\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos)\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c15) }\n    }\n    peg$silentFails--\n    if (s1 === peg$FAILED) {\n      s0 = void 0\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  var TransformationRule = require('./TransformationRule')\n\n  peg$result = peg$startRuleFunction()\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation())\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    )\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n}\n/* jscpd:ignore-end */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}