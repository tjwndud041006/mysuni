{"ast":null,"code":"import matchTerm from '../term/doesMatch.js';\nimport negGreedy from './logic/negative-greedy.js';\n\n// '!foo' should match anything that isn't 'foo'\n// if it matches, return false\nconst doNegative = function (state) {\n  const {\n    regs\n  } = state;\n  let reg = regs[state.r];\n\n  // match *anything* but this term\n  let tmpReg = Object.assign({}, reg);\n  tmpReg.negative = false; // try removing it\n\n  // found it? if so, we die here\n  let found = matchTerm(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length);\n  if (found) {\n    return false; //bye\n  }\n  // should we skip the term too?\n  if (reg.optional) {\n    // \"before after\" - \"before !foo? after\"\n    // does the next reg match the this term?\n    let nextReg = regs[state.r + 1];\n    if (nextReg) {\n      let fNext = matchTerm(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length);\n      if (fNext) {\n        state.r += 1;\n      } else if (nextReg.optional && regs[state.r + 2]) {\n        // ugh. ok,\n        // support \"!foo? extra? need\"\n        // but don't scan ahead more than that.\n        let fNext2 = matchTerm(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length);\n        if (fNext2) {\n          state.r += 2;\n        }\n      }\n    }\n  }\n  // negative greedy - !foo+  - super hard!\n  if (reg.greedy) {\n    return negGreedy(state, tmpReg, regs[state.r + 1]);\n  }\n  state.t += 1;\n  return true;\n};\nexport default doNegative;","map":{"version":3,"names":["matchTerm","negGreedy","doNegative","state","regs","reg","r","tmpReg","Object","assign","negative","found","terms","t","start_i","phrase_length","optional","nextReg","fNext","fNext2","greedy"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/steps/negative.js"],"sourcesContent":["import matchTerm from '../term/doesMatch.js'\nimport negGreedy from './logic/negative-greedy.js'\n\n// '!foo' should match anything that isn't 'foo'\n// if it matches, return false\nconst doNegative = function (state) {\n  const { regs } = state\n  let reg = regs[state.r]\n\n  // match *anything* but this term\n  let tmpReg = Object.assign({}, reg)\n  tmpReg.negative = false // try removing it\n\n  // found it? if so, we die here\n  let found = matchTerm(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length)\n  if (found) {\n    return false//bye\n  }\n  // should we skip the term too?\n  if (reg.optional) {\n    // \"before after\" - \"before !foo? after\"\n    // does the next reg match the this term?\n    let nextReg = regs[state.r + 1]\n    if (nextReg) {\n      let fNext = matchTerm(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length)\n      if (fNext) {\n        state.r += 1\n      } else if (nextReg.optional && regs[state.r + 2]) {\n        // ugh. ok,\n        // support \"!foo? extra? need\"\n        // but don't scan ahead more than that.\n        let fNext2 = matchTerm(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length)\n        if (fNext2) {\n          state.r += 2\n        }\n      }\n    }\n  }\n  // negative greedy - !foo+  - super hard!\n  if (reg.greedy) {\n    return negGreedy(state, tmpReg, regs[state.r + 1])\n  }\n  state.t += 1\n  return true\n}\nexport default doNegative"],"mappings":"AAAA,OAAOA,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,SAAS,MAAM,4BAA4B;;AAElD;AACA;AACA,MAAMC,UAAU,GAAG,SAAAA,CAAUC,KAAK,EAAE;EAClC,MAAM;IAAEC;EAAK,CAAC,GAAGD,KAAK;EACtB,IAAIE,GAAG,GAAGD,IAAI,CAACD,KAAK,CAACG,CAAC,CAAC;;EAEvB;EACA,IAAIC,MAAM,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,GAAG,CAAC;EACnCE,MAAM,CAACG,QAAQ,GAAG,KAAK,EAAC;;EAExB;EACA,IAAIC,KAAK,GAAGX,SAAS,CAACG,KAAK,CAACS,KAAK,CAACT,KAAK,CAACU,CAAC,CAAC,EAAEN,MAAM,EAAEJ,KAAK,CAACW,OAAO,GAAGX,KAAK,CAACU,CAAC,EAAEV,KAAK,CAACY,aAAa,CAAC;EACjG,IAAIJ,KAAK,EAAE;IACT,OAAO,KAAK;EACd;EACA;EACA,IAAIN,GAAG,CAACW,QAAQ,EAAE;IAChB;IACA;IACA,IAAIC,OAAO,GAAGb,IAAI,CAACD,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC;IAC/B,IAAIW,OAAO,EAAE;MACX,IAAIC,KAAK,GAAGlB,SAAS,CAACG,KAAK,CAACS,KAAK,CAACT,KAAK,CAACU,CAAC,CAAC,EAAEI,OAAO,EAAEd,KAAK,CAACW,OAAO,GAAGX,KAAK,CAACU,CAAC,EAAEV,KAAK,CAACY,aAAa,CAAC;MAClG,IAAIG,KAAK,EAAE;QACTf,KAAK,CAACG,CAAC,IAAI,CAAC;MACd,CAAC,MAAM,IAAIW,OAAO,CAACD,QAAQ,IAAIZ,IAAI,CAACD,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,EAAE;QAChD;QACA;QACA;QACA,IAAIa,MAAM,GAAGnB,SAAS,CAACG,KAAK,CAACS,KAAK,CAACT,KAAK,CAACU,CAAC,CAAC,EAAET,IAAI,CAACD,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,EAAEH,KAAK,CAACW,OAAO,GAAGX,KAAK,CAACU,CAAC,EAAEV,KAAK,CAACY,aAAa,CAAC;QAC7G,IAAII,MAAM,EAAE;UACVhB,KAAK,CAACG,CAAC,IAAI,CAAC;QACd;MACF;IACF;EACF;EACA;EACA,IAAID,GAAG,CAACe,MAAM,EAAE;IACd,OAAOnB,SAAS,CAACE,KAAK,EAAEI,MAAM,EAAEH,IAAI,CAACD,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,CAAC;EACpD;EACAH,KAAK,CAACU,CAAC,IAAI,CAAC;EACZ,OAAO,IAAI;AACb,CAAC;AACD,eAAeX,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}