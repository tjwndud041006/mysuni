{"ast":null,"code":"var net = require('net');\nvar events = require('events');\nvar util = require('util');\nvar makeRequestBuffer = require('./utils').makeRequestBuffer;\nvar parseMessage = require('./utils').parseMessage;\nvar merge = require('./utils').merge;\nvar timestamp = require('./utils').timestamp;\nvar Server = function (host, port, username, password, options) {\n  events.EventEmitter.call(this);\n  this.responseBuffer = Buffer.from([]);\n  this.host = host;\n  this.port = port;\n  this.connected = false;\n  this.timeoutSet = false;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.options = merge(options || {}, {\n    timeout: 0.5,\n    keepAlive: false,\n    keepAliveDelay: 30\n  });\n  if (this.options.conntimeout === undefined || this.options.conntimeout === null) {\n    this.options.conntimeout = 2 * this.options.timeout;\n  }\n  this.username = username || this.options.username || process.env.MEMCACHIER_USERNAME || process.env.MEMCACHE_USERNAME;\n  this.password = password || this.options.password || process.env.MEMCACHIER_PASSWORD || process.env.MEMCACHE_PASSWORD;\n  return this;\n};\nutil.inherits(Server, events.EventEmitter);\nServer.prototype.onConnect = function (func) {\n  this.connectCallbacks.push(func);\n};\nServer.prototype.onResponse = function (seq, func) {\n  this.responseCallbacks[seq] = func;\n};\nServer.prototype.respond = function (response) {\n  var callback = this.responseCallbacks[response.header.opaque];\n  if (!callback) {\n    // in case of authentication, no callback is registered\n    return;\n  }\n  callback(response);\n  if (!callback.quiet || response.header.totalBodyLength === 0) {\n    delete this.responseCallbacks[response.header.opaque];\n    this.requestTimeouts.shift();\n    delete this.errorCallbacks[response.header.opaque];\n  }\n};\nServer.prototype.onError = function (seq, func) {\n  this.errorCallbacks[seq] = func;\n};\nServer.prototype.error = function (err) {\n  var errcalls = this.errorCallbacks;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.timeoutSet = false;\n  if (this._socket) {\n    this._socket.destroy();\n    delete this._socket;\n  }\n  var k;\n  for (k in errcalls) {\n    if (errcalls.hasOwnProperty(k)) {\n      errcalls[k](err);\n    }\n  }\n};\nServer.prototype.listSasl = function () {\n  var buf = makeRequestBuffer(0x20, '', '', '');\n  this.writeSASL(buf);\n};\nServer.prototype.saslAuth = function () {\n  var authStr = '\\x00' + this.username + '\\x00' + this.password;\n  var buf = makeRequestBuffer(0x21, 'PLAIN', '', authStr);\n  this.writeSASL(buf);\n};\nServer.prototype.appendToBuffer = function (dataBuf) {\n  var old = this.responseBuffer;\n  this.responseBuffer = Buffer.alloc(old.length + dataBuf.length);\n  old.copy(this.responseBuffer, 0);\n  dataBuf.copy(this.responseBuffer, old.length);\n  return this.responseBuffer;\n};\nServer.prototype.responseHandler = function (dataBuf) {\n  var response = parseMessage(this.appendToBuffer(dataBuf));\n  var respLength;\n  while (response) {\n    if (response.header.opcode === 0x20) {\n      this.saslAuth();\n    } else if (response.header.status === 0x20) {\n      this.error('Memcached server authentication failed!');\n    } else if (response.header.opcode === 0x21) {\n      this.emit('authenticated');\n    } else {\n      this.respond(response);\n    }\n    respLength = response.header.totalBodyLength + 24;\n    this.responseBuffer = this.responseBuffer.slice(respLength);\n    response = parseMessage(this.responseBuffer);\n  }\n};\nServer.prototype.sock = function (sasl, go) {\n  var self = this;\n  if (!self._socket) {\n    // CASE 1: completely new socket\n    self.connected = false;\n    self._socket = net.connect(this.port, this.host, function () {\n      // SASL authentication handler\n      self.once('authenticated', function () {\n        if (self._socket) {\n          self.connected = true;\n          // cancel connection timeout\n          self._socket.setTimeout(0);\n          self.timeoutSet = false;\n          // run actual request(s)\n          go(self._socket);\n          self.connectCallbacks.forEach(function (cb) {\n            cb(self._socket);\n          });\n          self.connectCallbacks = [];\n        }\n      });\n\n      // setup response handler\n      this.on('data', function (dataBuf) {\n        self.responseHandler(dataBuf);\n      });\n\n      // kick of SASL if needed\n      if (self.username && self.password) {\n        self.listSasl();\n      } else {\n        self.emit('authenticated');\n      }\n    });\n\n    // setup error handler\n    self._socket.on('error', function (error) {\n      self.error(error);\n    });\n    self._socket.on('close', function () {\n      self.connected = false;\n      if (self.timeoutSet) {\n        self._socket.setTimeout(0);\n        self.timeoutSet = false;\n      }\n      self._socket = undefined;\n    });\n\n    // setup connection timeout handler\n    self.timeoutSet = true;\n    self._socket.setTimeout(self.options.conntimeout * 1000, function () {\n      self.timeoutSet = false;\n      if (!self.connected) {\n        this.end();\n        self._socket = undefined;\n        self.error(new Error('socket timed out connecting to server.'));\n      }\n    });\n\n    // use TCP keep-alive\n    self._socket.setKeepAlive(self.options.keepAlive, self.options.keepAliveDelay * 1000);\n  } else if (!self.connected && !sasl) {\n    // CASE 2: socket exists, but still connecting / authenticating\n    self.onConnect(go);\n  } else {\n    // CASE 3: socket exists and connected / ready to use\n    go(self._socket);\n  }\n};\n\n// We handle tracking timeouts with an array of deadlines (requestTimeouts), as\n// node doesn't like us setting up lots of timers, and using just one is more\n// efficient anyway.\nvar timeoutHandler = function (server, sock) {\n  if (server.requestTimeouts.length === 0) {\n    // nothing active\n    server.timeoutSet = false;\n    return;\n  }\n\n  // some requests outstanding, check if any have timed-out\n  var now = timestamp();\n  var soonestTimeout = server.requestTimeouts[0];\n  if (soonestTimeout <= now) {\n    // timeout occurred!\n    sock.end();\n    server.connected = false;\n    server._socket = undefined;\n    server.timeoutSet = false;\n    server.error(new Error('socket timed out waiting on response.'));\n  } else {\n    // no timeout! Setup next one.\n    var deadline = soonestTimeout - now;\n    sock.setTimeout(deadline, function () {\n      timeoutHandler(server, sock);\n    });\n  }\n};\nServer.prototype.write = function (blob) {\n  var self = this;\n  var deadline = Math.round(self.options.timeout * 1000);\n  this.sock(false, function (s) {\n    s.write(blob);\n    self.requestTimeouts.push(timestamp() + deadline);\n    if (!self.timeoutSet) {\n      self.timeoutSet = true;\n      s.setTimeout(deadline, function () {\n        timeoutHandler(self, this);\n      });\n    }\n  });\n};\nServer.prototype.writeSASL = function (blob) {\n  this.sock(true, function (s) {\n    s.write(blob);\n  });\n};\nServer.prototype.close = function () {\n  if (this._socket) {\n    this._socket.end();\n  }\n};\nServer.prototype.toString = function () {\n  return '<Server ' + this.host + ':' + this.port + '>';\n};\nexports.Server = Server;","map":{"version":3,"names":["net","require","events","util","makeRequestBuffer","parseMessage","merge","timestamp","Server","host","port","username","password","options","EventEmitter","call","responseBuffer","Buffer","from","connected","timeoutSet","connectCallbacks","responseCallbacks","requestTimeouts","errorCallbacks","timeout","keepAlive","keepAliveDelay","conntimeout","undefined","process","env","MEMCACHIER_USERNAME","MEMCACHE_USERNAME","MEMCACHIER_PASSWORD","MEMCACHE_PASSWORD","inherits","prototype","onConnect","func","push","onResponse","seq","respond","response","callback","header","opaque","quiet","totalBodyLength","shift","onError","error","err","errcalls","_socket","destroy","k","hasOwnProperty","listSasl","buf","writeSASL","saslAuth","authStr","appendToBuffer","dataBuf","old","alloc","length","copy","responseHandler","respLength","opcode","status","emit","slice","sock","sasl","go","self","connect","once","setTimeout","forEach","cb","on","end","Error","setKeepAlive","timeoutHandler","server","now","soonestTimeout","deadline","write","blob","Math","round","s","close","toString","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/memjs/lib/memjs/server.js"],"sourcesContent":["var net = require('net');\nvar events = require('events');\nvar util = require('util');\nvar makeRequestBuffer = require('./utils').makeRequestBuffer;\nvar parseMessage = require('./utils').parseMessage;\nvar merge = require('./utils').merge;\nvar timestamp = require('./utils').timestamp;\n\nvar Server = function(host, port, username, password, options) {\n  events.EventEmitter.call(this);\n  this.responseBuffer = Buffer.from([]);\n  this.host = host;\n  this.port = port;\n  this.connected = false;\n  this.timeoutSet = false;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.options = merge(options || {}, {timeout: 0.5, keepAlive: false, keepAliveDelay: 30});\n  if (this.options.conntimeout === undefined || this.options.conntimeout === null) {\n    this.options.conntimeout = 2 * this.options.timeout;\n  }\n  this.username = username || this.options.username || process.env.MEMCACHIER_USERNAME || process.env.MEMCACHE_USERNAME;\n  this.password = password || this.options.password || process.env.MEMCACHIER_PASSWORD || process.env.MEMCACHE_PASSWORD;\n  return this;\n};\n\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype.onConnect = function(func) {\n  this.connectCallbacks.push(func);\n};\n\nServer.prototype.onResponse = function(seq, func) {\n  this.responseCallbacks[seq] = func;\n};\n\nServer.prototype.respond = function(response) {\n  var callback = this.responseCallbacks[response.header.opaque];\n  if (!callback) {\n    // in case of authentication, no callback is registered\n    return;\n  }\n  callback(response);\n  if (!callback.quiet || response.header.totalBodyLength === 0) {\n    delete(this.responseCallbacks[response.header.opaque]);\n    this.requestTimeouts.shift();\n    delete(this.errorCallbacks[response.header.opaque]);\n  }\n};\n\nServer.prototype.onError = function(seq, func) {\n  this.errorCallbacks[seq] = func;\n};\n\nServer.prototype.error = function(err) {\n  var errcalls = this.errorCallbacks;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.timeoutSet = false;\n  if (this._socket) {\n    this._socket.destroy();\n    delete(this._socket);\n  }\n  var k;\n  for (k in errcalls) {\n    if (errcalls.hasOwnProperty(k)) {\n      errcalls[k](err);\n    }\n  }\n};\n\nServer.prototype.listSasl = function() {\n  var buf = makeRequestBuffer(0x20, '', '', '');\n  this.writeSASL(buf);\n};\n\nServer.prototype.saslAuth = function() {\n  var authStr = '\\x00' + this.username + '\\x00' + this.password;\n  var buf = makeRequestBuffer(0x21, 'PLAIN', '', authStr);\n  this.writeSASL(buf);\n};\n\nServer.prototype.appendToBuffer = function(dataBuf) {\n  var old = this.responseBuffer;\n  this.responseBuffer = Buffer.alloc(old.length + dataBuf.length);\n  old.copy(this.responseBuffer, 0);\n  dataBuf.copy(this.responseBuffer, old.length);\n  return this.responseBuffer;\n};\n\nServer.prototype.responseHandler = function(dataBuf) {\n  var response = parseMessage(this.appendToBuffer(dataBuf));\n  var respLength;\n  while (response) {\n    if (response.header.opcode === 0x20) {\n      this.saslAuth();\n    } else if (response.header.status === 0x20) {\n      this.error('Memcached server authentication failed!');\n    } else if (response.header.opcode === 0x21) {\n      this.emit('authenticated');\n    } else {\n      this.respond(response);\n    }\n    respLength = response.header.totalBodyLength + 24;\n    this.responseBuffer = this.responseBuffer.slice(respLength);\n    response = parseMessage(this.responseBuffer);\n  }\n};\n\nServer.prototype.sock = function(sasl, go) {\n  var self = this;\n\n  if (!self._socket) {\n    // CASE 1: completely new socket\n    self.connected = false;\n    self._socket = net.connect(this.port, this.host, function() {\n\n      // SASL authentication handler\n      self.once('authenticated', function() {\n        if (self._socket) {\n          self.connected = true;\n          // cancel connection timeout\n          self._socket.setTimeout(0);\n          self.timeoutSet = false;\n          // run actual request(s)\n          go(self._socket);\n          self.connectCallbacks.forEach(function(cb) {\n            cb(self._socket);\n          });\n          self.connectCallbacks = [];\n        }\n      });\n\n      // setup response handler\n      this.on('data', function(dataBuf) {\n        self.responseHandler(dataBuf);\n      });\n\n      // kick of SASL if needed\n      if (self.username && self.password) {\n        self.listSasl();\n      } else {\n        self.emit('authenticated');\n      }\n    });\n\n    // setup error handler\n    self._socket.on('error', function(error) {\n      self.error(error);\n    });\n\n    self._socket.on('close', function() {\n      self.connected = false;\n      if (self.timeoutSet) {\n        self._socket.setTimeout(0);\n        self.timeoutSet = false;\n      }\n      self._socket = undefined;\n    });\n\n    // setup connection timeout handler\n    self.timeoutSet = true;\n    self._socket.setTimeout(self.options.conntimeout * 1000, function() {\n      self.timeoutSet = false;\n      if (!self.connected) {\n        this.end();\n        self._socket = undefined;\n        self.error(new Error('socket timed out connecting to server.'));\n      }\n    });\n\n    // use TCP keep-alive\n    self._socket.setKeepAlive(self.options.keepAlive, self.options.keepAliveDelay * 1000);\n\n  } else if (!self.connected && !sasl) {\n    // CASE 2: socket exists, but still connecting / authenticating\n    self.onConnect(go);\n\n  } else {\n    // CASE 3: socket exists and connected / ready to use\n    go(self._socket);\n  }\n};\n\n// We handle tracking timeouts with an array of deadlines (requestTimeouts), as\n// node doesn't like us setting up lots of timers, and using just one is more\n// efficient anyway.\nvar timeoutHandler = function(server, sock) {\n  if (server.requestTimeouts.length === 0) {\n    // nothing active\n    server.timeoutSet = false;\n    return;\n  }\n\n  // some requests outstanding, check if any have timed-out\n  var now = timestamp();\n  var soonestTimeout = server.requestTimeouts[0];\n\n  if (soonestTimeout <= now) {\n    // timeout occurred!\n    sock.end();\n    server.connected = false;\n    server._socket = undefined;\n    server.timeoutSet = false;\n    server.error(new Error('socket timed out waiting on response.'));\n  } else {\n    // no timeout! Setup next one.\n    var deadline = soonestTimeout - now;\n    sock.setTimeout(deadline, function() {\n      timeoutHandler(server, sock);\n    });\n  }\n};\n\nServer.prototype.write = function(blob) {\n  var self = this;\n  var deadline = Math.round(self.options.timeout * 1000);\n  this.sock(false, function(s) {\n    s.write(blob);\n    self.requestTimeouts.push(timestamp() + deadline);\n    if (!self.timeoutSet) {\n      self.timeoutSet = true;\n      s.setTimeout(deadline, function() {\n        timeoutHandler(self, this);\n      });\n    }\n  });\n};\n\nServer.prototype.writeSASL = function(blob) {\n  this.sock(true, function(s) {\n    s.write(blob);\n  });\n};\n\nServer.prototype.close = function() {\n  if (this._socket) { this._socket.end(); }\n};\n\nServer.prototype.toString = function() {\n  return '<Server ' + this.host + ':' + this.port + '>';\n};\n\nexports.Server = Server;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}