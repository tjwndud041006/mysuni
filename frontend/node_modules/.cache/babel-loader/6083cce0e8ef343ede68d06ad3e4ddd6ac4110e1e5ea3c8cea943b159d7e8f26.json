{"ast":null,"code":"'use strict';\n\n/* Load `trigram-utils`. */\nvar utilities = require('trigram-utils');\n\n/* Load `expressions` (regular expressions matching\n * scripts). */\nvar expressions = require('./expressions.js');\n\n/* Load `data` (trigram information per language,\n * per script). */\nvar data = require('./data.json');\n\n/* Expose `detectAll` on `detect`. */\ndetect.all = detectAll;\n\n/* Expose `detect`. */\nmodule.exports = detect;\n\n/* Maximum sample length. */\nvar MAX_LENGTH = 2048;\n\n/* Minimum sample length. */\nvar MIN_LENGTH = 10;\n\n/* The maximum distance to add when a given trigram does\n * not exist in a trigram dictionary. */\nvar MAX_DIFFERENCE = 300;\n\n/* Construct trigram dictionaries. */\n(function () {\n  var languages;\n  var name;\n  var trigrams;\n  var model;\n  var script;\n  var weight;\n  for (script in data) {\n    languages = data[script];\n    for (name in languages) {\n      model = languages[name].split('|');\n      weight = model.length;\n      trigrams = {};\n      while (weight--) {\n        trigrams[model[weight]] = weight;\n      }\n      languages[name] = trigrams;\n    }\n  }\n})();\n\n/**\n * Get the most probable language for the given value.\n *\n * @param {string} value - The value to test.\n * @param {Object} options - Configuration.\n * @return {string} The most probable language.\n */\nfunction detect(value, options) {\n  return detectAll(value, options)[0][0];\n}\n\n/**\n * Get a list of probable languages the given value is\n * written in.\n *\n * @param {string} value - The value to test.\n * @param {Object} options - Configuration.\n * @return {Array.<Array.<string, number>>} An array\n *   containing language--distance tuples.\n */\nfunction detectAll(value, options) {\n  var settings = options || {};\n  var minLength = MIN_LENGTH;\n  var script;\n  if (settings.minLength !== null && settings.minLength !== undefined) {\n    minLength = settings.minLength;\n  }\n  if (!value || value.length < minLength) {\n    return und();\n  }\n  value = value.substr(0, MAX_LENGTH);\n\n  /* Get the script which characters occur the most\n   * in `value`. */\n  script = getTopScript(value, expressions);\n\n  /* One languages exists for the most-used script.\n   *\n   * If no matches occured, such as a digit only string,\n   * exit with `und`. */\n  if (!(script[0] in data)) {\n    return script[1] === 0 ? und() : singleLanguageTuples(script[0]);\n  }\n\n  /* Get all distances for a given script, and\n   * normalize the distance values. */\n  return normalize(value, getDistances(utilities.asTuples(value), data[script[0]], settings));\n}\n\n/**\n * Normalize the difference for each tuple in\n * `distances`.\n *\n * @param {string} value - Value to normalize.\n * @param {Array.<Array.<string, number>>} distances\n *   - List of distances.\n * @return {Array.<Array.<string, number>>} - Normalized\n *   distances.\n */\nfunction normalize(value, distances) {\n  var min = distances[0][1];\n  var max = value.length * MAX_DIFFERENCE - min;\n  var index = -1;\n  var length = distances.length;\n  while (++index < length) {\n    distances[index][1] = 1 - (distances[index][1] - min) / max || 0;\n  }\n  return distances;\n}\n\n/**\n * From `scripts`, get the most occurring expression for\n * `value`.\n *\n * @param {string} value - Value to check.\n * @param {Object.<RegExp>} scripts - Top-Scripts.\n * @return {Array} Top script and its\n *   occurrence percentage.\n */\nfunction getTopScript(value, scripts) {\n  var topCount = -1;\n  var topScript;\n  var script;\n  var count;\n  for (script in scripts) {\n    count = getOccurrence(value, scripts[script]);\n    if (count > topCount) {\n      topCount = count;\n      topScript = script;\n    }\n  }\n  return [topScript, topCount];\n}\n\n/**\n * Get the occurrence ratio of `expression` for `value`.\n *\n * @param {string} value - Value to check.\n * @param {RegExp} expression - Code-point expression.\n * @return {number} Float between 0 and 1.\n */\nfunction getOccurrence(value, expression) {\n  var count = value.match(expression);\n  return (count ? count.length : 0) / value.length || 0;\n}\n\n/**\n * Get the distance between an array of trigram--count\n * tuples, and multiple trigram dictionaries.\n *\n * @param {Array.<Array.<string, number>>} trigrams - An\n *   array containing trigram--count tuples.\n * @param {Object.<Object>} languages - multiple\n *   trigrams to test against.\n * @param {Object} options - Configuration.\n * @return {Array.<Array.<string, number>>} An array\n *   containing language--distance tuples.\n */\nfunction getDistances(trigrams, languages, options) {\n  var distances = [];\n  var whitelist = options.whitelist || [];\n  var blacklist = options.blacklist || [];\n  var language;\n  languages = filterLanguages(languages, whitelist, blacklist);\n  for (language in languages) {\n    distances.push([language, getDistance(trigrams, languages[language])]);\n  }\n  return distances.length ? distances.sort(sort) : und();\n}\n\n/**\n * Get the distance between an array of trigram--count\n * tuples, and a language dictionary.\n *\n * @param {Array.<Array.<string, number>>} trigrams - An\n *   array containing trigram--count tuples.\n * @param {Object.<number>} model - Object\n *   containing weighted trigrams.\n * @return {number} - The distance between the two.\n */\nfunction getDistance(trigrams, model) {\n  var distance = 0;\n  var index = -1;\n  var length = trigrams.length;\n  var trigram;\n  var difference;\n  while (++index < length) {\n    trigram = trigrams[index];\n    if (trigram[0] in model) {\n      difference = trigram[1] - model[trigram[0]] - 1;\n      if (difference < 0) {\n        difference = -difference;\n      }\n    } else {\n      difference = MAX_DIFFERENCE;\n    }\n    distance += difference;\n  }\n  return distance;\n}\n\n/**\n * Filter `languages` by removing languages in\n * `blacklist`, or including languages in `whitelist`.\n *\n * @param {Object.<Object>} languages - Languages\n *   to filter\n * @param {Array.<string>} whitelist - Whitelisted\n *   languages; if non-empty, only included languages\n *   are kept.\n * @param {Array.<string>} blacklist - Blacklisted\n *   languages; included languages are ignored.\n * @return {Object.<Object>} - Filtered array of\n *   languages.\n */\nfunction filterLanguages(languages, whitelist, blacklist) {\n  var filteredLanguages;\n  var language;\n  if (whitelist.length === 0 && blacklist.length === 0) {\n    return languages;\n  }\n  filteredLanguages = {};\n  for (language in languages) {\n    if ((whitelist.length === 0 || whitelist.indexOf(language) !== -1) && blacklist.indexOf(language) === -1) {\n      filteredLanguages[language] = languages[language];\n    }\n  }\n  return filteredLanguages;\n}\n\n/* Create a single `und` tuple. */\nfunction und() {\n  return singleLanguageTuples('und');\n}\n\n/* Create a single tuple as a list of tuples from a given\n * language code. */\nfunction singleLanguageTuples(language) {\n  return [[language, 1]];\n}\n\n/* Deep regular sort on the number at `1` in both objects. */\nfunction sort(a, b) {\n  return a[1] - b[1];\n}","map":{"version":3,"names":["utilities","require","expressions","data","detect","all","detectAll","module","exports","MAX_LENGTH","MIN_LENGTH","MAX_DIFFERENCE","languages","name","trigrams","model","script","weight","split","length","value","options","settings","minLength","undefined","und","substr","getTopScript","singleLanguageTuples","normalize","getDistances","asTuples","distances","min","max","index","scripts","topCount","topScript","count","getOccurrence","expression","match","whitelist","blacklist","language","filterLanguages","push","getDistance","sort","distance","trigram","difference","filteredLanguages","indexOf","a","b"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/franc/index.js"],"sourcesContent":["'use strict';\n\n/* Load `trigram-utils`. */\nvar utilities = require('trigram-utils');\n\n/* Load `expressions` (regular expressions matching\n * scripts). */\nvar expressions = require('./expressions.js');\n\n/* Load `data` (trigram information per language,\n * per script). */\nvar data = require('./data.json');\n\n/* Expose `detectAll` on `detect`. */\ndetect.all = detectAll;\n\n/* Expose `detect`. */\nmodule.exports = detect;\n\n/* Maximum sample length. */\nvar MAX_LENGTH = 2048;\n\n/* Minimum sample length. */\nvar MIN_LENGTH = 10;\n\n/* The maximum distance to add when a given trigram does\n * not exist in a trigram dictionary. */\nvar MAX_DIFFERENCE = 300;\n\n/* Construct trigram dictionaries. */\n(function () {\n  var languages;\n  var name;\n  var trigrams;\n  var model;\n  var script;\n  var weight;\n\n  for (script in data) {\n    languages = data[script];\n\n    for (name in languages) {\n      model = languages[name].split('|');\n\n      weight = model.length;\n\n      trigrams = {};\n\n      while (weight--) {\n        trigrams[model[weight]] = weight;\n      }\n\n      languages[name] = trigrams;\n    }\n  }\n})();\n\n/**\n * Get the most probable language for the given value.\n *\n * @param {string} value - The value to test.\n * @param {Object} options - Configuration.\n * @return {string} The most probable language.\n */\nfunction detect(value, options) {\n  return detectAll(value, options)[0][0];\n}\n\n/**\n * Get a list of probable languages the given value is\n * written in.\n *\n * @param {string} value - The value to test.\n * @param {Object} options - Configuration.\n * @return {Array.<Array.<string, number>>} An array\n *   containing language--distance tuples.\n */\nfunction detectAll(value, options) {\n  var settings = options || {};\n  var minLength = MIN_LENGTH;\n  var script;\n\n  if (settings.minLength !== null && settings.minLength !== undefined) {\n    minLength = settings.minLength;\n  }\n\n  if (!value || value.length < minLength) {\n    return und();\n  }\n\n  value = value.substr(0, MAX_LENGTH);\n\n  /* Get the script which characters occur the most\n   * in `value`. */\n  script = getTopScript(value, expressions);\n\n  /* One languages exists for the most-used script.\n   *\n   * If no matches occured, such as a digit only string,\n   * exit with `und`. */\n  if (!(script[0] in data)) {\n    return script[1] === 0 ? und() : singleLanguageTuples(script[0]);\n  }\n\n  /* Get all distances for a given script, and\n   * normalize the distance values. */\n  return normalize(value, getDistances(\n    utilities.asTuples(value), data[script[0]], settings\n  ));\n}\n\n/**\n * Normalize the difference for each tuple in\n * `distances`.\n *\n * @param {string} value - Value to normalize.\n * @param {Array.<Array.<string, number>>} distances\n *   - List of distances.\n * @return {Array.<Array.<string, number>>} - Normalized\n *   distances.\n */\nfunction normalize(value, distances) {\n  var min = distances[0][1];\n  var max = (value.length * MAX_DIFFERENCE) - min;\n  var index = -1;\n  var length = distances.length;\n\n  while (++index < length) {\n    distances[index][1] = 1 - ((distances[index][1] - min) / max) || 0;\n  }\n\n  return distances;\n}\n\n/**\n * From `scripts`, get the most occurring expression for\n * `value`.\n *\n * @param {string} value - Value to check.\n * @param {Object.<RegExp>} scripts - Top-Scripts.\n * @return {Array} Top script and its\n *   occurrence percentage.\n */\nfunction getTopScript(value, scripts) {\n  var topCount = -1;\n  var topScript;\n  var script;\n  var count;\n\n  for (script in scripts) {\n    count = getOccurrence(value, scripts[script]);\n\n    if (count > topCount) {\n      topCount = count;\n      topScript = script;\n    }\n  }\n\n  return [topScript, topCount];\n}\n\n/**\n * Get the occurrence ratio of `expression` for `value`.\n *\n * @param {string} value - Value to check.\n * @param {RegExp} expression - Code-point expression.\n * @return {number} Float between 0 and 1.\n */\nfunction getOccurrence(value, expression) {\n  var count = value.match(expression);\n\n  return (count ? count.length : 0) / value.length || 0;\n}\n\n/**\n * Get the distance between an array of trigram--count\n * tuples, and multiple trigram dictionaries.\n *\n * @param {Array.<Array.<string, number>>} trigrams - An\n *   array containing trigram--count tuples.\n * @param {Object.<Object>} languages - multiple\n *   trigrams to test against.\n * @param {Object} options - Configuration.\n * @return {Array.<Array.<string, number>>} An array\n *   containing language--distance tuples.\n */\nfunction getDistances(trigrams, languages, options) {\n  var distances = [];\n  var whitelist = options.whitelist || [];\n  var blacklist = options.blacklist || [];\n  var language;\n\n  languages = filterLanguages(languages, whitelist, blacklist);\n\n  for (language in languages) {\n    distances.push([\n      language,\n      getDistance(trigrams, languages[language])\n    ]);\n  }\n\n  return distances.length ? distances.sort(sort) : und();\n}\n\n/**\n * Get the distance between an array of trigram--count\n * tuples, and a language dictionary.\n *\n * @param {Array.<Array.<string, number>>} trigrams - An\n *   array containing trigram--count tuples.\n * @param {Object.<number>} model - Object\n *   containing weighted trigrams.\n * @return {number} - The distance between the two.\n */\nfunction getDistance(trigrams, model) {\n  var distance = 0;\n  var index = -1;\n  var length = trigrams.length;\n  var trigram;\n  var difference;\n\n  while (++index < length) {\n    trigram = trigrams[index];\n\n    if (trigram[0] in model) {\n      difference = trigram[1] - model[trigram[0]] - 1;\n\n      if (difference < 0) {\n        difference = -difference;\n      }\n    } else {\n      difference = MAX_DIFFERENCE;\n    }\n\n    distance += difference;\n  }\n\n  return distance;\n}\n\n/**\n * Filter `languages` by removing languages in\n * `blacklist`, or including languages in `whitelist`.\n *\n * @param {Object.<Object>} languages - Languages\n *   to filter\n * @param {Array.<string>} whitelist - Whitelisted\n *   languages; if non-empty, only included languages\n *   are kept.\n * @param {Array.<string>} blacklist - Blacklisted\n *   languages; included languages are ignored.\n * @return {Object.<Object>} - Filtered array of\n *   languages.\n */\nfunction filterLanguages(languages, whitelist, blacklist) {\n  var filteredLanguages;\n  var language;\n\n  if (whitelist.length === 0 && blacklist.length === 0) {\n    return languages;\n  }\n\n  filteredLanguages = {};\n\n  for (language in languages) {\n    if (\n      (\n        whitelist.length === 0 ||\n        whitelist.indexOf(language) !== -1\n      ) &&\n      blacklist.indexOf(language) === -1\n    ) {\n      filteredLanguages[language] = languages[language];\n    }\n  }\n\n  return filteredLanguages;\n}\n\n/* Create a single `und` tuple. */\nfunction und() {\n  return singleLanguageTuples('und');\n}\n\n/* Create a single tuple as a list of tuples from a given\n * language code. */\nfunction singleLanguageTuples(language) {\n  return [[language, 1]];\n}\n\n/* Deep regular sort on the number at `1` in both objects. */\nfunction sort(a, b) {\n  return a[1] - b[1];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}