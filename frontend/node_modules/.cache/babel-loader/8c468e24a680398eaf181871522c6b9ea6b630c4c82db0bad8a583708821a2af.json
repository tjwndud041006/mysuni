{"ast":null,"code":"import { noop, getTense } from '../lib.js';\nconst keep = {\n  tags: true\n};\nconst simple = (vb, parsed) => {\n  const {\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const {\n    root,\n    auxiliary\n  } = parsed;\n  // 'i may'\n  if (root.has('#Modal')) {\n    return vb;\n  }\n  let str = root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  if (str) {\n    vb = vb.replace(root, str, keep);\n    vb.not('#Particle').tag('Verb');\n  }\n  vb.prepend('will').match('will').tag('Auxiliary');\n  vb.remove(auxiliary);\n  return vb;\n};\n\n// 'will be walking'\nconst progressive = (vb, parsed) => {\n  const {\n    conjugate,\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const {\n    root,\n    auxiliary\n  } = parsed;\n  let str = root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  if (str) {\n    str = conjugate(str, vb.model).Gerund;\n    vb.replace(root, str, keep);\n    vb.not('#Particle').tag('PresentTense');\n  }\n  vb.remove(auxiliary);\n  vb.prepend('will be').match('will be').tag('Auxiliary');\n  return vb;\n};\nconst forms = {\n  // walk ->\n  'infinitive': simple,\n  // he walks ->\n  'simple-present': simple,\n  // he walked\n  'simple-past': simple,\n  // he will walk ->\n  'simple-future': noop,\n  // is walking ->\n  'present-progressive': progressive,\n  // was walking ->\n  'past-progressive': progressive,\n  // will be walking ->\n  'future-progressive': noop,\n  // has walked ->\n  'present-perfect': vb => {\n    vb.match('(have|has)').replaceWith('will have');\n    return vb;\n  },\n  // had walked ->\n  'past-perfect': vb => vb.replace('(had|has)', 'will have'),\n  // will have walked ->\n  'future-perfect': noop,\n  // has been walking\n  'present-perfect-progressive': vb => vb.replace('has', 'will have'),\n  // had been walking\n  'past-perfect-progressive': vb => vb.replace('had', 'will have'),\n  // will have been ->\n  'future-perfect-progressive': noop,\n  // got walked ->\n  // was walked ->\n  // was being walked ->\n  // had been walked ->\n  'passive-past': vb => {\n    if (vb.has('got')) {\n      return vb.replace('got', 'will get');\n    }\n    if (vb.has('(was|were)')) {\n      vb.replace('(was|were)', 'will be');\n      return vb.remove('being');\n    }\n    if (vb.has('(have|has|had) been')) {\n      return vb.replace('(have|has|had) been', 'will be');\n    }\n    return vb;\n  },\n  // is being walked  ->\n  'passive-present': vb => {\n    vb.replace('being', 'will be');\n    vb.remove('(is|are|am)');\n    return vb;\n  },\n  // will be walked ->\n  'passive-future': noop,\n  // would be walked ->\n  'present-conditional': vb => vb.replace('would', 'will'),\n  // would have been walked ->\n  'past-conditional': vb => vb.replace('would', 'will'),\n  // is going to drink ->\n  'auxiliary-future': noop,\n  // used to walk -> is walking\n  // did walk -> is walking\n  'auxiliary-past': vb => {\n    if (vb.has('used') && vb.has('to')) {\n      vb.replace('used', 'will');\n      return vb.remove('to');\n    }\n    vb.replace('did', 'will');\n    return vb;\n  },\n  // we do walk ->\n  // he does walk ->\n  'auxiliary-present': vb => {\n    return vb.replace('(do|does)', 'will');\n  },\n  // must walk ->\n  'modal-infinitive': noop,\n  // must have walked\n  'modal-past': noop,\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$');\n    simple(vb, parsed);\n    return vb.remove('(had|have)');\n  },\n  // wanted to walk\n  'want-infinitive': vb => {\n    vb.replace('(want|wants|wanted)', 'will want');\n    return vb;\n  }\n};\nconst toFuture = function (vb, parsed, form) {\n  // console.log(form)\n  // is it already future-tense?\n  if (vb.has('will') || vb.has('going to')) {\n    return vb;\n  }\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed);\n    vb.fullSentence().compute(['tagger', 'chunks']);\n    return vb;\n  }\n  return vb;\n};\nexport default toFuture;","map":{"version":3,"names":["noop","getTense","keep","tags","simple","vb","parsed","toInfinitive","methods","two","transform","verb","root","auxiliary","has","str","text","model","replace","not","tag","prepend","match","remove","progressive","conjugate","Gerund","forms","replaceWith","gerund-phrase","toFuture","form","hasOwnProperty","fullSentence","compute"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toFuture.js"],"sourcesContent":["import { noop, getTense } from '../lib.js'\nconst keep = { tags: true }\n\nconst simple = (vb, parsed) => {\n  const { toInfinitive } = vb.methods.two.transform.verb\n  const { root, auxiliary } = parsed\n  // 'i may'\n  if (root.has('#Modal')) {\n    return vb\n  }\n  let str = root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  if (str) {\n    vb = vb.replace(root, str, keep)\n    vb.not('#Particle').tag('Verb')\n  }\n  vb.prepend('will').match('will').tag('Auxiliary')\n  vb.remove(auxiliary)\n  return vb\n}\n\n// 'will be walking'\nconst progressive = (vb, parsed) => {\n  const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n  const { root, auxiliary } = parsed\n  let str = root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  if (str) {\n    str = conjugate(str, vb.model).Gerund\n    vb.replace(root, str, keep)\n    vb.not('#Particle').tag('PresentTense')\n  }\n  vb.remove(auxiliary)\n  vb.prepend('will be').match('will be').tag('Auxiliary')\n  return vb\n}\n\nconst forms = {\n  // walk ->\n  'infinitive': simple,\n  // he walks ->\n  'simple-present': simple,\n  // he walked\n  'simple-past': simple,\n  // he will walk ->\n  'simple-future': noop,\n\n  // is walking ->\n  'present-progressive': progressive,\n  // was walking ->\n  'past-progressive': progressive,\n  // will be walking ->\n  'future-progressive': noop,\n\n  // has walked ->\n  'present-perfect': (vb) => {\n    vb.match('(have|has)').replaceWith('will have')\n    return vb\n  },\n  // had walked ->\n  'past-perfect': vb => vb.replace('(had|has)', 'will have'),\n  // will have walked ->\n  'future-perfect': noop,\n\n  // has been walking\n  'present-perfect-progressive': vb => vb.replace('has', 'will have'),\n  // had been walking\n  'past-perfect-progressive': vb => vb.replace('had', 'will have'),\n  // will have been ->\n  'future-perfect-progressive': noop,\n\n  // got walked ->\n  // was walked ->\n  // was being walked ->\n  // had been walked ->\n  'passive-past': vb => {\n    if (vb.has('got')) {\n      return vb.replace('got', 'will get')\n    }\n    if (vb.has('(was|were)')) {\n      vb.replace('(was|were)', 'will be')\n      return vb.remove('being')\n    }\n    if (vb.has('(have|has|had) been')) {\n      return vb.replace('(have|has|had) been', 'will be')\n    }\n    return vb\n  },\n  // is being walked  ->\n  'passive-present': vb => {\n    vb.replace('being', 'will be')\n    vb.remove('(is|are|am)')\n    return vb\n  },\n  // will be walked ->\n  'passive-future': noop,\n  // would be walked ->\n  'present-conditional': vb => vb.replace('would', 'will'),\n  // would have been walked ->\n  'past-conditional': vb => vb.replace('would', 'will'),\n\n  // is going to drink ->\n  'auxiliary-future': noop,\n  // used to walk -> is walking\n  // did walk -> is walking\n  'auxiliary-past': vb => {\n    if (vb.has('used') && vb.has('to')) {\n      vb.replace('used', 'will')\n      return vb.remove('to')\n    }\n    vb.replace('did', 'will')\n    return vb\n  },\n  // we do walk ->\n  // he does walk ->\n  'auxiliary-present': vb => {\n    return vb.replace('(do|does)', 'will')\n  },\n\n  // must walk ->\n  'modal-infinitive': noop,\n  // must have walked\n  'modal-past': noop,\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$')\n    simple(vb, parsed)\n    return vb.remove('(had|have)')\n  },\n  // wanted to walk\n  'want-infinitive': vb => {\n    vb.replace('(want|wants|wanted)', 'will want')\n    return vb\n  },\n}\n\nconst toFuture = function (vb, parsed, form) {\n  // console.log(form)\n  // is it already future-tense?\n  if (vb.has('will') || vb.has('going to')) {\n    return vb\n  }\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed)\n    vb.fullSentence().compute(['tagger', 'chunks'])\n    return vb\n  }\n  return vb\n}\nexport default toFuture\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}