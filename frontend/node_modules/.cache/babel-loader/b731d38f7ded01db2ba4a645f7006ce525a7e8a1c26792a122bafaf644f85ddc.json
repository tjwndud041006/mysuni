{"ast":null,"code":"import findMain from './mainClause.js';\nconst grammar = function (vb) {\n  let tense = null;\n  if (vb.has('#PastTense')) {\n    tense = 'PastTense';\n  } else if (vb.has('#FutureTense')) {\n    tense = 'FutureTense';\n  } else if (vb.has('#PresentTense')) {\n    tense = 'PresentTense';\n  }\n  return {\n    tense\n  };\n};\nconst parse = function (s) {\n  let clauses = s.clauses();\n  let main = findMain(clauses);\n  let chunks = main.chunks();\n  let subj = s.none();\n  let verb = s.none();\n  let pred = s.none();\n  chunks.forEach((ch, i) => {\n    if (i === 0 && !ch.has('<Verb>')) {\n      subj = ch;\n      return;\n    }\n    if (!verb.found && ch.has('<Verb>')) {\n      verb = ch;\n      return;\n    }\n    if (verb.found) {\n      pred = pred.concat(ch);\n    }\n  });\n  // cleanup a missed parse\n  if (verb.found && !subj.found) {\n    subj = verb.before('<Noun>+').first();\n  }\n  return {\n    subj,\n    verb,\n    pred,\n    grammar: grammar(verb)\n  };\n};\nexport default parse;","map":{"version":3,"names":["findMain","grammar","vb","tense","has","parse","s","clauses","main","chunks","subj","none","verb","pred","forEach","ch","i","found","concat","before","first"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/sentences/parse/index.js"],"sourcesContent":["import findMain from './mainClause.js'\n\nconst grammar = function (vb) {\n  let tense = null\n  if (vb.has('#PastTense')) {\n    tense = 'PastTense'\n  } else if (vb.has('#FutureTense')) {\n    tense = 'FutureTense'\n  } else if (vb.has('#PresentTense')) {\n    tense = 'PresentTense'\n  }\n  return {\n    tense\n  }\n}\n\nconst parse = function (s) {\n  let clauses = s.clauses()\n  let main = findMain(clauses)\n  let chunks = main.chunks()\n  let subj = s.none()\n  let verb = s.none()\n  let pred = s.none()\n  chunks.forEach((ch, i) => {\n    if (i === 0 && !ch.has('<Verb>')) {\n      subj = ch\n      return\n    }\n    if (!verb.found && ch.has('<Verb>')) {\n      verb = ch\n      return\n    }\n    if (verb.found) {\n      pred = pred.concat(ch)\n    }\n  })\n  // cleanup a missed parse\n  if (verb.found && !subj.found) {\n    subj = verb.before('<Noun>+').first()\n  }\n  return {\n    subj,\n    verb,\n    pred,\n    grammar: grammar(verb)\n  }\n}\nexport default parse"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,iBAAiB;AAEtC,MAAMC,OAAO,GAAG,SAAAA,CAAUC,EAAE,EAAE;EAC5B,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAID,EAAE,CAACE,GAAG,CAAC,YAAY,CAAC,EAAE;IACxBD,KAAK,GAAG,WAAW;EACrB,CAAC,MAAM,IAAID,EAAE,CAACE,GAAG,CAAC,cAAc,CAAC,EAAE;IACjCD,KAAK,GAAG,aAAa;EACvB,CAAC,MAAM,IAAID,EAAE,CAACE,GAAG,CAAC,eAAe,CAAC,EAAE;IAClCD,KAAK,GAAG,cAAc;EACxB;EACA,OAAO;IACLA;EACF,CAAC;AACH,CAAC;AAED,MAAME,KAAK,GAAG,SAAAA,CAAUC,CAAC,EAAE;EACzB,IAAIC,OAAO,GAAGD,CAAC,CAACC,OAAO,CAAC,CAAC;EACzB,IAAIC,IAAI,GAAGR,QAAQ,CAACO,OAAO,CAAC;EAC5B,IAAIE,MAAM,GAAGD,IAAI,CAACC,MAAM,CAAC,CAAC;EAC1B,IAAIC,IAAI,GAAGJ,CAAC,CAACK,IAAI,CAAC,CAAC;EACnB,IAAIC,IAAI,GAAGN,CAAC,CAACK,IAAI,CAAC,CAAC;EACnB,IAAIE,IAAI,GAAGP,CAAC,CAACK,IAAI,CAAC,CAAC;EACnBF,MAAM,CAACK,OAAO,CAAC,CAACC,EAAE,EAAEC,CAAC,KAAK;IACxB,IAAIA,CAAC,KAAK,CAAC,IAAI,CAACD,EAAE,CAACX,GAAG,CAAC,QAAQ,CAAC,EAAE;MAChCM,IAAI,GAAGK,EAAE;MACT;IACF;IACA,IAAI,CAACH,IAAI,CAACK,KAAK,IAAIF,EAAE,CAACX,GAAG,CAAC,QAAQ,CAAC,EAAE;MACnCQ,IAAI,GAAGG,EAAE;MACT;IACF;IACA,IAAIH,IAAI,CAACK,KAAK,EAAE;MACdJ,IAAI,GAAGA,IAAI,CAACK,MAAM,CAACH,EAAE,CAAC;IACxB;EACF,CAAC,CAAC;EACF;EACA,IAAIH,IAAI,CAACK,KAAK,IAAI,CAACP,IAAI,CAACO,KAAK,EAAE;IAC7BP,IAAI,GAAGE,IAAI,CAACO,MAAM,CAAC,SAAS,CAAC,CAACC,KAAK,CAAC,CAAC;EACvC;EACA,OAAO;IACLV,IAAI;IACJE,IAAI;IACJC,IAAI;IACJZ,OAAO,EAAEA,OAAO,CAACW,IAAI;EACvB,CAAC;AACH,CAAC;AACD,eAAeP,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}