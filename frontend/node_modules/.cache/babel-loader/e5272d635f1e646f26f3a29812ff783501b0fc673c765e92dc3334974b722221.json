{"ast":null,"code":"import findModifiers from './findModifiers.js';\nimport words from './data.js';\nimport isValid from './validate.js';\nimport parseDecimals from './parseDecimals.js';\nimport parseNumeric from './parseNumeric.js';\nconst improperFraction = /^([0-9,. ]+)\\/([0-9,. ]+)$/;\n\n//some numbers we know\nconst casualForms = {\n  'a few': 3,\n  'a couple': 2,\n  'a dozen': 12,\n  'two dozen': 24,\n  zero: 0\n};\n\n// a 'section' is something like 'fifty-nine thousand'\n// turn a section into something we can add to - like 59000\nconst section_sum = obj => {\n  return Object.keys(obj).reduce((sum, k) => {\n    sum += obj[k];\n    return sum;\n  }, 0);\n};\n\n//turn a string into a number\nconst parse = function (str) {\n  //convert some known-numbers\n  if (casualForms.hasOwnProperty(str) === true) {\n    return casualForms[str];\n  }\n  //'a/an' is 1\n  if (str === 'a' || str === 'an') {\n    return 1;\n  }\n  const modifier = findModifiers(str);\n  str = modifier.str;\n  let last_mult = null;\n  let has = {};\n  let sum = 0;\n  let isNegative = false;\n  const terms = str.split(/[ -]/);\n  // const isFraction = findFraction(terms)\n  for (let i = 0; i < terms.length; i++) {\n    let w = terms[i];\n    w = parseNumeric(w);\n    if (!w || w === 'and') {\n      continue;\n    }\n    if (w === '-' || w === 'negative') {\n      isNegative = true;\n      continue;\n    }\n    if (w.charAt(0) === '-') {\n      isNegative = true;\n      w = w.substring(1);\n    }\n\n    //decimal mode\n    if (w === 'point') {\n      sum += section_sum(has);\n      sum += parseDecimals(terms.slice(i + 1, terms.length));\n      sum *= modifier.amount;\n      return sum;\n    }\n\n    //improper fraction\n    const fm = w.match(improperFraction);\n    if (fm) {\n      const num = parseFloat(fm[1].replace(/[, ]/g, ''));\n      const denom = parseFloat(fm[2].replace(/[, ]/g, ''));\n      if (denom) {\n        sum += num / denom || 0;\n      }\n      continue;\n    }\n    // try to support 'two fifty'\n    if (words.tens.hasOwnProperty(w)) {\n      if (has.ones && Object.keys(has).length === 1) {\n        sum = has.ones * 100;\n        has = {};\n      }\n    }\n\n    //prevent mismatched units, like 'seven eleven' if not a fraction\n    if (isValid(w, has) === false) {\n      return null;\n    }\n\n    //buildOut section, collect 'has' values\n    if (/^[0-9.]+$/.test(w)) {\n      has.ones = parseFloat(w); //not technically right\n    } else if (words.ones.hasOwnProperty(w) === true) {\n      has.ones = words.ones[w];\n    } else if (words.teens.hasOwnProperty(w) === true) {\n      has.teens = words.teens[w];\n    } else if (words.tens.hasOwnProperty(w) === true) {\n      has.tens = words.tens[w];\n    } else if (words.multiples.hasOwnProperty(w) === true) {\n      let mult = words.multiples[w];\n\n      //something has gone wrong : 'two hundred five hundred'\n      //possibly because it's a fraction\n      if (mult === last_mult) {\n        return null;\n      }\n      //support 'hundred thousand'\n      //this one is tricky..\n      if (mult === 100 && terms[i + 1] !== undefined) {\n        const w2 = terms[i + 1];\n        if (words.multiples[w2]) {\n          mult *= words.multiples[w2]; //hundredThousand/hundredMillion\n          i += 1;\n        }\n      }\n      //natural order of things\n      //five thousand, one hundred..\n      if (last_mult === null || mult < last_mult) {\n        sum += (section_sum(has) || 1) * mult;\n        last_mult = mult;\n        has = {};\n      } else {\n        //maybe hundred .. thousand\n        sum += section_sum(has);\n        last_mult = mult;\n        sum = (sum || 1) * mult;\n        has = {};\n      }\n    }\n  }\n  //dump the remaining has values\n  sum += section_sum(has);\n  //post-process add modifier\n  sum *= modifier.amount;\n  sum *= isNegative ? -1 : 1;\n  //dont return 0, if it went straight-through\n  if (sum === 0 && Object.keys(has).length === 0) {\n    return null;\n  }\n  return sum;\n};\nexport default parse;","map":{"version":3,"names":["findModifiers","words","isValid","parseDecimals","parseNumeric","improperFraction","casualForms","zero","section_sum","obj","Object","keys","reduce","sum","k","parse","str","hasOwnProperty","modifier","last_mult","has","isNegative","terms","split","i","length","w","charAt","substring","slice","amount","fm","match","num","parseFloat","replace","denom","tens","ones","test","teens","multiples","mult","undefined","w2"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/index.js"],"sourcesContent":["import findModifiers from './findModifiers.js'\nimport words from './data.js'\nimport isValid from './validate.js'\nimport parseDecimals from './parseDecimals.js'\nimport parseNumeric from './parseNumeric.js'\nconst improperFraction = /^([0-9,. ]+)\\/([0-9,. ]+)$/\n\n//some numbers we know\nconst casualForms = {\n  'a few': 3,\n  'a couple': 2,\n  'a dozen': 12,\n  'two dozen': 24,\n  zero: 0,\n}\n\n// a 'section' is something like 'fifty-nine thousand'\n// turn a section into something we can add to - like 59000\nconst section_sum = obj => {\n  return Object.keys(obj).reduce((sum, k) => {\n    sum += obj[k]\n    return sum\n  }, 0)\n}\n\n//turn a string into a number\nconst parse = function (str) {\n  //convert some known-numbers\n  if (casualForms.hasOwnProperty(str) === true) {\n    return casualForms[str]\n  }\n  //'a/an' is 1\n  if (str === 'a' || str === 'an') {\n    return 1\n  }\n  const modifier = findModifiers(str)\n  str = modifier.str\n  let last_mult = null\n  let has = {}\n  let sum = 0\n  let isNegative = false\n  const terms = str.split(/[ -]/)\n  // const isFraction = findFraction(terms)\n  for (let i = 0; i < terms.length; i++) {\n    let w = terms[i]\n    w = parseNumeric(w)\n\n    if (!w || w === 'and') {\n      continue\n    }\n    if (w === '-' || w === 'negative') {\n      isNegative = true\n      continue\n    }\n    if (w.charAt(0) === '-') {\n      isNegative = true\n      w = w.substring(1)\n    }\n\n    //decimal mode\n    if (w === 'point') {\n      sum += section_sum(has)\n      sum += parseDecimals(terms.slice(i + 1, terms.length))\n      sum *= modifier.amount\n      return sum\n    }\n\n    //improper fraction\n    const fm = w.match(improperFraction)\n    if (fm) {\n      const num = parseFloat(fm[1].replace(/[, ]/g, ''))\n      const denom = parseFloat(fm[2].replace(/[, ]/g, ''))\n      if (denom) {\n        sum += num / denom || 0\n      }\n      continue\n    }\n    // try to support 'two fifty'\n    if (words.tens.hasOwnProperty(w)) {\n      if (has.ones && Object.keys(has).length === 1) {\n        sum = has.ones * 100\n        has = {}\n      }\n    }\n\n    //prevent mismatched units, like 'seven eleven' if not a fraction\n    if (isValid(w, has) === false) {\n      return null\n    }\n\n    //buildOut section, collect 'has' values\n    if (/^[0-9.]+$/.test(w)) {\n      has.ones = parseFloat(w) //not technically right\n    } else if (words.ones.hasOwnProperty(w) === true) {\n      has.ones = words.ones[w]\n    } else if (words.teens.hasOwnProperty(w) === true) {\n      has.teens = words.teens[w]\n    } else if (words.tens.hasOwnProperty(w) === true) {\n      has.tens = words.tens[w]\n    } else if (words.multiples.hasOwnProperty(w) === true) {\n      let mult = words.multiples[w]\n\n      //something has gone wrong : 'two hundred five hundred'\n      //possibly because it's a fraction\n      if (mult === last_mult) {\n        return null\n      }\n      //support 'hundred thousand'\n      //this one is tricky..\n      if (mult === 100 && terms[i + 1] !== undefined) {\n        const w2 = terms[i + 1]\n        if (words.multiples[w2]) {\n          mult *= words.multiples[w2] //hundredThousand/hundredMillion\n          i += 1\n        }\n      }\n      //natural order of things\n      //five thousand, one hundred..\n      if (last_mult === null || mult < last_mult) {\n        sum += (section_sum(has) || 1) * mult\n        last_mult = mult\n        has = {}\n      } else {\n        //maybe hundred .. thousand\n        sum += section_sum(has)\n        last_mult = mult\n        sum = (sum || 1) * mult\n        has = {}\n      }\n    }\n  }\n  //dump the remaining has values\n  sum += section_sum(has)\n  //post-process add modifier\n  sum *= modifier.amount\n  sum *= isNegative ? -1 : 1\n  //dont return 0, if it went straight-through\n  if (sum === 0 && Object.keys(has).length === 0) {\n    return null\n  }\n  return sum\n}\n\nexport default parse\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,KAAK,MAAM,WAAW;AAC7B,OAAOC,OAAO,MAAM,eAAe;AACnC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,MAAMC,gBAAgB,GAAG,4BAA4B;;AAErD;AACA,MAAMC,WAAW,GAAG;EAClB,OAAO,EAAE,CAAC;EACV,UAAU,EAAE,CAAC;EACb,SAAS,EAAE,EAAE;EACb,WAAW,EAAE,EAAE;EACfC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA,MAAMC,WAAW,GAAGC,GAAG,IAAI;EACzB,OAAOC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;IACzCD,GAAG,IAAIJ,GAAG,CAACK,CAAC,CAAC;IACb,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC;AACP,CAAC;;AAED;AACA,MAAME,KAAK,GAAG,SAAAA,CAAUC,GAAG,EAAE;EAC3B;EACA,IAAIV,WAAW,CAACW,cAAc,CAACD,GAAG,CAAC,KAAK,IAAI,EAAE;IAC5C,OAAOV,WAAW,CAACU,GAAG,CAAC;EACzB;EACA;EACA,IAAIA,GAAG,KAAK,GAAG,IAAIA,GAAG,KAAK,IAAI,EAAE;IAC/B,OAAO,CAAC;EACV;EACA,MAAME,QAAQ,GAAGlB,aAAa,CAACgB,GAAG,CAAC;EACnCA,GAAG,GAAGE,QAAQ,CAACF,GAAG;EAClB,IAAIG,SAAS,GAAG,IAAI;EACpB,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,IAAIP,GAAG,GAAG,CAAC;EACX,IAAIQ,UAAU,GAAG,KAAK;EACtB,MAAMC,KAAK,GAAGN,GAAG,CAACO,KAAK,CAAC,MAAM,CAAC;EAC/B;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIE,CAAC,GAAGJ,KAAK,CAACE,CAAC,CAAC;IAChBE,CAAC,GAAGtB,YAAY,CAACsB,CAAC,CAAC;IAEnB,IAAI,CAACA,CAAC,IAAIA,CAAC,KAAK,KAAK,EAAE;MACrB;IACF;IACA,IAAIA,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,UAAU,EAAE;MACjCL,UAAU,GAAG,IAAI;MACjB;IACF;IACA,IAAIK,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACvBN,UAAU,GAAG,IAAI;MACjBK,CAAC,GAAGA,CAAC,CAACE,SAAS,CAAC,CAAC,CAAC;IACpB;;IAEA;IACA,IAAIF,CAAC,KAAK,OAAO,EAAE;MACjBb,GAAG,IAAIL,WAAW,CAACY,GAAG,CAAC;MACvBP,GAAG,IAAIV,aAAa,CAACmB,KAAK,CAACO,KAAK,CAACL,CAAC,GAAG,CAAC,EAAEF,KAAK,CAACG,MAAM,CAAC,CAAC;MACtDZ,GAAG,IAAIK,QAAQ,CAACY,MAAM;MACtB,OAAOjB,GAAG;IACZ;;IAEA;IACA,MAAMkB,EAAE,GAAGL,CAAC,CAACM,KAAK,CAAC3B,gBAAgB,CAAC;IACpC,IAAI0B,EAAE,EAAE;MACN,MAAME,GAAG,GAAGC,UAAU,CAACH,EAAE,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;MAClD,MAAMC,KAAK,GAAGF,UAAU,CAACH,EAAE,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;MACpD,IAAIC,KAAK,EAAE;QACTvB,GAAG,IAAIoB,GAAG,GAAGG,KAAK,IAAI,CAAC;MACzB;MACA;IACF;IACA;IACA,IAAInC,KAAK,CAACoC,IAAI,CAACpB,cAAc,CAACS,CAAC,CAAC,EAAE;MAChC,IAAIN,GAAG,CAACkB,IAAI,IAAI5B,MAAM,CAACC,IAAI,CAACS,GAAG,CAAC,CAACK,MAAM,KAAK,CAAC,EAAE;QAC7CZ,GAAG,GAAGO,GAAG,CAACkB,IAAI,GAAG,GAAG;QACpBlB,GAAG,GAAG,CAAC,CAAC;MACV;IACF;;IAEA;IACA,IAAIlB,OAAO,CAACwB,CAAC,EAAEN,GAAG,CAAC,KAAK,KAAK,EAAE;MAC7B,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,WAAW,CAACmB,IAAI,CAACb,CAAC,CAAC,EAAE;MACvBN,GAAG,CAACkB,IAAI,GAAGJ,UAAU,CAACR,CAAC,CAAC,EAAC;IAC3B,CAAC,MAAM,IAAIzB,KAAK,CAACqC,IAAI,CAACrB,cAAc,CAACS,CAAC,CAAC,KAAK,IAAI,EAAE;MAChDN,GAAG,CAACkB,IAAI,GAAGrC,KAAK,CAACqC,IAAI,CAACZ,CAAC,CAAC;IAC1B,CAAC,MAAM,IAAIzB,KAAK,CAACuC,KAAK,CAACvB,cAAc,CAACS,CAAC,CAAC,KAAK,IAAI,EAAE;MACjDN,GAAG,CAACoB,KAAK,GAAGvC,KAAK,CAACuC,KAAK,CAACd,CAAC,CAAC;IAC5B,CAAC,MAAM,IAAIzB,KAAK,CAACoC,IAAI,CAACpB,cAAc,CAACS,CAAC,CAAC,KAAK,IAAI,EAAE;MAChDN,GAAG,CAACiB,IAAI,GAAGpC,KAAK,CAACoC,IAAI,CAACX,CAAC,CAAC;IAC1B,CAAC,MAAM,IAAIzB,KAAK,CAACwC,SAAS,CAACxB,cAAc,CAACS,CAAC,CAAC,KAAK,IAAI,EAAE;MACrD,IAAIgB,IAAI,GAAGzC,KAAK,CAACwC,SAAS,CAACf,CAAC,CAAC;;MAE7B;MACA;MACA,IAAIgB,IAAI,KAAKvB,SAAS,EAAE;QACtB,OAAO,IAAI;MACb;MACA;MACA;MACA,IAAIuB,IAAI,KAAK,GAAG,IAAIpB,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC,KAAKmB,SAAS,EAAE;QAC9C,MAAMC,EAAE,GAAGtB,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC;QACvB,IAAIvB,KAAK,CAACwC,SAAS,CAACG,EAAE,CAAC,EAAE;UACvBF,IAAI,IAAIzC,KAAK,CAACwC,SAAS,CAACG,EAAE,CAAC,EAAC;UAC5BpB,CAAC,IAAI,CAAC;QACR;MACF;MACA;MACA;MACA,IAAIL,SAAS,KAAK,IAAI,IAAIuB,IAAI,GAAGvB,SAAS,EAAE;QAC1CN,GAAG,IAAI,CAACL,WAAW,CAACY,GAAG,CAAC,IAAI,CAAC,IAAIsB,IAAI;QACrCvB,SAAS,GAAGuB,IAAI;QAChBtB,GAAG,GAAG,CAAC,CAAC;MACV,CAAC,MAAM;QACL;QACAP,GAAG,IAAIL,WAAW,CAACY,GAAG,CAAC;QACvBD,SAAS,GAAGuB,IAAI;QAChB7B,GAAG,GAAG,CAACA,GAAG,IAAI,CAAC,IAAI6B,IAAI;QACvBtB,GAAG,GAAG,CAAC,CAAC;MACV;IACF;EACF;EACA;EACAP,GAAG,IAAIL,WAAW,CAACY,GAAG,CAAC;EACvB;EACAP,GAAG,IAAIK,QAAQ,CAACY,MAAM;EACtBjB,GAAG,IAAIQ,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC;EAC1B;EACA,IAAIR,GAAG,KAAK,CAAC,IAAIH,MAAM,CAACC,IAAI,CAACS,GAAG,CAAC,CAACK,MAAM,KAAK,CAAC,EAAE;IAC9C,OAAO,IAAI;EACb;EACA,OAAOZ,GAAG;AACZ,CAAC;AAED,eAAeE,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}