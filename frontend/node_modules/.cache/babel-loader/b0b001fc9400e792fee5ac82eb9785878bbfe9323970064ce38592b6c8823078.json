{"ast":null,"code":"import swapVerb from './swap-verb.js';\nconst swapNoun = function (m, lemma) {\n  let str = lemma;\n  if (m.has('#Plural')) {\n    const toPlural = m.methods.two.transform.noun.toPlural;\n    str = toPlural(lemma, m.model);\n  }\n  m.replaceWith(str, {\n    possessives: true\n  });\n};\nconst swapAdverb = function (m, lemma) {\n  const {\n    toAdverb\n  } = m.methods.two.transform.adjective;\n  let str = lemma;\n  let adv = toAdverb(str);\n  if (adv) {\n    m.replaceWith(adv);\n  }\n};\nconst swapAdjective = function (m, lemma) {\n  const {\n    toComparative,\n    toSuperlative\n  } = m.methods.two.transform.adjective;\n  let str = lemma;\n  if (m.has('#Comparative')) {\n    str = toComparative(str, m.model);\n  } else if (m.has('#Superlative')) {\n    str = toSuperlative(str, m.model);\n  }\n  if (str) {\n    m.replaceWith(str);\n  }\n};\nconst swap = function (from, to, tag) {\n  let reg = from.split(/ /g).map(str => str.toLowerCase().trim());\n  reg = reg.filter(str => str);\n  reg = reg.map(str => `{${str}}`).join(' ');\n  let m = this.match(reg);\n  // guard against some homonyms\n  if (tag) {\n    m = m.if(tag);\n  }\n  if (m.has('#Verb')) {\n    return swapVerb(m, to);\n  }\n  if (m.has('#Noun')) {\n    return swapNoun(m, to);\n  }\n  if (m.has('#Adverb')) {\n    return swapAdverb(m, to);\n  }\n  if (m.has('#Adjective')) {\n    return swapAdjective(m, to);\n  }\n  return this;\n};\nexport default swap;","map":{"version":3,"names":["swapVerb","swapNoun","m","lemma","str","has","toPlural","methods","two","transform","noun","model","replaceWith","possessives","swapAdverb","toAdverb","adjective","adv","swapAdjective","toComparative","toSuperlative","swap","from","to","tag","reg","split","map","toLowerCase","trim","filter","join","match","if"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/swap/api/swap.js"],"sourcesContent":["import swapVerb from './swap-verb.js'\n\nconst swapNoun = function (m, lemma) {\n  let str = lemma\n  if (m.has('#Plural')) {\n    const toPlural = m.methods.two.transform.noun.toPlural\n    str = toPlural(lemma, m.model)\n  }\n  m.replaceWith(str, { possessives: true })\n}\n\nconst swapAdverb = function (m, lemma) {\n  const { toAdverb } = m.methods.two.transform.adjective\n  let str = lemma\n  let adv = toAdverb(str)\n  if (adv) {\n    m.replaceWith(adv)\n  }\n}\nconst swapAdjective = function (m, lemma) {\n  const { toComparative, toSuperlative } = m.methods.two.transform.adjective\n  let str = lemma\n  if (m.has('#Comparative')) {\n    str = toComparative(str, m.model)\n  } else if (m.has('#Superlative')) {\n    str = toSuperlative(str, m.model)\n  }\n  if (str) {\n    m.replaceWith(str)\n  }\n}\n\nconst swap = function (from, to, tag) {\n  let reg = from.split(/ /g).map(str => str.toLowerCase().trim())\n  reg = reg.filter(str => str)\n  reg = reg.map(str => `{${str}}`).join(' ')\n  let m = this.match(reg)\n  // guard against some homonyms\n  if (tag) {\n    m = m.if(tag)\n  }\n  if (m.has('#Verb')) {\n    return swapVerb(m, to)\n  }\n  if (m.has('#Noun')) {\n    return swapNoun(m, to)\n  }\n  if (m.has('#Adverb')) {\n    return swapAdverb(m, to)\n  }\n  if (m.has('#Adjective')) {\n    return swapAdjective(m, to)\n  }\n  return this\n}\nexport default swap"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}