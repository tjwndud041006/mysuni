{"ast":null,"code":"// import { toPast, toPresent, toGerund, toParticiple } from '../../../../model/models/index.js'\nimport { convert } from 'suffix-thumb';\n\n// pull-apart phrasal verb 'fall over'\nconst parse = inf => {\n  if (/ /.test(inf)) {\n    return inf.split(/ /);\n  }\n  return [inf, ''];\n};\n\n//we run this on every verb in the lexicon, so please keep it fast\n//we assume the input word is a proper infinitive\nconst conjugate = function (inf, model) {\n  const {\n    toPast,\n    toPresent,\n    toGerund,\n    toParticiple\n  } = model.two.models;\n  // ad-hoc Copula response\n  if (inf === 'be') {\n    return {\n      Infinitive: inf,\n      Gerund: 'being',\n      PastTense: 'was',\n      PresentTense: 'is'\n    };\n  }\n  let [str, particle] = parse(inf);\n  let found = {\n    Infinitive: str,\n    PastTense: convert(str, toPast),\n    PresentTense: convert(str, toPresent),\n    Gerund: convert(str, toGerund),\n    FutureTense: 'will ' + str\n  };\n  // add past-participle if it's interesting\n  // drive -> driven (not drove)\n  let pastPrt = convert(str, toParticiple);\n  if (pastPrt !== inf && pastPrt !== found.PastTense) {\n    // ensure it's a known participle\n    let lex = model.one.lexicon || {};\n    if (lex[pastPrt] === 'Participle' || lex[pastPrt] === 'Adjective') {\n      // one exception\n      if (inf === 'play') {\n        pastPrt = 'played';\n      }\n      found.Participle = pastPrt;\n    }\n  }\n  // put phrasal-verbs back together again\n  if (particle) {\n    Object.keys(found).forEach(k => {\n      found[k] += ' ' + particle;\n    });\n  }\n  return found;\n};\nexport default conjugate;\n\n// console.log(toPresent.rules.y)\n// console.log(convert('buy', toPresent))","map":{"version":3,"names":["convert","parse","inf","test","split","conjugate","model","toPast","toPresent","toGerund","toParticiple","two","models","Infinitive","Gerund","PastTense","PresentTense","str","particle","found","FutureTense","pastPrt","lex","one","lexicon","Participle","Object","keys","forEach","k"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/conjugate/index.js"],"sourcesContent":["// import { toPast, toPresent, toGerund, toParticiple } from '../../../../model/models/index.js'\nimport { convert } from 'suffix-thumb'\n\n// pull-apart phrasal verb 'fall over'\nconst parse = (inf) => {\n  if (/ /.test(inf)) {\n    return inf.split(/ /)\n  }\n  return [inf, '']\n}\n\n//we run this on every verb in the lexicon, so please keep it fast\n//we assume the input word is a proper infinitive\nconst conjugate = function (inf, model) {\n  const { toPast, toPresent, toGerund, toParticiple } = model.two.models\n  // ad-hoc Copula response\n  if (inf === 'be') {\n    return {\n      Infinitive: inf,\n      Gerund: 'being',\n      PastTense: 'was',\n      PresentTense: 'is',\n    }\n  }\n  let [str, particle] = parse(inf)\n  let found = {\n    Infinitive: str,\n    PastTense: convert(str, toPast),\n    PresentTense: convert(str, toPresent),\n    Gerund: convert(str, toGerund),\n    FutureTense: 'will ' + str\n  }\n  // add past-participle if it's interesting\n  // drive -> driven (not drove)\n  let pastPrt = convert(str, toParticiple)\n  if (pastPrt !== inf && pastPrt !== found.PastTense) {\n    // ensure it's a known participle\n    let lex = model.one.lexicon || {}\n    if (lex[pastPrt] === 'Participle' || lex[pastPrt] === 'Adjective') {\n      // one exception\n      if (inf === 'play') {\n        pastPrt = 'played'\n      }\n      found.Participle = pastPrt\n    }\n  }\n  // put phrasal-verbs back together again\n  if (particle) {\n    Object.keys(found).forEach(k => {\n      found[k] += ' ' + particle\n    })\n  }\n  return found\n}\n\n\nexport default conjugate\n\n// console.log(toPresent.rules.y)\n// console.log(convert('buy', toPresent))\n\n"],"mappings":"AAAA;AACA,SAASA,OAAO,QAAQ,cAAc;;AAEtC;AACA,MAAMC,KAAK,GAAIC,GAAG,IAAK;EACrB,IAAI,GAAG,CAACC,IAAI,CAACD,GAAG,CAAC,EAAE;IACjB,OAAOA,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EACvB;EACA,OAAO,CAACF,GAAG,EAAE,EAAE,CAAC;AAClB,CAAC;;AAED;AACA;AACA,MAAMG,SAAS,GAAG,SAAAA,CAAUH,GAAG,EAAEI,KAAK,EAAE;EACtC,MAAM;IAAEC,MAAM;IAAEC,SAAS;IAAEC,QAAQ;IAAEC;EAAa,CAAC,GAAGJ,KAAK,CAACK,GAAG,CAACC,MAAM;EACtE;EACA,IAAIV,GAAG,KAAK,IAAI,EAAE;IAChB,OAAO;MACLW,UAAU,EAAEX,GAAG;MACfY,MAAM,EAAE,OAAO;MACfC,SAAS,EAAE,KAAK;MAChBC,YAAY,EAAE;IAChB,CAAC;EACH;EACA,IAAI,CAACC,GAAG,EAAEC,QAAQ,CAAC,GAAGjB,KAAK,CAACC,GAAG,CAAC;EAChC,IAAIiB,KAAK,GAAG;IACVN,UAAU,EAAEI,GAAG;IACfF,SAAS,EAAEf,OAAO,CAACiB,GAAG,EAAEV,MAAM,CAAC;IAC/BS,YAAY,EAAEhB,OAAO,CAACiB,GAAG,EAAET,SAAS,CAAC;IACrCM,MAAM,EAAEd,OAAO,CAACiB,GAAG,EAAER,QAAQ,CAAC;IAC9BW,WAAW,EAAE,OAAO,GAAGH;EACzB,CAAC;EACD;EACA;EACA,IAAII,OAAO,GAAGrB,OAAO,CAACiB,GAAG,EAAEP,YAAY,CAAC;EACxC,IAAIW,OAAO,KAAKnB,GAAG,IAAImB,OAAO,KAAKF,KAAK,CAACJ,SAAS,EAAE;IAClD;IACA,IAAIO,GAAG,GAAGhB,KAAK,CAACiB,GAAG,CAACC,OAAO,IAAI,CAAC,CAAC;IACjC,IAAIF,GAAG,CAACD,OAAO,CAAC,KAAK,YAAY,IAAIC,GAAG,CAACD,OAAO,CAAC,KAAK,WAAW,EAAE;MACjE;MACA,IAAInB,GAAG,KAAK,MAAM,EAAE;QAClBmB,OAAO,GAAG,QAAQ;MACpB;MACAF,KAAK,CAACM,UAAU,GAAGJ,OAAO;IAC5B;EACF;EACA;EACA,IAAIH,QAAQ,EAAE;IACZQ,MAAM,CAACC,IAAI,CAACR,KAAK,CAAC,CAACS,OAAO,CAACC,CAAC,IAAI;MAC9BV,KAAK,CAACU,CAAC,CAAC,IAAI,GAAG,GAAGX,QAAQ;IAC5B,CAAC,CAAC;EACJ;EACA,OAAOC,KAAK;AACd,CAAC;AAGD,eAAed,SAAS;;AAExB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}