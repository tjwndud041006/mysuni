{"ast":null,"code":"import fuzzy from './_fuzzy.js';\nimport methods from '../../termMethods.js'; //this should load off of 'methods.one.termMethods'\n\n//declare it up here\nlet wrapMatch = function () {};\n/** ignore optional/greedy logic, straight-up term match*/\nconst doesMatch = function (term, reg, index, length) {\n  // support '.'\n  if (reg.anything === true) {\n    return true;\n  }\n  // support '^' (in parentheses)\n  if (reg.start === true && index !== 0) {\n    return false;\n  }\n  // support '$' (in parentheses)\n  if (reg.end === true && index !== length - 1) {\n    return false;\n  }\n  // match an id\n  if (reg.id !== undefined && reg.id === term.id) {\n    return true;\n  }\n  //support a text match\n  if (reg.word !== undefined) {\n    // check case-sensitivity, etc\n    if (reg.use) {\n      return reg.word === term[reg.use];\n    }\n    //match contractions, machine-form\n    if (term.machine !== null && term.machine === reg.word) {\n      return true;\n    }\n    // term aliases for slashes and things\n    if (term.alias !== undefined && term.alias.hasOwnProperty(reg.word)) {\n      return true;\n    }\n    // support ~ fuzzy match\n    if (reg.fuzzy === true) {\n      if (reg.word === term.root) {\n        return true;\n      }\n      let score = fuzzy(reg.word, term.normal);\n      if (score >= reg.min) {\n        return true;\n      }\n    }\n    // match slashes and things\n    if (term.alias && term.alias.some(str => str === reg.word)) {\n      return true;\n    }\n    //match either .normal or .text\n    return reg.word === term.text || reg.word === term.normal;\n  }\n  //support #Tag\n  if (reg.tag !== undefined) {\n    return term.tags.has(reg.tag) === true;\n  }\n  //support @method\n  if (reg.method !== undefined) {\n    if (typeof methods[reg.method] === 'function' && methods[reg.method](term) === true) {\n      return true;\n    }\n    return false;\n  }\n  //support whitespace/punctuation\n  if (reg.pre !== undefined) {\n    return term.pre && term.pre.includes(reg.pre);\n  }\n  if (reg.post !== undefined) {\n    return term.post && term.post.includes(reg.post);\n  }\n  //support /reg/\n  if (reg.regex !== undefined) {\n    let str = term.normal;\n    if (reg.use) {\n      str = term[reg.use];\n    }\n    return reg.regex.test(str);\n  }\n  //support <chunk>\n  if (reg.chunk !== undefined) {\n    return term.chunk === reg.chunk;\n  }\n  //support %Noun|Verb%\n  if (reg.switch !== undefined) {\n    return term.switch === reg.switch;\n  }\n  //support {machine}\n  if (reg.machine !== undefined) {\n    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;\n  }\n  //support {word/sense}\n  if (reg.sense !== undefined) {\n    return term.sense === reg.sense;\n  }\n  // support optimized (one|two)\n  if (reg.fastOr !== undefined) {\n    // {work/verb} must be a verb\n    if (reg.pos && !term.tags.has(reg.pos)) {\n      return null;\n    }\n    let str = term.root || term.implicit || term.machine || term.normal;\n    return reg.fastOr.has(str) || reg.fastOr.has(term.text);\n  }\n  //support slower (one|two)\n  if (reg.choices !== undefined) {\n    // try to support && operator\n    if (reg.operator === 'and') {\n      // must match them all\n      return reg.choices.every(r => wrapMatch(term, r, index, length));\n    }\n    // or must match one\n    return reg.choices.some(r => wrapMatch(term, r, index, length));\n  }\n  return false;\n};\n// wrap result for !negative match logic\nwrapMatch = function (t, reg, index, length) {\n  let result = doesMatch(t, reg, index, length);\n  if (reg.negative === true) {\n    return !result;\n  }\n  return result;\n};\nexport default wrapMatch;","map":{"version":3,"names":["fuzzy","methods","wrapMatch","doesMatch","term","reg","index","length","anything","start","end","id","undefined","word","use","machine","alias","hasOwnProperty","root","score","normal","min","some","str","text","tag","tags","has","method","pre","includes","post","regex","test","chunk","switch","sense","fastOr","pos","implicit","choices","operator","every","r","t","result","negative"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/term/doesMatch.js"],"sourcesContent":["import fuzzy from './_fuzzy.js'\nimport methods from '../../termMethods.js' //this should load off of 'methods.one.termMethods'\n\n//declare it up here\nlet wrapMatch = function () { }\n/** ignore optional/greedy logic, straight-up term match*/\nconst doesMatch = function (term, reg, index, length) {\n  // support '.'\n  if (reg.anything === true) {\n    return true\n  }\n  // support '^' (in parentheses)\n  if (reg.start === true && index !== 0) {\n    return false\n  }\n  // support '$' (in parentheses)\n  if (reg.end === true && index !== length - 1) {\n    return false\n  }\n  // match an id\n  if (reg.id !== undefined && reg.id === term.id) {\n    return true\n  }\n  //support a text match\n  if (reg.word !== undefined) {\n    // check case-sensitivity, etc\n    if (reg.use) {\n      return reg.word === term[reg.use]\n    }\n    //match contractions, machine-form\n    if (term.machine !== null && term.machine === reg.word) {\n      return true\n    }\n    // term aliases for slashes and things\n    if (term.alias !== undefined && term.alias.hasOwnProperty(reg.word)) {\n      return true\n    }\n    // support ~ fuzzy match\n    if (reg.fuzzy === true) {\n      if (reg.word === term.root) {\n        return true\n      }\n      let score = fuzzy(reg.word, term.normal)\n      if (score >= reg.min) {\n        return true\n      }\n    }\n    // match slashes and things\n    if (term.alias && term.alias.some(str => str === reg.word)) {\n      return true\n    }\n    //match either .normal or .text\n    return reg.word === term.text || reg.word === term.normal\n  }\n  //support #Tag\n  if (reg.tag !== undefined) {\n    return term.tags.has(reg.tag) === true\n  }\n  //support @method\n  if (reg.method !== undefined) {\n    if (typeof methods[reg.method] === 'function' && methods[reg.method](term) === true) {\n      return true\n    }\n    return false\n  }\n  //support whitespace/punctuation\n  if (reg.pre !== undefined) {\n    return term.pre && term.pre.includes(reg.pre)\n  }\n  if (reg.post !== undefined) {\n    return term.post && term.post.includes(reg.post)\n  }\n  //support /reg/\n  if (reg.regex !== undefined) {\n    let str = term.normal\n    if (reg.use) {\n      str = term[reg.use]\n    }\n    return reg.regex.test(str)\n  }\n  //support <chunk>\n  if (reg.chunk !== undefined) {\n    return term.chunk === reg.chunk\n  }\n  //support %Noun|Verb%\n  if (reg.switch !== undefined) {\n    return term.switch === reg.switch\n  }\n  //support {machine}\n  if (reg.machine !== undefined) {\n    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine\n  }\n  //support {word/sense}\n  if (reg.sense !== undefined) {\n    return term.sense === reg.sense\n  }\n  // support optimized (one|two)\n  if (reg.fastOr !== undefined) {\n    // {work/verb} must be a verb\n    if (reg.pos && !term.tags.has(reg.pos)) {\n      return null\n    }\n    let str = term.root || term.implicit || term.machine || term.normal\n    return reg.fastOr.has(str) || reg.fastOr.has(term.text)\n  }\n  //support slower (one|two)\n  if (reg.choices !== undefined) {\n    // try to support && operator\n    if (reg.operator === 'and') {\n      // must match them all\n      return reg.choices.every(r => wrapMatch(term, r, index, length))\n    }\n    // or must match one\n    return reg.choices.some(r => wrapMatch(term, r, index, length))\n  }\n  return false\n}\n// wrap result for !negative match logic\nwrapMatch = function (t, reg, index, length) {\n  let result = doesMatch(t, reg, index, length)\n  if (reg.negative === true) {\n    return !result\n  }\n  return result\n}\nexport default wrapMatch\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}