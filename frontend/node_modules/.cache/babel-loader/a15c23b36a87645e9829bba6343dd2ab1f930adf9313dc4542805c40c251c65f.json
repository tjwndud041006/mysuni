{"ast":null,"code":"import { doDoes, getTense } from '../lib.js';\nconst keep = {\n  tags: true\n};\n\n// all verb forms are the same\nconst toInf = function (vb, parsed) {\n  const {\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const {\n    root,\n    auxiliary\n  } = parsed;\n  let aux = auxiliary.terms().harden();\n  let str = root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  if (str) {\n    vb.replace(root, str, keep).tag('Verb').firstTerm().tag('Infinitive');\n  }\n  // remove any auxiliary terms\n  if (aux.found) {\n    vb.remove(aux);\n  }\n  // there is no real way to do this\n  // 'i not walk'?  'i walk not'?\n  if (parsed.negative.found) {\n    if (!vb.has('not')) {\n      vb.prepend('not');\n    }\n    let does = doDoes(vb, parsed);\n    vb.prepend(does);\n  }\n  vb.fullSentence().compute(['freeze', 'lexicon', 'preTagger', 'postTagger', 'unfreeze', 'chunks']);\n  return vb;\n};\nexport default toInf;","map":{"version":3,"names":["doDoes","getTense","keep","tags","toInf","vb","parsed","toInfinitive","methods","two","transform","verb","root","auxiliary","aux","terms","harden","str","text","model","replace","tag","firstTerm","found","remove","negative","has","prepend","does","fullSentence","compute"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toInfinitive.js"],"sourcesContent":["import { doDoes, getTense } from '../lib.js'\nconst keep = { tags: true }\n\n// all verb forms are the same\nconst toInf = function (vb, parsed) {\n  const { toInfinitive } = vb.methods.two.transform.verb\n  const { root, auxiliary } = parsed\n  let aux = auxiliary.terms().harden()\n  let str = root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  if (str) {\n    vb.replace(root, str, keep).tag('Verb').firstTerm().tag('Infinitive')\n  }\n  // remove any auxiliary terms\n  if (aux.found) {\n    vb.remove(aux)\n  }\n  // there is no real way to do this\n  // 'i not walk'?  'i walk not'?\n  if (parsed.negative.found) {\n    if (!vb.has('not')) {\n      vb.prepend('not')\n    }\n    let does = doDoes(vb, parsed)\n    vb.prepend(does)\n  }\n  vb.fullSentence().compute(['freeze', 'lexicon', 'preTagger', 'postTagger', 'unfreeze', 'chunks'])\n  return vb\n}\nexport default toInf\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,QAAQ,WAAW;AAC5C,MAAMC,IAAI,GAAG;EAAEC,IAAI,EAAE;AAAK,CAAC;;AAE3B;AACA,MAAMC,KAAK,GAAG,SAAAA,CAAUC,EAAE,EAAEC,MAAM,EAAE;EAClC,MAAM;IAAEC;EAAa,CAAC,GAAGF,EAAE,CAACG,OAAO,CAACC,GAAG,CAACC,SAAS,CAACC,IAAI;EACtD,MAAM;IAAEC,IAAI;IAAEC;EAAU,CAAC,GAAGP,MAAM;EAClC,IAAIQ,GAAG,GAAGD,SAAS,CAACE,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;EACpC,IAAIC,GAAG,GAAGL,IAAI,CAACM,IAAI,CAAC,QAAQ,CAAC;EAC7BD,GAAG,GAAGV,YAAY,CAACU,GAAG,EAAEZ,EAAE,CAACc,KAAK,EAAElB,QAAQ,CAACW,IAAI,CAAC,CAAC;EACjD,IAAIK,GAAG,EAAE;IACPZ,EAAE,CAACe,OAAO,CAACR,IAAI,EAAEK,GAAG,EAAEf,IAAI,CAAC,CAACmB,GAAG,CAAC,MAAM,CAAC,CAACC,SAAS,CAAC,CAAC,CAACD,GAAG,CAAC,YAAY,CAAC;EACvE;EACA;EACA,IAAIP,GAAG,CAACS,KAAK,EAAE;IACblB,EAAE,CAACmB,MAAM,CAACV,GAAG,CAAC;EAChB;EACA;EACA;EACA,IAAIR,MAAM,CAACmB,QAAQ,CAACF,KAAK,EAAE;IACzB,IAAI,CAAClB,EAAE,CAACqB,GAAG,CAAC,KAAK,CAAC,EAAE;MAClBrB,EAAE,CAACsB,OAAO,CAAC,KAAK,CAAC;IACnB;IACA,IAAIC,IAAI,GAAG5B,MAAM,CAACK,EAAE,EAAEC,MAAM,CAAC;IAC7BD,EAAE,CAACsB,OAAO,CAACC,IAAI,CAAC;EAClB;EACAvB,EAAE,CAACwB,YAAY,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,QAAQ,EAAE,SAAS,EAAE,WAAW,EAAE,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;EACjG,OAAOzB,EAAE;AACX,CAAC;AACD,eAAeD,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}