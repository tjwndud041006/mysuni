{"ast":null,"code":"import failFast from './01-failFast.js';\nimport fromHere from './02-from-here.js';\nimport getGroup from './03-getGroup.js';\nimport notIf from './03-notIf.js';\n\n// make proper pointers\nconst addSentence = function (res, n) {\n  res.pointer[0] = n;\n  Object.keys(res.groups).forEach(k => {\n    res.groups[k][0] = n;\n  });\n  return res;\n};\nconst handleStart = function (terms, regs, n) {\n  let res = fromHere(terms, regs, 0, terms.length);\n  if (res) {\n    res = addSentence(res, n);\n    return res; //getGroup([res], group)\n  }\n  return null;\n};\n\n// ok, here we go.\nconst runMatch = function (docs, todo, cache) {\n  cache = cache || [];\n  let {\n    regs,\n    group,\n    justOne\n  } = todo;\n  let results = [];\n  if (!regs || regs.length === 0) {\n    return {\n      ptrs: [],\n      byGroup: {}\n    };\n  }\n  const minLength = regs.filter(r => r.optional !== true && r.negative !== true).length;\n  docs: for (let n = 0; n < docs.length; n += 1) {\n    let terms = docs[n];\n    // let index = terms[0].index || []\n    // can we skip this sentence?\n    if (cache[n] && failFast(regs, cache[n])) {\n      continue;\n    }\n    // ^start regs only run once, per phrase\n    if (regs[0].start === true) {\n      let foundStart = handleStart(terms, regs, n, group);\n      if (foundStart) {\n        results.push(foundStart);\n      }\n      continue;\n    }\n    //ok, try starting the match now from every term\n    for (let i = 0; i < terms.length; i += 1) {\n      let slice = terms.slice(i);\n      // ensure it's long-enough\n      if (slice.length < minLength) {\n        break;\n      }\n      let res = fromHere(slice, regs, i, terms.length);\n      // did we find a result?\n      if (res) {\n        // res = addSentence(res, index[0])\n        res = addSentence(res, n);\n        results.push(res);\n        // should we stop here?\n        if (justOne === true) {\n          break docs;\n        }\n        // skip ahead, over these results\n        let end = res.pointer[2];\n        if (Math.abs(end - 1) > i) {\n          i = Math.abs(end - 1);\n        }\n      }\n    }\n  }\n  // ensure any end-results ($) match until the last term\n  if (regs[regs.length - 1].end === true) {\n    results = results.filter(res => {\n      let n = res.pointer[0];\n      return docs[n].length === res.pointer[2];\n    });\n  }\n  if (todo.notIf) {\n    results = notIf(results, todo.notIf, docs);\n  }\n  // grab the requested group\n  results = getGroup(results, group);\n  // add ids to pointers\n  results.ptrs.forEach(ptr => {\n    let [n, start, end] = ptr;\n    ptr[3] = docs[n][start].id; //start-id\n    ptr[4] = docs[n][end - 1].id; //end-id\n  });\n  return results;\n};\nexport default runMatch;","map":{"version":3,"names":["failFast","fromHere","getGroup","notIf","addSentence","res","n","pointer","Object","keys","groups","forEach","k","handleStart","terms","regs","length","runMatch","docs","todo","cache","group","justOne","results","ptrs","byGroup","minLength","filter","r","optional","negative","start","foundStart","push","i","slice","end","Math","abs","ptr","id"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/index.js"],"sourcesContent":["import failFast from './01-failFast.js'\nimport fromHere from './02-from-here.js'\nimport getGroup from './03-getGroup.js'\nimport notIf from './03-notIf.js'\n\n\n// make proper pointers\nconst addSentence = function (res, n) {\n  res.pointer[0] = n\n  Object.keys(res.groups).forEach(k => {\n    res.groups[k][0] = n\n  })\n  return res\n}\n\nconst handleStart = function (terms, regs, n) {\n  let res = fromHere(terms, regs, 0, terms.length)\n  if (res) {\n    res = addSentence(res, n)\n    return res //getGroup([res], group)\n  }\n  return null\n}\n\n// ok, here we go.\nconst runMatch = function (docs, todo, cache) {\n  cache = cache || []\n  let { regs, group, justOne } = todo\n  let results = []\n  if (!regs || regs.length === 0) {\n    return { ptrs: [], byGroup: {} }\n  }\n\n  const minLength = regs.filter(r => r.optional !== true && r.negative !== true).length\n  docs: for (let n = 0; n < docs.length; n += 1) {\n    let terms = docs[n]\n    // let index = terms[0].index || []\n    // can we skip this sentence?\n    if (cache[n] && failFast(regs, cache[n])) {\n      continue\n    }\n    // ^start regs only run once, per phrase\n    if (regs[0].start === true) {\n      let foundStart = handleStart(terms, regs, n, group)\n      if (foundStart) {\n        results.push(foundStart)\n      }\n      continue\n    }\n    //ok, try starting the match now from every term\n    for (let i = 0; i < terms.length; i += 1) {\n      let slice = terms.slice(i)\n      // ensure it's long-enough\n      if (slice.length < minLength) {\n        break\n      }\n      let res = fromHere(slice, regs, i, terms.length)\n      // did we find a result?\n      if (res) {\n        // res = addSentence(res, index[0])\n        res = addSentence(res, n)\n        results.push(res)\n        // should we stop here?\n        if (justOne === true) {\n          break docs\n        }\n        // skip ahead, over these results\n        let end = res.pointer[2]\n        if (Math.abs(end - 1) > i) {\n          i = Math.abs(end - 1)\n        }\n      }\n    }\n  }\n  // ensure any end-results ($) match until the last term\n  if (regs[regs.length - 1].end === true) {\n    results = results.filter(res => {\n      let n = res.pointer[0]\n      return docs[n].length === res.pointer[2]\n    })\n  }\n  if (todo.notIf) {\n    results = notIf(results, todo.notIf, docs)\n  }\n  // grab the requested group\n  results = getGroup(results, group)\n  // add ids to pointers\n  results.ptrs.forEach(ptr => {\n    let [n, start, end] = ptr\n    ptr[3] = docs[n][start].id//start-id\n    ptr[4] = docs[n][end - 1].id//end-id\n  })\n  return results\n}\n\nexport default runMatch\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}