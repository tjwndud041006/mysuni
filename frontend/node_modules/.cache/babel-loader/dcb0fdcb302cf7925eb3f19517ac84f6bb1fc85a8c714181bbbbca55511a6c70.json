{"ast":null,"code":"import { getGroup } from '../_lib.js';\nimport foundOptional from './optional-match.js';\nimport greedyMatch from './greedy-match.js';\nimport contractionSkip from './contraction-skip.js';\n\n// '[foo]' should also be logged as a group\nconst setGroup = function (state, startAt) {\n  let reg = state.regs[state.r];\n  // Get or create capture group\n  const g = getGroup(state, startAt);\n  // Update group - add greedy or increment length\n  if (state.t > 1 && reg.greedy) {\n    g.length += state.t - startAt;\n  } else {\n    g.length++;\n  }\n};\n\n// when a reg matches a term\nconst simpleMatch = function (state) {\n  const {\n    regs\n  } = state;\n  let reg = regs[state.r];\n  let term = state.terms[state.t];\n  let startAt = state.t;\n  // if it's a negative optional match... :0\n  if (reg.optional && regs[state.r + 1] && reg.negative) {\n    return true;\n  }\n  // okay, it was a match, but if it's optional too,\n  // we should check the next reg too, to skip it?\n  if (reg.optional && regs[state.r + 1]) {\n    foundOptional(state);\n  }\n  // Contraction skip:\n  // did we match the first part of a contraction?\n  if (term.implicit && state.terms[state.t + 1]) {\n    contractionSkip(state);\n  }\n  //advance to the next term!\n  state.t += 1;\n  //check any ending '$' flags\n  //if this isn't the last term, refuse the match\n  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {\n    return null; //die\n  }\n  // keep 'foo+' going...\n  if (reg.greedy === true) {\n    let alive = greedyMatch(state);\n    if (!alive) {\n      return null;\n    }\n  }\n  // log '[foo]' as a group\n  if (state.hasGroup === true) {\n    setGroup(state, startAt);\n  }\n  return true;\n};\nexport default simpleMatch;","map":{"version":3,"names":["getGroup","foundOptional","greedyMatch","contractionSkip","setGroup","state","startAt","reg","regs","r","g","t","greedy","length","simpleMatch","term","terms","optional","negative","implicit","end","alive","hasGroup"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/steps/simple-match.js"],"sourcesContent":["import { getGroup } from '../_lib.js'\nimport foundOptional from './optional-match.js'\nimport greedyMatch from './greedy-match.js'\nimport contractionSkip from './contraction-skip.js'\n\n\n// '[foo]' should also be logged as a group\nconst setGroup = function (state, startAt) {\n  let reg = state.regs[state.r]\n  // Get or create capture group\n  const g = getGroup(state, startAt)\n  // Update group - add greedy or increment length\n  if (state.t > 1 && reg.greedy) {\n    g.length += state.t - startAt\n  } else {\n    g.length++\n  }\n}\n\n// when a reg matches a term\nconst simpleMatch = function (state) {\n  const { regs } = state\n  let reg = regs[state.r]\n  let term = state.terms[state.t]\n  let startAt = state.t\n  // if it's a negative optional match... :0\n  if (reg.optional && regs[state.r + 1] && reg.negative) {\n    return true\n  }\n  // okay, it was a match, but if it's optional too,\n  // we should check the next reg too, to skip it?\n  if (reg.optional && regs[state.r + 1]) {\n    foundOptional(state)\n  }\n  // Contraction skip:\n  // did we match the first part of a contraction?\n  if (term.implicit && state.terms[state.t + 1]) {\n    contractionSkip(state)\n  }\n  //advance to the next term!\n  state.t += 1\n  //check any ending '$' flags\n  //if this isn't the last term, refuse the match\n  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {\n    return null //die\n  }\n  // keep 'foo+' going...\n  if (reg.greedy === true) {\n    let alive = greedyMatch(state)\n    if (!alive) {\n      return null\n    }\n  }\n  // log '[foo]' as a group\n  if (state.hasGroup === true) {\n    setGroup(state, startAt)\n  }\n  return true\n}\nexport default simpleMatch"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,YAAY;AACrC,OAAOC,aAAa,MAAM,qBAAqB;AAC/C,OAAOC,WAAW,MAAM,mBAAmB;AAC3C,OAAOC,eAAe,MAAM,uBAAuB;;AAGnD;AACA,MAAMC,QAAQ,GAAG,SAAAA,CAAUC,KAAK,EAAEC,OAAO,EAAE;EACzC,IAAIC,GAAG,GAAGF,KAAK,CAACG,IAAI,CAACH,KAAK,CAACI,CAAC,CAAC;EAC7B;EACA,MAAMC,CAAC,GAAGV,QAAQ,CAACK,KAAK,EAAEC,OAAO,CAAC;EAClC;EACA,IAAID,KAAK,CAACM,CAAC,GAAG,CAAC,IAAIJ,GAAG,CAACK,MAAM,EAAE;IAC7BF,CAAC,CAACG,MAAM,IAAIR,KAAK,CAACM,CAAC,GAAGL,OAAO;EAC/B,CAAC,MAAM;IACLI,CAAC,CAACG,MAAM,EAAE;EACZ;AACF,CAAC;;AAED;AACA,MAAMC,WAAW,GAAG,SAAAA,CAAUT,KAAK,EAAE;EACnC,MAAM;IAAEG;EAAK,CAAC,GAAGH,KAAK;EACtB,IAAIE,GAAG,GAAGC,IAAI,CAACH,KAAK,CAACI,CAAC,CAAC;EACvB,IAAIM,IAAI,GAAGV,KAAK,CAACW,KAAK,CAACX,KAAK,CAACM,CAAC,CAAC;EAC/B,IAAIL,OAAO,GAAGD,KAAK,CAACM,CAAC;EACrB;EACA,IAAIJ,GAAG,CAACU,QAAQ,IAAIT,IAAI,CAACH,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,IAAIF,GAAG,CAACW,QAAQ,EAAE;IACrD,OAAO,IAAI;EACb;EACA;EACA;EACA,IAAIX,GAAG,CAACU,QAAQ,IAAIT,IAAI,CAACH,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,EAAE;IACrCR,aAAa,CAACI,KAAK,CAAC;EACtB;EACA;EACA;EACA,IAAIU,IAAI,CAACI,QAAQ,IAAId,KAAK,CAACW,KAAK,CAACX,KAAK,CAACM,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7CR,eAAe,CAACE,KAAK,CAAC;EACxB;EACA;EACAA,KAAK,CAACM,CAAC,IAAI,CAAC;EACZ;EACA;EACA,IAAIJ,GAAG,CAACa,GAAG,KAAK,IAAI,IAAIf,KAAK,CAACM,CAAC,KAAKN,KAAK,CAACW,KAAK,CAACH,MAAM,IAAIN,GAAG,CAACK,MAAM,KAAK,IAAI,EAAE;IAC7E,OAAO,IAAI,EAAC;EACd;EACA;EACA,IAAIL,GAAG,CAACK,MAAM,KAAK,IAAI,EAAE;IACvB,IAAIS,KAAK,GAAGnB,WAAW,CAACG,KAAK,CAAC;IAC9B,IAAI,CAACgB,KAAK,EAAE;MACV,OAAO,IAAI;IACb;EACF;EACA;EACA,IAAIhB,KAAK,CAACiB,QAAQ,KAAK,IAAI,EAAE;IAC3BlB,QAAQ,CAACC,KAAK,EAAEC,OAAO,CAAC;EAC1B;EACA,OAAO,IAAI;AACb,CAAC;AACD,eAAeQ,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}