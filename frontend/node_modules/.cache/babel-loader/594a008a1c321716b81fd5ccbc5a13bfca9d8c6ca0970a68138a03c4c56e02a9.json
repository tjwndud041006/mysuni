{"ast":null,"code":"// # MemJS Memcache Client\n\nvar errors = require('./protocol').errors;\nvar Server = require('./server').Server;\nvar noopSerializer = require('./noop-serializer').noopSerializer;\nvar makeRequestBuffer = require('./utils').makeRequestBuffer;\nvar hashCode = require('./utils').hashCode;\nvar merge = require('./utils').merge;\nvar makeExpiration = require('./utils').makeExpiration;\nvar makeAmountInitialAndExpiration = require('./utils').makeAmountInitialAndExpiration;\n\n// Client initializer takes a list of `Server`s and an `options` dictionary.\n// See `Client.create` for details.\nvar Client = function (servers, options) {\n  this.servers = servers;\n  this.seq = 0;\n  this.options = merge(options || {}, {\n    failoverTime: 60,\n    retries: 2,\n    retry_delay: 0.2,\n    expires: 0,\n    logger: console\n  });\n  this.serializer = this.options.serializer || noopSerializer;\n};\n\n// Creates a new client given an optional config string and optional hash of\n// options. The config string should be of the form:\n//\n//     \"[user:pass@]server1[:11211],[user:pass@]server2[:11211],...\"\n//\n// If the argument is not given, fallback on the `MEMCACHIER_SERVERS` environment\n// variable, `MEMCACHE_SERVERS` environment variable or `\"localhost:11211\"`.\n//\n// The options hash may contain the options:\n//\n// * `retries` - the number of times to retry an operation in lieu of failures\n// (default 2)\n// * `expires` - the default expiration in seconds to use (default 0 - never\n// expire). If `expires` is greater than 30 days (60 x 60 x 24 x 30), it is\n// treated as a UNIX time (number of seconds since January 1, 1970).\n// * `logger` - a logger object that responds to `log(string)` method calls.\n// * `failover` - whether to failover to next server. Defaults to false.\n// * `failoverTime` - how much to wait until retring a failed server. Default\n//                    is 60 seconds.\n//\n//   ~~~~\n//     log(msg1[, msg2[, msg3[...]]])\n//   ~~~~\n//\n//   Defaults to `console`.\n// * `serializer` - the object which will (de)serialize the data. It needs\n//   two public methods: serialize and deserialize. It defaults to the \n//   noopSerializer:\n//\n//   ~~~~\n//   var noopSerializer = {\n//     serialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     },\n//     deserialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     }\n//   };\n//   ~~~~\n//\n// Or options for the servers including:\n// * `username` and `password` for fallback SASL authentication credentials.\n// * `timeout` in seconds to determine failure for operations. Default is 0.5\n//             seconds.\n// * 'conntimeout' in seconds to connection failure. Default is twice the value\n//                 of `timeout`.\n// * `keepAlive` whether to enable keep-alive functionality. Defaults to false.\n// * `keepAliveDelay` in seconds to the initial delay before the first keepalive\n//                    probe is sent on an idle socket. Defaults is 30 seconds.\nClient.create = function (serversStr, options) {\n  serversStr = serversStr || process.env.MEMCACHIER_SERVERS || process.env.MEMCACHE_SERVERS || 'localhost:11211';\n  var serverUris = serversStr.split(',');\n  var servers = serverUris.map(function (uri) {\n    var uriParts = uri.split('@');\n    var hostPort = uriParts[uriParts.length - 1].split(':');\n    var userPass = (uriParts[uriParts.length - 2] || '').split(':');\n    return new Server(hostPort[0], parseInt(hostPort[1] || 11211, 10), userPass[0], userPass[1], options);\n  });\n  return new Client(servers, options);\n};\n\n// An overridable method you can use for determing\n// server selection. Should return the server index\n// in the list of servers on Client#servers.\n// \n//   Example using node-hashring:\n//   ~~~~\n//   const memjs = require('memjs');\n//   const HashRing = require('node-hashring');\n//   const servers = ['localhost:11211', 'localhost:11212'];\n//   // build a map of server addresses to their index in the server list\n//   const serverMap = {};\n//   servers.forEach((server, index) => serverMap[server] = index);\n//   const client = memjs.Client.create(servers.join(','));\n//   // build the hashring\n//   const hashRing = new HashRing(servers);\n//   // override the getServer method\n//   client.getServer = (key) => serverMap[hashRing.findNode(key)];\n//   ~~~~\nClient.prototype.getServer = function (key) {\n  return hashCode(key) % this.servers.length;\n};\n\n// Chooses the server to talk to by hashing the given key.\nClient.prototype.server = function (key) {\n  // mechanisms\n  var total = this.servers.length;\n  var origIdx = total > 1 ? this.getServer(key) : 0;\n  var idx = origIdx;\n  var serv = this.servers[idx];\n  while (serv.wakeupAt && serv.wakeupAt > Date.now()) {\n    idx = (idx + 1) % total;\n    if (idx === origIdx) {\n      return null;\n    }\n    serv = this.servers[idx];\n  }\n  return serv;\n};\n\n// converts a call into a promise-returning one\nvar promisify = function (command) {\n  return new Promise(function (resolve, reject) {\n    command(function (err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n};\n\n// ## Memcache Commands\n//\n// All commands return their results through a callback passed as the last\n// required argument (some commands, like `Client#set`, take optional arguments\n// after the callback).\n//\n// The callback signature always follows:\n//\n//     callback(err, [arg1[, arg2[, arg3[...]]]])\n//\n// In case of an error the _err_ argument will be non-null and contain the\n// `Error`. A notable exception includes a `Client#get` on a key that doesn't\n// exist. In this case, _err_ will be null, as will the _value and _extras_\n// arguments.\n\n// GET\n//\n// Retrieves the value at the given key in memcache.\n//\n// The callback signature is:\n//\n//     callback(err, value, flags)\n//\n// _value_ and _flags_ are both `Buffer`s. If the key is not found, the\n// callback is invoked with null for both arguments and no error.\nClient.prototype.get = function (key, callback) {\n  var self = this;\n  if (callback === undefined) {\n    return promisify(function (callback) {\n      self.get(key, function (err, value, flags) {\n        callback(err, {\n          value: value,\n          flags: flags\n        });\n      });\n    });\n  }\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          var deserialized = self.serializer.deserialize(response.header.opcode, response.val, response.extras);\n          callback(null, deserialized.value, deserialized.extras);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, null, null);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS GET: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// SET\n//\n// Sets the given _key_ and _value_ in memcache.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.set = function (key, value, options, callback) {\n  if (callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function (callback) {\n      self.set(key, value, options, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function' || typeof callback === 'number') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS SET: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n  var opcode = 1;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS SET: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// ADD\n//\n// Adds the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is not already set.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.add = function (key, value, options, callback) {\n  if (callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function (callback) {\n      self.add(key, value, options, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS ADD: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n  var opcode = 2;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 2:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS ADD: ' + errors[response.header.status];\n        logger.log(errorMessage, false);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// REPLACE\n//\n// Replaces the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is already present.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.replace = function (key, value, options, callback) {\n  if (callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function (callback) {\n      self.replace(key, value, options, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS REPLACE: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n  var opcode = 3;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS REPLACE: ' + errors[response.header.status];\n        logger.log(errorMessage, false);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// DELETE\n//\n// Deletes the given _key_ from memcache. The operation only succeeds\n// if the key is already present.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.delete = function (key, callback) {\n  if (callback === undefined) {\n    var self = this;\n    return promisify(function (callback) {\n      self.delete(key, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  // TODO: Support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(4, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS DELETE: ' + errors[response.header.status];\n        logger.log(errorMessage, false);\n        if (callback) {\n          callback(new Error(errorMessage), null);\n        }\n    }\n  });\n};\n\n// INCREMENT\n//\n// Increments the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.increment = function (key, amount, options, callback) {\n  if (callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function (callback) {\n      if (!options) options = {};\n      self.increment(key, amount, options, function (err, success, value) {\n        callback(err, {\n          success: success,\n          value: value\n        });\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS INCREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n\n  // TODO: support version (CAS)\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(5, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n        if (callback) {\n          callback(null, true, bufInt);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS INCREMENT: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// DECREMENT\n//\n// Decrements the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.decrement = function (key, amount, options, callback) {\n  if (callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function (callback) {\n      self.decrement(key, amount, options, function (err, success, value) {\n        callback(err, {\n          success: success,\n          value: value\n        });\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS DECREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  // TODO: support version (CAS)\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(6, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n        if (callback) {\n          callback(null, true, bufInt);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS DECREMENT: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null, null);\n        }\n    }\n  });\n};\n\n// APPEND\n//\n// Append the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.append = function (key, value, callback) {\n  if (callback === undefined) {\n    var self = this;\n    return promisify(function (callback) {\n      self.append(key, value, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS APPEND: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null);\n        }\n    }\n  });\n};\n\n// PREPEND\n//\n// Prepend the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.prepend = function (key, value, callback) {\n  if (callback === undefined) {\n    var self = this;\n    return promisify(function (callback) {\n      self.prepend(key, value, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS PREPEND: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null);\n        }\n    }\n  });\n};\n\n// TOUCH\n//\n// Touch sets an expiration value, given by _expires_, on the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.touch = function (key, expires, callback) {\n  if (callback === undefined) {\n    var self = this;\n    return promisify(function (callback) {\n      self.touch(key, expires, function (err, success) {\n        callback(err, success);\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var extras = makeExpiration(expires || this.options.expires);\n  var request = makeRequestBuffer(0x1C, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function (err, response) {\n    if (err) {\n      if (callback) {\n        callback(err, null);\n      }\n      return;\n    }\n    switch (response.header.status) {\n      case 0:\n        if (callback) {\n          callback(null, true);\n        }\n        break;\n      case 1:\n        if (callback) {\n          callback(null, false);\n        }\n        break;\n      default:\n        var errorMessage = 'MemJS TOUCH: ' + errors[response.header.status];\n        logger.log(errorMessage);\n        if (callback) {\n          callback(new Error(errorMessage), null);\n        }\n    }\n  });\n};\n\n// FLUSH\n//\n// Flushes the cache on each connected server. The callback signature is:\n//\n//     callback(lastErr, results)\n//\n// where _lastErr_ is the last error encountered (or null, in the common case\n// of no errors). _results_ is a dictionary mapping `\"hostname:port\"` to either\n// `true` (if the operation was successful), or an error.\nClient.prototype.flush = function (callback) {\n  if (callback === undefined) {\n    var self = this;\n    return promisify(function (callback) {\n      self.flush(function (err, results) {\n        callback(err, results);\n      });\n    });\n  }\n  // TODO: support expiration\n  this.incrSeq();\n  var request = makeRequestBuffer(0x08, '', '', '', this.seq);\n  var count = this.servers.length;\n  var result = {};\n  var lastErr = null;\n  var i;\n  var handleFlush = function (seq, serv) {\n    serv.onResponse(seq, function /* response */\n    () {\n      count -= 1;\n      result[serv.host + ':' + serv.port] = true;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.onError(seq, function (err) {\n      count -= 1;\n      lastErr = err;\n      result[serv.host + ':' + serv.port] = err;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.write(request);\n  };\n  for (i = 0; i < this.servers.length; i++) {\n    handleFlush(this.seq, this.servers[i]);\n  }\n};\n\n// STATS_WITH_KEY\n//\n// Sends a memcache stats command with a key to each connected server. The\n// callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a dictionary\n// mapping the stat name to the value of the statistic as a string.\nClient.prototype.statsWithKey = function (key, callback) {\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0x10, key, '', '', this.seq);\n  var i;\n  var handleStats = function (seq, serv) {\n    var result = {};\n    var handle = function (response) {\n      // end of stat responses\n      if (response.header.totalBodyLength === 0) {\n        if (callback) {\n          callback(null, serv.host + ':' + serv.port, result);\n        }\n        return;\n      }\n      // process single stat line response\n      switch (response.header.status) {\n        case 0:\n          result[response.key.toString()] = response.val.toString();\n          break;\n        default:\n          var errorMessage = 'MemJS STATS (' + key + '): ' + errors[response.header.status];\n          logger.log(errorMessage, false);\n          if (callback) {\n            callback(new Error(errorMessage), serv.host + ':' + serv.port, null);\n          }\n      }\n    };\n    handle.quiet = true;\n    serv.onResponse(seq, handle);\n    serv.onError(seq, function (err) {\n      if (callback) {\n        callback(err, serv.host + ':' + serv.port, null);\n      }\n    });\n    serv.write(request);\n  };\n  for (i = 0; i < this.servers.length; i++) {\n    handleStats(this.seq, this.servers[i]);\n  }\n};\n\n// STATS\n//\n// Fetches memcache stats from each connected server. The callback is invoked\n// **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a\n// dictionary mapping the stat name to the value of the statistic as a string.\nClient.prototype.stats = function (callback) {\n  this.statsWithKey('', callback);\n};\n\n// RESET_STATS\n//\n// Reset the statistics each server is keeping back to zero. This doesn't clear\n// stats such as item count, but temporary stats such as total number of\n// connections over time.\n//\n// The callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server)\n//\n// _server_ is the `\"hostname:port\"` of the server.\nClient.prototype.resetStats = function (callback) {\n  this.statsWithKey('reset', callback);\n};\n\n// QUIT\n//\n// Closes the connection to each server, notifying them of this intention. Note\n// that quit can race against already outstanding requests when those requests\n// fail and are retried, leading to the quit command winning and closing the\n// connection before the retries complete.\nClient.prototype.quit = function () {\n  this.incrSeq();\n  // TODO: Nicer perhaps to do QUITQ (0x17) but need a new callback for when\n  // write is done.\n  var request = makeRequestBuffer(0x07, '', '', '', this.seq); // QUIT\n  var serv;\n  var i;\n  var handleQuit = function (seq, serv) {\n    serv.onResponse(seq, function /* response */\n    () {\n      serv.close();\n    });\n    serv.onError(seq, function /* err */\n    () {\n      serv.close();\n    });\n    serv.write(request);\n  };\n  for (i = 0; i < this.servers.length; i++) {\n    serv = this.servers[i];\n    handleQuit(this.seq, serv);\n  }\n};\n\n// CLOSE\n//\n// Closes (abruptly) connections to all the servers.\nClient.prototype.close = function () {\n  var i;\n  for (i = 0; i < this.servers.length; i++) {\n    this.servers[i].close();\n  }\n};\n\n// Perform a generic single response operation (get, set etc) on a server\n// serv: the server to perform the operation on\n// request: a buffer containing the request\n// seq: the sequence number of the operation. It is used to pin the callbacks\n//      to a specific operation and should never change during a `perform`.\n// callback: a callback invoked when a response is received or the request\n//           fails\n// retries: number of times to retry request on failure\nClient.prototype.perform = function (key, request, seq, callback, retries) {\n  var _this = this;\n  var serv = this.server(key);\n  if (!serv) {\n    if (callback) {\n      callback(new Error('No servers available'), null);\n    }\n    return;\n  }\n  retries = retries || this.options.retries;\n  var failover = this.options.failover;\n  var failoverTime = this.options.failoverTime;\n  var origRetries = this.options.retries;\n  var logger = this.options.logger;\n  var retry_delay = this.options.retry_delay;\n  var responseHandler = function (response) {\n    if (callback) {\n      callback(null, response);\n    }\n  };\n  var errorHandler = function (error) {\n    if (--retries > 0) {\n      // Wait for retry_delay\n      setTimeout(function () {\n        _this.perform(key, request, seq, callback, retries);\n      }, 1000 * retry_delay);\n    } else {\n      logger.log('MemJS: Server <' + serv.host + ':' + serv.port + '> failed after (' + origRetries + ') retries with error - ' + error.message);\n      if (failover) {\n        serv.wakeupAt = Date.now() + failoverTime * 1000;\n        _this.perform(key, request, seq, callback, origRetries);\n      } else {\n        if (callback) {\n          callback(error, null);\n        }\n      }\n    }\n  };\n  serv.onResponse(seq, responseHandler);\n  serv.onError(seq, errorHandler);\n  serv.write(request);\n};\n\n// Increment the seq value\nClient.prototype.incrSeq = function () {\n  this.seq++;\n\n  // Wrap `this.seq` to 32-bits since the field we fit it into is only 32-bits.\n  this.seq &= 0xffffffff;\n};\nexports.Client = Client;\nexports.Server = Server;\nexports.Utils = require('./utils');\nexports.Header = require('./header');","map":{"version":3,"names":["errors","require","Server","noopSerializer","makeRequestBuffer","hashCode","merge","makeExpiration","makeAmountInitialAndExpiration","Client","servers","options","seq","failoverTime","retries","retry_delay","expires","logger","console","serializer","create","serversStr","process","env","MEMCACHIER_SERVERS","MEMCACHE_SERVERS","serverUris","split","map","uri","uriParts","hostPort","length","userPass","parseInt","prototype","getServer","key","server","total","origIdx","idx","serv","wakeupAt","Date","now","promisify","command","Promise","resolve","reject","err","result","get","callback","self","undefined","value","flags","incrSeq","request","perform","response","header","status","deserialized","deserialize","opcode","val","extras","errorMessage","log","Error","set","success","expiration","Buffer","concat","from","serialized","serialize","add","replace","delete","increment","amount","initial","arguments","bufInt","readUInt32BE","decrement","append","prepend","touch","flush","results","count","lastErr","i","handleFlush","onResponse","host","port","onError","write","statsWithKey","handleStats","handle","totalBodyLength","toString","quiet","stats","resetStats","quit","handleQuit","close","_this","failover","origRetries","responseHandler","errorHandler","error","setTimeout","message","exports","Utils","Header"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/memjs/lib/memjs/memjs.js"],"sourcesContent":["// # MemJS Memcache Client\n\nvar errors = require('./protocol').errors;\nvar Server = require('./server').Server;\nvar noopSerializer = require('./noop-serializer').noopSerializer;\nvar makeRequestBuffer = require('./utils').makeRequestBuffer;\nvar hashCode = require('./utils').hashCode;\nvar merge = require('./utils').merge;\nvar makeExpiration = require('./utils').makeExpiration;\nvar makeAmountInitialAndExpiration = require('./utils').makeAmountInitialAndExpiration;\n\n// Client initializer takes a list of `Server`s and an `options` dictionary.\n// See `Client.create` for details.\nvar Client = function(servers, options) {\n  this.servers = servers;\n  this.seq = 0;\n  this.options = merge(options || {},\n    {failoverTime: 60, retries: 2, retry_delay: 0.2, expires: 0, logger: console});\n\n  this.serializer = this.options.serializer || noopSerializer;\n};\n\n// Creates a new client given an optional config string and optional hash of\n// options. The config string should be of the form:\n//\n//     \"[user:pass@]server1[:11211],[user:pass@]server2[:11211],...\"\n//\n// If the argument is not given, fallback on the `MEMCACHIER_SERVERS` environment\n// variable, `MEMCACHE_SERVERS` environment variable or `\"localhost:11211\"`.\n//\n// The options hash may contain the options:\n//\n// * `retries` - the number of times to retry an operation in lieu of failures\n// (default 2)\n// * `expires` - the default expiration in seconds to use (default 0 - never\n// expire). If `expires` is greater than 30 days (60 x 60 x 24 x 30), it is\n// treated as a UNIX time (number of seconds since January 1, 1970).\n// * `logger` - a logger object that responds to `log(string)` method calls.\n// * `failover` - whether to failover to next server. Defaults to false.\n// * `failoverTime` - how much to wait until retring a failed server. Default\n//                    is 60 seconds.\n//\n//   ~~~~\n//     log(msg1[, msg2[, msg3[...]]])\n//   ~~~~\n//\n//   Defaults to `console`.\n// * `serializer` - the object which will (de)serialize the data. It needs\n//   two public methods: serialize and deserialize. It defaults to the \n//   noopSerializer:\n//\n//   ~~~~\n//   var noopSerializer = {\n//     serialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     },\n//     deserialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     }\n//   };\n//   ~~~~\n//\n// Or options for the servers including:\n// * `username` and `password` for fallback SASL authentication credentials.\n// * `timeout` in seconds to determine failure for operations. Default is 0.5\n//             seconds.\n// * 'conntimeout' in seconds to connection failure. Default is twice the value\n//                 of `timeout`.\n// * `keepAlive` whether to enable keep-alive functionality. Defaults to false.\n// * `keepAliveDelay` in seconds to the initial delay before the first keepalive\n//                    probe is sent on an idle socket. Defaults is 30 seconds.\nClient.create = function(serversStr, options) {\n  serversStr = serversStr || process.env.MEMCACHIER_SERVERS ||\n                             process.env.MEMCACHE_SERVERS || 'localhost:11211';\n  var serverUris = serversStr.split(',');\n  var servers = serverUris.map(function(uri) {\n    var uriParts = uri.split('@');\n    var hostPort = uriParts[uriParts.length - 1].split(':');\n    var userPass = (uriParts[uriParts.length - 2] || '').split(':');\n    return new Server(hostPort[0], parseInt(hostPort[1] || 11211, 10), userPass[0], userPass[1], options);\n  });\n  return new Client(servers, options);\n};\n\n// An overridable method you can use for determing\n// server selection. Should return the server index\n// in the list of servers on Client#servers.\n// \n//   Example using node-hashring:\n//   ~~~~\n//   const memjs = require('memjs');\n//   const HashRing = require('node-hashring');\n//   const servers = ['localhost:11211', 'localhost:11212'];\n//   // build a map of server addresses to their index in the server list\n//   const serverMap = {};\n//   servers.forEach((server, index) => serverMap[server] = index);\n//   const client = memjs.Client.create(servers.join(','));\n//   // build the hashring\n//   const hashRing = new HashRing(servers);\n//   // override the getServer method\n//   client.getServer = (key) => serverMap[hashRing.findNode(key)];\n//   ~~~~\nClient.prototype.getServer = function(key) {\n  return hashCode(key) % this.servers.length;\n};\n\n// Chooses the server to talk to by hashing the given key.\nClient.prototype.server = function(key) {\n  // mechanisms\n  var total = this.servers.length;\n  var origIdx = total > 1 ? this.getServer(key) : 0;\n  var idx = origIdx;\n  var serv = this.servers[idx];\n  while (serv.wakeupAt &&\n      serv.wakeupAt > Date.now()) {\n    idx = (idx + 1) % total;\n    if (idx === origIdx) {\n      return null;\n    }\n    serv = this.servers[idx];\n  }\n  return serv;\n};\n\n// converts a call into a promise-returning one\nvar promisify = function(command) {\n  return new Promise(function(resolve, reject) {\n    command(function(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n};\n\n// ## Memcache Commands\n//\n// All commands return their results through a callback passed as the last\n// required argument (some commands, like `Client#set`, take optional arguments\n// after the callback).\n//\n// The callback signature always follows:\n//\n//     callback(err, [arg1[, arg2[, arg3[...]]]])\n//\n// In case of an error the _err_ argument will be non-null and contain the\n// `Error`. A notable exception includes a `Client#get` on a key that doesn't\n// exist. In this case, _err_ will be null, as will the _value and _extras_\n// arguments.\n\n// GET\n//\n// Retrieves the value at the given key in memcache.\n//\n// The callback signature is:\n//\n//     callback(err, value, flags)\n//\n// _value_ and _flags_ are both `Buffer`s. If the key is not found, the\n// callback is invoked with null for both arguments and no error.\nClient.prototype.get = function(key, callback) {\n  var self = this;\n  if(callback === undefined) {\n    return promisify(function(callback) {\n      self.get(key, function(err, value, flags) {\n        callback(err, {value: value, flags: flags});\n      });\n    });\n  }\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case  0:\n      if (callback) {\n        var deserialized = self.serializer.deserialize(response.header.opcode, response.val, response.extras);\n        callback(null, deserialized.value, deserialized.extras);\n      }\n      break;\n    case 1:\n      if (callback) { callback(null, null, null); }\n      break;\n    default:\n      var errorMessage = 'MemJS GET: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// SET\n//\n// Sets the given _key_ and _value_ in memcache.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.set = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.set(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function' || typeof callback === 'number') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS SET: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 1;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    default:\n      var errorMessage = 'MemJS SET: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// ADD\n//\n// Adds the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is not already set.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.add = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.add(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS ADD: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 2;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 2:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS ADD: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// REPLACE\n//\n// Replaces the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is already present.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.replace = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.replace(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS REPLACE: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 3;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS REPLACE: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// DELETE\n//\n// Deletes the given _key_ from memcache. The operation only succeeds\n// if the key is already present.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.delete = function(key, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.delete(key, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: Support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(4, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case  0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS DELETE: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// INCREMENT\n//\n// Increments the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.increment = function(key, amount, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function(callback) {\n      if (!options) options = {};\n      self.increment(key, amount, options, function(err, success, value) {\n        callback(err, {success: success, value: value});\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS INCREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n\n  // TODO: support version (CAS)\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(5, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n      if (callback) { callback(null, true, bufInt); }\n      break;\n    default:\n      var errorMessage = 'MemJS INCREMENT: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// DECREMENT\n//\n// Decrements the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.decrement = function(key, amount, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function(callback) {\n      self.decrement(key, amount, options, function(err, success, value) {\n        callback(err, {success: success, value: value});\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS DECREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  // TODO: support version (CAS)\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(6, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n      if (callback) { callback(null, true, bufInt); }\n      break;\n    default:\n      var errorMessage = 'MemJS DECREMENT: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// APPEND\n//\n// Append the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.append = function(key, value, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.append(key, value, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS APPEND: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// PREPEND\n//\n// Prepend the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.prepend = function(key, value, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.prepend(key, value, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS PREPEND: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// TOUCH\n//\n// Touch sets an expiration value, given by _expires_, on the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.touch = function(key, expires, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.touch(key, expires, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var extras = makeExpiration(expires || this.options.expires);\n  var request = makeRequestBuffer(0x1C, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS TOUCH: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// FLUSH\n//\n// Flushes the cache on each connected server. The callback signature is:\n//\n//     callback(lastErr, results)\n//\n// where _lastErr_ is the last error encountered (or null, in the common case\n// of no errors). _results_ is a dictionary mapping `\"hostname:port\"` to either\n// `true` (if the operation was successful), or an error.\nClient.prototype.flush = function(callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.flush(function(err, results) { callback(err, results); }); });\n  }\n  // TODO: support expiration\n  this.incrSeq();\n  var request = makeRequestBuffer(0x08, '', '', '', this.seq);\n  var count   = this.servers.length;\n  var result  = {};\n  var lastErr = null;\n  var i;\n\n  var handleFlush = function(seq, serv) {\n    serv.onResponse(seq, function(/* response */) {\n      count -= 1;\n      result[serv.host + ':' + serv.port] = true;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.onError(seq, function(err) {\n      count -= 1;\n      lastErr = err;\n      result[serv.host + ':' + serv.port] = err;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    handleFlush(this.seq, this.servers[i]);\n  }\n};\n\n// STATS_WITH_KEY\n//\n// Sends a memcache stats command with a key to each connected server. The\n// callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a dictionary\n// mapping the stat name to the value of the statistic as a string.\nClient.prototype.statsWithKey = function(key, callback) {\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0x10, key, '', '', this.seq);\n  var i;\n\n  var handleStats = function(seq, serv) {\n    var result = {};\n    var handle = function(response) {\n      // end of stat responses\n      if (response.header.totalBodyLength === 0) {\n        if (callback) { callback(null, serv.host + ':' + serv.port, result); }\n        return;\n      }\n      // process single stat line response\n      switch (response.header.status) {\n      case  0:\n        result[response.key.toString()] = response.val.toString();\n        break;\n      default:\n        var errorMessage = 'MemJS STATS (' + key + '): ' +\n          errors[response.header.status];\n        logger.log(errorMessage, false);\n        if (callback) {\n          callback(new Error(errorMessage), serv.host + ':' + serv.port, null);\n        }\n      }\n    };\n    handle.quiet = true;\n\n    serv.onResponse(seq, handle);\n    serv.onError(seq, function(err) {\n      if (callback) { callback(err, serv.host + ':' + serv.port, null); }\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    handleStats(this.seq, this.servers[i]);\n  }\n};\n\n\n// STATS\n//\n// Fetches memcache stats from each connected server. The callback is invoked\n// **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a\n// dictionary mapping the stat name to the value of the statistic as a string.\nClient.prototype.stats = function(callback) {\n  this.statsWithKey('', callback);\n};\n\n// RESET_STATS\n//\n// Reset the statistics each server is keeping back to zero. This doesn't clear\n// stats such as item count, but temporary stats such as total number of\n// connections over time.\n//\n// The callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server)\n//\n// _server_ is the `\"hostname:port\"` of the server.\nClient.prototype.resetStats = function(callback) {\n  this.statsWithKey('reset', callback);\n};\n\n// QUIT\n//\n// Closes the connection to each server, notifying them of this intention. Note\n// that quit can race against already outstanding requests when those requests\n// fail and are retried, leading to the quit command winning and closing the\n// connection before the retries complete.\nClient.prototype.quit = function() {\n  this.incrSeq();\n  // TODO: Nicer perhaps to do QUITQ (0x17) but need a new callback for when\n  // write is done.\n  var request = makeRequestBuffer(0x07, '', '', '', this.seq); // QUIT\n  var serv;\n  var i;\n\n  var handleQuit = function(seq, serv) {\n    serv.onResponse(seq, function(/* response */) {\n      serv.close();\n    });\n    serv.onError(seq, function(/* err */) {\n      serv.close();\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    serv = this.servers[i];\n    handleQuit(this.seq, serv);\n  }\n};\n\n// CLOSE\n//\n// Closes (abruptly) connections to all the servers.\nClient.prototype.close = function() {\n  var i;\n  for (i = 0; i < this.servers.length; i++) {\n    this.servers[i].close();\n  }\n};\n\n// Perform a generic single response operation (get, set etc) on a server\n// serv: the server to perform the operation on\n// request: a buffer containing the request\n// seq: the sequence number of the operation. It is used to pin the callbacks\n//      to a specific operation and should never change during a `perform`.\n// callback: a callback invoked when a response is received or the request\n//           fails\n// retries: number of times to retry request on failure\nClient.prototype.perform = function(key, request, seq, callback, retries) {\n  var _this = this;\n  var serv = this.server(key);\n  if (!serv) {\n    if (callback) { callback(new Error('No servers available'), null); }\n    return;\n  }\n\n  retries = retries || this.options.retries;\n  var failover = this.options.failover;\n  var failoverTime = this.options.failoverTime;\n  var origRetries = this.options.retries;\n  var logger = this.options.logger;\n  var retry_delay = this.options.retry_delay;\n\n  var responseHandler = function(response) {\n    if (callback) { callback(null, response); }\n  };\n\n  var errorHandler = function(error) {\n    if (--retries > 0) {\n      // Wait for retry_delay\n      setTimeout(function() {\n        _this.perform(key, request, seq, callback, retries);\n      }, 1000 * retry_delay);\n    } else {\n      logger.log('MemJS: Server <' + serv.host + ':' + serv.port +\n                  '> failed after (' + origRetries +\n                  ') retries with error - ' + error.message);\n      if (failover) {\n        serv.wakeupAt = Date.now() + failoverTime * 1000;\n        _this.perform(key, request, seq, callback, origRetries);\n      } else {\n        if (callback) { callback(error, null); }\n      }\n    }\n  };\n\n  serv.onResponse(seq, responseHandler);\n  serv.onError(seq, errorHandler);\n  serv.write(request);\n};\n\n// Increment the seq value\nClient.prototype.incrSeq = function() {\n  this.seq++;\n\n  // Wrap `this.seq` to 32-bits since the field we fit it into is only 32-bits.\n  this.seq &= 0xffffffff;\n};\n\nexports.Client = Client;\nexports.Server = Server;\nexports.Utils = require('./utils');\nexports.Header = require('./header');\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}