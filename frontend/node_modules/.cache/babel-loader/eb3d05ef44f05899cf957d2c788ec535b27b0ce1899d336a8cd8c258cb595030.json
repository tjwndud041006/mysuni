{"ast":null,"code":"/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict';\n\nconst englishLexicon = require('../data/English/lexicon_from_posjs.json');\nconst dutchLexicon = require('../data/Dutch/brill_Lexicon.json');\nconst DEBUG = false;\nclass Lexicon {\n  // Constructor creates a Lexicon for language\n  constructor(language, defaultCategory, defaultCategoryCapitalised, extendedLexicon) {\n    const lexicon = (() => {\n      switch (language) {\n        case 'EN':\n          return englishLexicon;\n        case 'DU':\n          return dutchLexicon;\n        default:\n          return dutchLexicon;\n      }\n    })();\n    this.lexicon = Object.assign(lexicon, extendedLexicon || {});\n    if (defaultCategory) {\n      this.defaultCategory = defaultCategory;\n      if (defaultCategoryCapitalised) {\n        this.defaultCategoryCapitalised = defaultCategoryCapitalised;\n      }\n    }\n  }\n\n  // Parses a lexicon in text format: word cat1 cat2 ... catn\n  parseLexicon(data) {\n    // Split into an array of non-empty lines\n    const arrayOfLines = data.match(/[^\\r\\n]+/g);\n    this.lexicon = {}; // Object.create(null);\n    const that = this;\n    arrayOfLines.forEach(function (line) {\n      // Split line by whitespace\n      const elements = line.trim().split(/\\s+/);\n      if (elements.length > 0) {\n        that.lexicon[elements[0]] = elements.slice(1);\n      }\n    });\n  }\n  tagWordWithDefaults(word) {\n    if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n      // Capitalised\n      return this.defaultCategoryCapitalised;\n    } else {\n      // If not found assign default_category\n      return this.defaultCategory;\n    }\n  }\n\n  // Returns a list of categories for word\n  tagWord(word) {\n    let categories = this.lexicon[word];\n    DEBUG && console.log(categories);\n    if (!categories || typeof categories === 'function') {\n      categories = this.lexicon[word.toLowerCase()];\n    }\n    if (!categories || typeof categories === 'function') {\n      categories = [this.tagWordWithDefaults(word)];\n    }\n    return categories;\n  }\n\n  // Adds a word to the lexicon. NB simply replaces the entry\n  addWord(word, categories) {\n    this.lexicon[word] = categories;\n  }\n  prettyPrint() {\n    let result = '';\n    const that = this;\n    Object.keys(this.lexicon).forEach(function (token) {\n      result += token + '\\t';\n      that.lexicon[token].forEach(function (cat) {\n        result += cat + '\\t';\n      });\n      result += '\\n';\n    });\n    return result;\n  }\n  nrEntries() {\n    return Object.keys(this.lexicon).length;\n  }\n  size() {\n    return this.nrEntries();\n  }\n  setDefaultCategories(category, categoryCapitalised) {\n    this.defaultCategory = category;\n    if (categoryCapitalised) {\n      this.defaultCategoryCapitalised = categoryCapitalised;\n    }\n  }\n}\nmodule.exports = Lexicon;","map":{"version":3,"names":["englishLexicon","require","dutchLexicon","DEBUG","Lexicon","constructor","language","defaultCategory","defaultCategoryCapitalised","extendedLexicon","lexicon","Object","assign","parseLexicon","data","arrayOfLines","match","that","forEach","line","elements","trim","split","length","slice","tagWordWithDefaults","word","test","tagWord","categories","console","log","toLowerCase","addWord","prettyPrint","result","keys","token","cat","nrEntries","size","setDefaultCategories","category","categoryCapitalised","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/brill_pos_tagger/lib/Lexicon.js"],"sourcesContent":["/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst englishLexicon = require('../data/English/lexicon_from_posjs.json')\nconst dutchLexicon = require('../data/Dutch/brill_Lexicon.json')\n\nconst DEBUG = false\n\nclass Lexicon {\n  // Constructor creates a Lexicon for language\n  constructor (language, defaultCategory, defaultCategoryCapitalised, extendedLexicon) {\n    const lexicon = (() => {\n      switch (language) {\n        case 'EN':\n          return englishLexicon\n        case 'DU':\n          return dutchLexicon\n        default:\n          return dutchLexicon\n      }\n    })()\n\n    this.lexicon = Object.assign(lexicon, extendedLexicon || {})\n\n    if (defaultCategory) {\n      this.defaultCategory = defaultCategory\n      if (defaultCategoryCapitalised) {\n        this.defaultCategoryCapitalised = defaultCategoryCapitalised\n      }\n    }\n  }\n\n  // Parses a lexicon in text format: word cat1 cat2 ... catn\n  parseLexicon (data) {\n    // Split into an array of non-empty lines\n    const arrayOfLines = data.match(/[^\\r\\n]+/g)\n    this.lexicon = {} // Object.create(null);\n    const that = this\n    arrayOfLines.forEach(function (line) {\n      // Split line by whitespace\n      const elements = line.trim().split(/\\s+/)\n      if (elements.length > 0) {\n        that.lexicon[elements[0]] = elements.slice(1)\n      }\n    })\n  }\n\n  tagWordWithDefaults (word) {\n    if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n      // Capitalised\n      return this.defaultCategoryCapitalised\n    } else {\n      // If not found assign default_category\n      return this.defaultCategory\n    }\n  }\n\n  // Returns a list of categories for word\n  tagWord (word) {\n    let categories = this.lexicon[word]\n    DEBUG && console.log(categories)\n    if (!categories || (typeof categories === 'function')) {\n      categories = this.lexicon[word.toLowerCase()]\n    }\n    if (!categories || (typeof categories === 'function')) {\n      categories = [this.tagWordWithDefaults(word)]\n    }\n    return (categories)\n  }\n\n  // Adds a word to the lexicon. NB simply replaces the entry\n  addWord (word, categories) {\n    this.lexicon[word] = categories\n  }\n\n  prettyPrint () {\n    let result = ''\n    const that = this\n    Object.keys(this.lexicon).forEach(function (token) {\n      result += token + '\\t'\n      that.lexicon[token].forEach(function (cat) {\n        result += cat + '\\t'\n      })\n      result += '\\n'\n    })\n    return result\n  }\n\n  nrEntries () {\n    return Object.keys(this.lexicon).length\n  }\n\n  size () {\n    return this.nrEntries()\n  }\n\n  setDefaultCategories (category, categoryCapitalised) {\n    this.defaultCategory = category\n    if (categoryCapitalised) {\n      this.defaultCategoryCapitalised = categoryCapitalised\n    }\n  }\n}\n\nmodule.exports = Lexicon\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,cAAc,GAAGC,OAAO,CAAC,yCAAyC,CAAC;AACzE,MAAMC,YAAY,GAAGD,OAAO,CAAC,kCAAkC,CAAC;AAEhE,MAAME,KAAK,GAAG,KAAK;AAEnB,MAAMC,OAAO,CAAC;EACZ;EACAC,WAAWA,CAAEC,QAAQ,EAAEC,eAAe,EAAEC,0BAA0B,EAAEC,eAAe,EAAE;IACnF,MAAMC,OAAO,GAAG,CAAC,MAAM;MACrB,QAAQJ,QAAQ;QACd,KAAK,IAAI;UACP,OAAON,cAAc;QACvB,KAAK,IAAI;UACP,OAAOE,YAAY;QACrB;UACE,OAAOA,YAAY;MACvB;IACF,CAAC,EAAE,CAAC;IAEJ,IAAI,CAACQ,OAAO,GAAGC,MAAM,CAACC,MAAM,CAACF,OAAO,EAAED,eAAe,IAAI,CAAC,CAAC,CAAC;IAE5D,IAAIF,eAAe,EAAE;MACnB,IAAI,CAACA,eAAe,GAAGA,eAAe;MACtC,IAAIC,0BAA0B,EAAE;QAC9B,IAAI,CAACA,0BAA0B,GAAGA,0BAA0B;MAC9D;IACF;EACF;;EAEA;EACAK,YAAYA,CAAEC,IAAI,EAAE;IAClB;IACA,MAAMC,YAAY,GAAGD,IAAI,CAACE,KAAK,CAAC,WAAW,CAAC;IAC5C,IAAI,CAACN,OAAO,GAAG,CAAC,CAAC,EAAC;IAClB,MAAMO,IAAI,GAAG,IAAI;IACjBF,YAAY,CAACG,OAAO,CAAC,UAAUC,IAAI,EAAE;MACnC;MACA,MAAMC,QAAQ,GAAGD,IAAI,CAACE,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;MACzC,IAAIF,QAAQ,CAACG,MAAM,GAAG,CAAC,EAAE;QACvBN,IAAI,CAACP,OAAO,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC;MAC/C;IACF,CAAC,CAAC;EACJ;EAEAC,mBAAmBA,CAAEC,IAAI,EAAE;IACzB,IAAI,OAAO,CAACC,IAAI,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAClB,0BAA0B,EAAE;MAC5D;MACA,OAAO,IAAI,CAACA,0BAA0B;IACxC,CAAC,MAAM;MACL;MACA,OAAO,IAAI,CAACD,eAAe;IAC7B;EACF;;EAEA;EACAqB,OAAOA,CAAEF,IAAI,EAAE;IACb,IAAIG,UAAU,GAAG,IAAI,CAACnB,OAAO,CAACgB,IAAI,CAAC;IACnCvB,KAAK,IAAI2B,OAAO,CAACC,GAAG,CAACF,UAAU,CAAC;IAChC,IAAI,CAACA,UAAU,IAAK,OAAOA,UAAU,KAAK,UAAW,EAAE;MACrDA,UAAU,GAAG,IAAI,CAACnB,OAAO,CAACgB,IAAI,CAACM,WAAW,CAAC,CAAC,CAAC;IAC/C;IACA,IAAI,CAACH,UAAU,IAAK,OAAOA,UAAU,KAAK,UAAW,EAAE;MACrDA,UAAU,GAAG,CAAC,IAAI,CAACJ,mBAAmB,CAACC,IAAI,CAAC,CAAC;IAC/C;IACA,OAAQG,UAAU;EACpB;;EAEA;EACAI,OAAOA,CAAEP,IAAI,EAAEG,UAAU,EAAE;IACzB,IAAI,CAACnB,OAAO,CAACgB,IAAI,CAAC,GAAGG,UAAU;EACjC;EAEAK,WAAWA,CAAA,EAAI;IACb,IAAIC,MAAM,GAAG,EAAE;IACf,MAAMlB,IAAI,GAAG,IAAI;IACjBN,MAAM,CAACyB,IAAI,CAAC,IAAI,CAAC1B,OAAO,CAAC,CAACQ,OAAO,CAAC,UAAUmB,KAAK,EAAE;MACjDF,MAAM,IAAIE,KAAK,GAAG,IAAI;MACtBpB,IAAI,CAACP,OAAO,CAAC2B,KAAK,CAAC,CAACnB,OAAO,CAAC,UAAUoB,GAAG,EAAE;QACzCH,MAAM,IAAIG,GAAG,GAAG,IAAI;MACtB,CAAC,CAAC;MACFH,MAAM,IAAI,IAAI;IAChB,CAAC,CAAC;IACF,OAAOA,MAAM;EACf;EAEAI,SAASA,CAAA,EAAI;IACX,OAAO5B,MAAM,CAACyB,IAAI,CAAC,IAAI,CAAC1B,OAAO,CAAC,CAACa,MAAM;EACzC;EAEAiB,IAAIA,CAAA,EAAI;IACN,OAAO,IAAI,CAACD,SAAS,CAAC,CAAC;EACzB;EAEAE,oBAAoBA,CAAEC,QAAQ,EAAEC,mBAAmB,EAAE;IACnD,IAAI,CAACpC,eAAe,GAAGmC,QAAQ;IAC/B,IAAIC,mBAAmB,EAAE;MACvB,IAAI,CAACnC,0BAA0B,GAAGmC,mBAAmB;IACvD;EACF;AACF;AAEAC,MAAM,CAACC,OAAO,GAAGzC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}