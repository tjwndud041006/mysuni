{"ast":null,"code":"// fuzzy-match (damerau-levenshtein)\n// Based on  tad-lispy /node-damerau-levenshtein\n// https://github.com/tad-lispy/node-damerau-levenshtein/blob/master/index.js\n// count steps (insertions, deletions, substitutions, or transpositions)\nconst editDistance = function (strA, strB) {\n  let aLength = strA.length,\n    bLength = strB.length;\n  // fail-fast\n  if (aLength === 0) {\n    return bLength;\n  }\n  if (bLength === 0) {\n    return aLength;\n  }\n  // If the limit is not defined it will be calculate from this and that args.\n  let limit = (bLength > aLength ? bLength : aLength) + 1;\n  if (Math.abs(aLength - bLength) > (limit || 100)) {\n    return limit || 100;\n  }\n  // init the array\n  let matrix = [];\n  for (let i = 0; i < limit; i++) {\n    matrix[i] = [i];\n    matrix[i].length = limit;\n  }\n  for (let i = 0; i < limit; i++) {\n    matrix[0][i] = i;\n  }\n  // Calculate matrix.\n  let j, a_index, b_index, cost, min, t;\n  for (let i = 1; i <= aLength; ++i) {\n    a_index = strA[i - 1];\n    for (j = 1; j <= bLength; ++j) {\n      // Check the jagged distance total so far\n      if (i === j && matrix[i][j] > 4) {\n        return aLength;\n      }\n      b_index = strB[j - 1];\n      cost = a_index === b_index ? 0 : 1; // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n      min = matrix[i - 1][j] + 1; // Deletion.\n      if ((t = matrix[i][j - 1] + 1) < min) min = t; // Insertion.\n      if ((t = matrix[i - 1][j - 1] + cost) < min) min = t; // Substitution.\n      // Update matrix.\n      let shouldUpdate = i > 1 && j > 1 && a_index === strB[j - 2] && strA[i - 2] === b_index && (t = matrix[i - 2][j - 2] + cost) < min;\n      if (shouldUpdate) {\n        matrix[i][j] = t;\n      } else {\n        matrix[i][j] = min;\n      }\n    }\n  }\n  // return number of steps\n  return matrix[aLength][bLength];\n};\n// score similarity by from 0-1 (steps/length)\nconst fuzzyMatch = function (strA, strB, minLength = 3) {\n  if (strA === strB) {\n    return 1;\n  }\n  //don't even bother on tiny strings\n  if (strA.length < minLength || strB.length < minLength) {\n    return 0;\n  }\n  const steps = editDistance(strA, strB);\n  let length = Math.max(strA.length, strB.length);\n  let relative = length === 0 ? 0 : steps / length;\n  let similarity = 1 - relative;\n  return similarity;\n};\nexport default fuzzyMatch;","map":{"version":3,"names":["editDistance","strA","strB","aLength","length","bLength","limit","Math","abs","matrix","i","j","a_index","b_index","cost","min","t","shouldUpdate","fuzzyMatch","minLength","steps","max","relative","similarity"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/term/_fuzzy.js"],"sourcesContent":["// fuzzy-match (damerau-levenshtein)\n// Based on  tad-lispy /node-damerau-levenshtein\n// https://github.com/tad-lispy/node-damerau-levenshtein/blob/master/index.js\n// count steps (insertions, deletions, substitutions, or transpositions)\nconst editDistance = function (strA, strB) {\n  let aLength = strA.length,\n    bLength = strB.length\n  // fail-fast\n  if (aLength === 0) {\n    return bLength\n  }\n  if (bLength === 0) {\n    return aLength\n  }\n  // If the limit is not defined it will be calculate from this and that args.\n  let limit = (bLength > aLength ? bLength : aLength) + 1\n  if (Math.abs(aLength - bLength) > (limit || 100)) {\n    return limit || 100\n  }\n  // init the array\n  let matrix = []\n  for (let i = 0; i < limit; i++) {\n    matrix[i] = [i]\n    matrix[i].length = limit\n  }\n  for (let i = 0; i < limit; i++) {\n    matrix[0][i] = i\n  }\n  // Calculate matrix.\n  let j, a_index, b_index, cost, min, t\n  for (let i = 1; i <= aLength; ++i) {\n    a_index = strA[i - 1]\n    for (j = 1; j <= bLength; ++j) {\n      // Check the jagged distance total so far\n      if (i === j && matrix[i][j] > 4) {\n        return aLength\n      }\n      b_index = strB[j - 1]\n      cost = a_index === b_index ? 0 : 1 // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n      min = matrix[i - 1][j] + 1 // Deletion.\n      if ((t = matrix[i][j - 1] + 1) < min) min = t // Insertion.\n      if ((t = matrix[i - 1][j - 1] + cost) < min) min = t // Substitution.\n      // Update matrix.\n      let shouldUpdate =\n        i > 1 && j > 1 && a_index === strB[j - 2] && strA[i - 2] === b_index && (t = matrix[i - 2][j - 2] + cost) < min\n      if (shouldUpdate) {\n        matrix[i][j] = t\n      } else {\n        matrix[i][j] = min\n      }\n    }\n  }\n  // return number of steps\n  return matrix[aLength][bLength]\n}\n// score similarity by from 0-1 (steps/length)\nconst fuzzyMatch = function (strA, strB, minLength = 3) {\n  if (strA === strB) {\n    return 1\n  }\n  //don't even bother on tiny strings\n  if (strA.length < minLength || strB.length < minLength) {\n    return 0\n  }\n  const steps = editDistance(strA, strB)\n  let length = Math.max(strA.length, strB.length)\n  let relative = length === 0 ? 0 : steps / length\n  let similarity = 1 - relative\n  return similarity\n}\nexport default fuzzyMatch\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}