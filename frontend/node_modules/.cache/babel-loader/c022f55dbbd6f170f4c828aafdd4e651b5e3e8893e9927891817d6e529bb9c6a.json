{"ast":null,"code":"import doAstrix from './steps/astrix.js';\nimport doOrBlock from './steps/or-block.js';\nimport doAndBlock from './steps/and-block.js';\nimport doNegative from './steps/negative.js';\nimport simpleMatch from './steps/simple-match.js';\nimport { isEndGreedy } from './steps/logic/greedy.js';\nimport matchTerm from './term/doesMatch.js';\n// i formally apologize for how complicated this is.\n\n/** \n * try a sequence of match tokens ('regs') \n * on a sequence of terms, \n * starting at this certain term.\n */\nconst tryHere = function (terms, regs, start_i, phrase_length) {\n  // console.log(`\\n\\n:start: '${terms[0].text}':`)\n  if (terms.length === 0 || regs.length === 0) {\n    return null;\n  }\n  // all the variables that matter\n  let state = {\n    t: 0,\n    terms: terms,\n    r: 0,\n    regs: regs,\n    groups: {},\n    start_i: start_i,\n    phrase_length: phrase_length,\n    inGroup: null\n  };\n\n  // we must satisfy every token in 'regs'\n  // if we get to the end, we have a match.\n  for (; state.r < regs.length; state.r += 1) {\n    let reg = regs[state.r];\n    // Check if this reg has a named capture group\n    state.hasGroup = Boolean(reg.group);\n    // Reuse previous capture group if same\n    if (state.hasGroup === true) {\n      state.inGroup = reg.group;\n    } else {\n      state.inGroup = null;\n    }\n    //have we run-out of terms?\n    if (!state.terms[state.t]) {\n      //are all remaining regs optional or negative?\n      const alive = regs.slice(state.r).some(remain => !remain.optional);\n      if (alive === false) {\n        break; //done!\n      }\n      return null; // die\n    }\n    // support 'unspecific greedy' .* properly\n    if (reg.anything === true && reg.greedy === true) {\n      let alive = doAstrix(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // slow-OR - multi-word OR (a|b|foo bar)\n    if (reg.choices !== undefined && reg.operator === 'or') {\n      let alive = doOrBlock(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // slow-AND - multi-word AND (#Noun && foo) blocks\n    if (reg.choices !== undefined && reg.operator === 'and') {\n      let alive = doAndBlock(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // support '.' as any-single\n    if (reg.anything === true) {\n      // '!.' negative anything should insta-fail\n      if (reg.negative && reg.anything) {\n        return null;\n      }\n      let alive = simpleMatch(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // support 'foo*$' until the end\n    if (isEndGreedy(reg, state) === true) {\n      let alive = simpleMatch(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // ok, it doesn't match - but maybe it wasn't *supposed* to?\n    if (reg.negative) {\n      // we want *anything* but this term\n      let alive = doNegative(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    // ok, finally test the term-reg\n    let hasMatch = matchTerm(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);\n    if (hasMatch === true) {\n      let alive = simpleMatch(state);\n      if (!alive) {\n        return null;\n      }\n      continue;\n    }\n    //ok who cares, keep going\n    if (reg.optional === true) {\n      continue;\n    }\n\n    // finally, we die\n    return null;\n  }\n  //return our results, as pointers\n  let pntr = [null, start_i, state.t + start_i];\n  if (pntr[1] === pntr[2]) {\n    return null; //found 0 terms\n  }\n  let groups = {};\n  Object.keys(state.groups).forEach(k => {\n    let o = state.groups[k];\n    let start = start_i + o.start;\n    groups[k] = [null, start, start + o.length];\n  });\n  return {\n    pointer: pntr,\n    groups: groups\n  };\n};\nexport default tryHere;","map":{"version":3,"names":["doAstrix","doOrBlock","doAndBlock","doNegative","simpleMatch","isEndGreedy","matchTerm","tryHere","terms","regs","start_i","phrase_length","length","state","t","r","groups","inGroup","reg","hasGroup","Boolean","group","alive","slice","some","remain","optional","anything","greedy","choices","undefined","operator","negative","hasMatch","pntr","Object","keys","forEach","k","o","start","pointer"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/02-from-here.js"],"sourcesContent":["import doAstrix from './steps/astrix.js'\nimport doOrBlock from './steps/or-block.js'\nimport doAndBlock from './steps/and-block.js'\nimport doNegative from './steps/negative.js'\nimport simpleMatch from './steps/simple-match.js'\nimport { isEndGreedy } from './steps/logic/greedy.js'\nimport matchTerm from './term/doesMatch.js'\n// i formally apologize for how complicated this is.\n\n/** \n * try a sequence of match tokens ('regs') \n * on a sequence of terms, \n * starting at this certain term.\n */\nconst tryHere = function (terms, regs, start_i, phrase_length) {\n  // console.log(`\\n\\n:start: '${terms[0].text}':`)\n  if (terms.length === 0 || regs.length === 0) {\n    return null\n  }\n  // all the variables that matter\n  let state = {\n    t: 0,\n    terms: terms,\n    r: 0,\n    regs: regs,\n    groups: {},\n    start_i: start_i,\n    phrase_length: phrase_length,\n    inGroup: null,\n  }\n\n  // we must satisfy every token in 'regs'\n  // if we get to the end, we have a match.\n  for (; state.r < regs.length; state.r += 1) {\n    let reg = regs[state.r]\n    // Check if this reg has a named capture group\n    state.hasGroup = Boolean(reg.group)\n    // Reuse previous capture group if same\n    if (state.hasGroup === true) {\n      state.inGroup = reg.group\n    } else {\n      state.inGroup = null\n    }\n    //have we run-out of terms?\n    if (!state.terms[state.t]) {\n      //are all remaining regs optional or negative?\n      const alive = regs.slice(state.r).some(remain => !remain.optional)\n      if (alive === false) {\n        break //done!\n      }\n      return null // die\n    }\n    // support 'unspecific greedy' .* properly\n    if (reg.anything === true && reg.greedy === true) {\n      let alive = doAstrix(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // slow-OR - multi-word OR (a|b|foo bar)\n    if (reg.choices !== undefined && reg.operator === 'or') {\n      let alive = doOrBlock(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // slow-AND - multi-word AND (#Noun && foo) blocks\n    if (reg.choices !== undefined && reg.operator === 'and') {\n      let alive = doAndBlock(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // support '.' as any-single\n    if (reg.anything === true) {\n      // '!.' negative anything should insta-fail\n      if (reg.negative && reg.anything) {\n        return null\n      }\n      let alive = simpleMatch(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // support 'foo*$' until the end\n    if (isEndGreedy(reg, state) === true) {\n      let alive = simpleMatch(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // ok, it doesn't match - but maybe it wasn't *supposed* to?\n    if (reg.negative) {\n      // we want *anything* but this term\n      let alive = doNegative(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    // ok, finally test the term-reg\n    let hasMatch = matchTerm(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length)\n    if (hasMatch === true) {\n      let alive = simpleMatch(state)\n      if (!alive) {\n        return null\n      }\n      continue\n    }\n    //ok who cares, keep going\n    if (reg.optional === true) {\n      continue\n    }\n\n    // finally, we die\n    return null\n  }\n  //return our results, as pointers\n  let pntr = [null, start_i, state.t + start_i]\n  if (pntr[1] === pntr[2]) {\n    return null //found 0 terms\n  }\n  let groups = {}\n  Object.keys(state.groups).forEach(k => {\n    let o = state.groups[k]\n    let start = start_i + o.start\n    groups[k] = [null, start, start + o.length]\n  })\n  return { pointer: pntr, groups: groups }\n}\nexport default tryHere\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}