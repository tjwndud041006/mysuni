{"ast":null,"code":"const hasMinMax = /\\{([0-9]+)?(, *[0-9]*)?\\}/;\nconst andSign = /&&/;\n// const hasDash = /\\p{Letter}[-–—]\\p{Letter}/u\nconst captureName = new RegExp(/^<\\s*(\\S+)\\s*>/);\n/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\nconst titleCase = str => str.charAt(0).toUpperCase() + str.substring(1);\nconst end = str => str.charAt(str.length - 1);\nconst start = str => str.charAt(0);\nconst stripStart = str => str.substring(1);\nconst stripEnd = str => str.substring(0, str.length - 1);\nconst stripBoth = function (str) {\n  str = stripStart(str);\n  str = stripEnd(str);\n  return str;\n};\n//\nconst parseToken = function (w, opts) {\n  let obj = {};\n  //collect any flags (do it twice)\n  for (let i = 0; i < 2; i += 1) {\n    //end-flag\n    if (end(w) === '$') {\n      obj.end = true;\n      w = stripEnd(w);\n    }\n    //front-flag\n    if (start(w) === '^') {\n      obj.start = true;\n      w = stripStart(w);\n    }\n    if (end(w) === '?') {\n      obj.optional = true;\n      w = stripEnd(w);\n    }\n    //capture group (this one can span multiple-terms)\n    if (start(w) === '[' || end(w) === ']') {\n      obj.group = null;\n      if (start(w) === '[') {\n        obj.groupStart = true;\n      }\n      if (end(w) === ']') {\n        obj.groupEnd = true;\n      }\n      w = w.replace(/^\\[/, '');\n      w = w.replace(/\\]$/, '');\n      // Use capture group name\n      if (start(w) === '<') {\n        const res = captureName.exec(w);\n        if (res.length >= 2) {\n          obj.group = res[1];\n          w = w.replace(res[0], '');\n        }\n      }\n    }\n    //back-flags\n    if (end(w) === '+') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n    if (start(w) === '!') {\n      obj.negative = true;\n      // obj.optional = true\n      w = stripStart(w);\n    }\n    //soft-match\n    if (start(w) === '~' && end(w) === '~' && w.length > 2) {\n      w = stripBoth(w);\n      obj.fuzzy = true;\n      obj.min = opts.fuzzy || 0.85;\n      if (/\\(/.test(w) === false) {\n        obj.word = w;\n        return obj;\n      }\n    }\n\n    //regex\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w);\n      if (opts.caseSensitive) {\n        obj.use = 'text';\n      }\n      obj.regex = new RegExp(w); //potential vuln - security/detect-non-literal-regexp\n      return obj;\n    }\n\n    // support foo{1,9}\n    if (hasMinMax.test(w) === true) {\n      w = w.replace(hasMinMax, (_a, b, c) => {\n        if (c === undefined) {\n          // '{3}'\tExactly three times\n          obj.min = Number(b);\n          obj.max = Number(b);\n        } else {\n          c = c.replace(/, */, '');\n          if (b === undefined) {\n            // '{,9}' implied zero min\n            obj.min = 0;\n            obj.max = Number(c);\n          } else {\n            // '{2,4}' Two to four times\n            obj.min = Number(b);\n            // '{3,}' Three or more times\n            obj.max = Number(c || 999);\n          }\n        }\n        // use same method as '+'\n        obj.greedy = true;\n        // 0 as min means the same as '?'\n        if (!obj.min) {\n          obj.optional = true;\n        }\n        return '';\n      });\n    }\n\n    //wrapped-flags\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign);\n        obj.operator = 'and';\n      } else {\n        obj.choices = w.split('|');\n        obj.operator = 'or';\n      }\n      //remove '(' and ')'\n      obj.choices[0] = stripStart(obj.choices[0]);\n      let last = obj.choices.length - 1;\n      obj.choices[last] = stripEnd(obj.choices[last]);\n      // clean up the results\n      obj.choices = obj.choices.map(s => s.trim());\n      obj.choices = obj.choices.filter(s => s);\n      //recursion alert!\n      obj.choices = obj.choices.map(str => {\n        return str.split(/ /g).map(s => parseToken(s, opts));\n      });\n      w = '';\n    }\n\n    //root/sense overloaded\n    if (start(w) === '{' && end(w) === '}') {\n      w = stripBoth(w);\n      // obj.sense = w\n      obj.root = w;\n      if (/\\//.test(w)) {\n        let split = obj.root.split(/\\//);\n        obj.root = split[0];\n        obj.pos = split[1];\n        if (obj.pos === 'adj') {\n          obj.pos = 'Adjective';\n        }\n        // titlecase\n        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();\n        // add sense-number too\n        if (split[2] !== undefined) {\n          obj.sense = split[2];\n        }\n      }\n      return obj;\n    }\n    //chunks\n    if (start(w) === '<' && end(w) === '>') {\n      w = stripBoth(w);\n      obj.chunk = titleCase(w);\n      obj.greedy = true;\n      return obj;\n    }\n    if (start(w) === '%' && end(w) === '%') {\n      w = stripBoth(w);\n      obj.switch = w;\n      return obj;\n    }\n  }\n  //do the actual token content\n  if (start(w) === '#') {\n    obj.tag = stripStart(w);\n    obj.tag = titleCase(obj.tag);\n    return obj;\n  }\n  //dynamic function on a term object\n  if (start(w) === '@') {\n    obj.method = stripStart(w);\n    return obj;\n  }\n  if (w === '.') {\n    obj.anything = true;\n    return obj;\n  }\n  //support alone-astrix\n  if (w === '*') {\n    obj.anything = true;\n    obj.greedy = true;\n    obj.optional = true;\n    return obj;\n  }\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*');\n    w = w.replace('\\\\.', '.');\n    if (opts.caseSensitive) {\n      obj.use = 'text';\n    } else {\n      w = w.toLowerCase();\n    }\n    obj.word = w;\n  }\n  return obj;\n};\nexport default parseToken;","map":{"version":3,"names":["hasMinMax","andSign","captureName","RegExp","titleCase","str","charAt","toUpperCase","substring","end","length","start","stripStart","stripEnd","stripBoth","parseToken","w","opts","obj","i","optional","group","groupStart","groupEnd","replace","res","exec","greedy","negative","fuzzy","min","test","word","caseSensitive","use","regex","_a","b","c","undefined","Number","max","choices","split","operator","last","map","s","trim","filter","root","pos","substr","toLowerCase","sense","chunk","switch","tag","method","anything"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js"],"sourcesContent":["const hasMinMax = /\\{([0-9]+)?(, *[0-9]*)?\\}/\nconst andSign = /&&/\n// const hasDash = /\\p{Letter}[-–—]\\p{Letter}/u\nconst captureName = new RegExp(/^<\\s*(\\S+)\\s*>/)\n/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\nconst titleCase = str => str.charAt(0).toUpperCase() + str.substring(1)\nconst end = (str) => str.charAt(str.length - 1)\nconst start = (str) => str.charAt(0)\nconst stripStart = (str) => str.substring(1)\nconst stripEnd = (str) => str.substring(0, str.length - 1)\n\nconst stripBoth = function (str) {\n  str = stripStart(str)\n  str = stripEnd(str)\n  return str\n}\n//\nconst parseToken = function (w, opts) {\n  let obj = {}\n  //collect any flags (do it twice)\n  for (let i = 0; i < 2; i += 1) {\n    //end-flag\n    if (end(w) === '$') {\n      obj.end = true\n      w = stripEnd(w)\n    }\n    //front-flag\n    if (start(w) === '^') {\n      obj.start = true\n      w = stripStart(w)\n    }\n    if (end(w) === '?') {\n      obj.optional = true\n      w = stripEnd(w)\n    }\n    //capture group (this one can span multiple-terms)\n    if (start(w) === '[' || end(w) === ']') {\n      obj.group = null\n      if (start(w) === '[') {\n        obj.groupStart = true\n      }\n      if (end(w) === ']') {\n        obj.groupEnd = true\n      }\n      w = w.replace(/^\\[/, '')\n      w = w.replace(/\\]$/, '')\n      // Use capture group name\n      if (start(w) === '<') {\n        const res = captureName.exec(w)\n        if (res.length >= 2) {\n          obj.group = res[1]\n          w = w.replace(res[0], '')\n        }\n      }\n    }\n    //back-flags\n    if (end(w) === '+') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (start(w) === '!') {\n      obj.negative = true\n      // obj.optional = true\n      w = stripStart(w)\n    }\n    //soft-match\n    if (start(w) === '~' && end(w) === '~' && w.length > 2) {\n      w = stripBoth(w)\n      obj.fuzzy = true\n      obj.min = opts.fuzzy || 0.85\n      if (/\\(/.test(w) === false) {\n        obj.word = w\n        return obj\n      }\n    }\n\n    //regex\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w)\n      if (opts.caseSensitive) {\n        obj.use = 'text'\n      }\n      obj.regex = new RegExp(w) //potential vuln - security/detect-non-literal-regexp\n      return obj\n    }\n\n    // support foo{1,9}\n    if (hasMinMax.test(w) === true) {\n      w = w.replace(hasMinMax, (_a, b, c) => {\n        if (c === undefined) {\n          // '{3}'\tExactly three times\n          obj.min = Number(b)\n          obj.max = Number(b)\n        } else {\n          c = c.replace(/, */, '')\n          if (b === undefined) {\n            // '{,9}' implied zero min\n            obj.min = 0\n            obj.max = Number(c)\n          } else {\n            // '{2,4}' Two to four times\n            obj.min = Number(b)\n            // '{3,}' Three or more times\n            obj.max = Number(c || 999)\n          }\n        }\n        // use same method as '+'\n        obj.greedy = true\n        // 0 as min means the same as '?'\n        if (!obj.min) {\n          obj.optional = true\n        }\n        return ''\n      })\n    }\n\n    //wrapped-flags\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign)\n        obj.operator = 'and'\n      } else {\n        obj.choices = w.split('|')\n        obj.operator = 'or'\n      }\n      //remove '(' and ')'\n      obj.choices[0] = stripStart(obj.choices[0])\n      let last = obj.choices.length - 1\n      obj.choices[last] = stripEnd(obj.choices[last])\n      // clean up the results\n      obj.choices = obj.choices.map(s => s.trim())\n      obj.choices = obj.choices.filter(s => s)\n      //recursion alert!\n      obj.choices = obj.choices.map(str => {\n        return str.split(/ /g).map(s => parseToken(s, opts))\n      })\n      w = ''\n    }\n\n    //root/sense overloaded\n    if (start(w) === '{' && end(w) === '}') {\n      w = stripBoth(w)\n      // obj.sense = w\n      obj.root = w\n      if (/\\//.test(w)) {\n        let split = obj.root.split(/\\//)\n        obj.root = split[0]\n        obj.pos = split[1]\n        if (obj.pos === 'adj') {\n          obj.pos = 'Adjective'\n        }\n        // titlecase\n        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase()\n        // add sense-number too\n        if (split[2] !== undefined) {\n          obj.sense = split[2]\n        }\n      }\n      return obj\n    }\n    //chunks\n    if (start(w) === '<' && end(w) === '>') {\n      w = stripBoth(w)\n      obj.chunk = titleCase(w)\n      obj.greedy = true\n      return obj\n    }\n    if (start(w) === '%' && end(w) === '%') {\n      w = stripBoth(w)\n      obj.switch = w\n      return obj\n    }\n  }\n  //do the actual token content\n  if (start(w) === '#') {\n    obj.tag = stripStart(w)\n    obj.tag = titleCase(obj.tag)\n    return obj\n  }\n  //dynamic function on a term object\n  if (start(w) === '@') {\n    obj.method = stripStart(w)\n    return obj\n  }\n  if (w === '.') {\n    obj.anything = true\n    return obj\n  }\n  //support alone-astrix\n  if (w === '*') {\n    obj.anything = true\n    obj.greedy = true\n    obj.optional = true\n    return obj\n  }\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*')\n    w = w.replace('\\\\.', '.')\n    if (opts.caseSensitive) {\n      obj.use = 'text'\n    } else {\n      w = w.toLowerCase()\n    }\n    obj.word = w\n  }\n  return obj\n}\nexport default parseToken\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}