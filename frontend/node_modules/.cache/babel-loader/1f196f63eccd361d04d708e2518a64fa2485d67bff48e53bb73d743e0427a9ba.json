{"ast":null,"code":"import parseSymbols from './symbols.js';\nimport encoding from '../encoding.js';\n\n// References are either absolute (symbol) or relative (1 - based)\nconst indexFromRef = function (trie, ref, index) {\n  const dnode = encoding.fromAlphaCode(ref);\n  if (dnode < trie.symCount) {\n    return trie.syms[dnode];\n  }\n  return index + dnode + 1 - trie.symCount;\n};\nconst toArray = function (trie) {\n  const all = [];\n  const crawl = (index, pref) => {\n    let node = trie.nodes[index];\n    if (node[0] === '!') {\n      all.push(pref);\n      node = node.slice(1); //ok, we tried. remove it.\n    }\n    const matches = node.split(/([A-Z0-9,]+)/g);\n    for (let i = 0; i < matches.length; i += 2) {\n      const str = matches[i];\n      const ref = matches[i + 1];\n      if (!str) {\n        continue;\n      }\n      const have = pref + str;\n      //branch's end\n      if (ref === ',' || ref === undefined) {\n        all.push(have);\n        continue;\n      }\n      const newIndex = indexFromRef(trie, ref, index);\n      crawl(newIndex, have);\n    }\n  };\n  crawl(0, '');\n  return all;\n};\n\n//PackedTrie - Trie traversal of the Trie packed-string representation.\nconst unpack = function (str) {\n  const trie = {\n    nodes: str.split(';'),\n    syms: [],\n    symCount: 0\n  };\n  //process symbols, if they have them\n  if (str.match(':')) {\n    parseSymbols(trie);\n  }\n  return toArray(trie);\n};\nexport default unpack;","map":{"version":3,"names":["parseSymbols","encoding","indexFromRef","trie","ref","index","dnode","fromAlphaCode","symCount","syms","toArray","all","crawl","pref","node","nodes","push","slice","matches","split","i","length","str","have","undefined","newIndex","unpack","match"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/efrt/src/unpack/traverse.js"],"sourcesContent":["import parseSymbols from './symbols.js'\nimport encoding from '../encoding.js'\n\n// References are either absolute (symbol) or relative (1 - based)\nconst indexFromRef = function (trie, ref, index) {\n  const dnode = encoding.fromAlphaCode(ref)\n  if (dnode < trie.symCount) {\n    return trie.syms[dnode]\n  }\n  return index + dnode + 1 - trie.symCount\n}\n\nconst toArray = function (trie) {\n  const all = []\n  const crawl = (index, pref) => {\n    let node = trie.nodes[index]\n    if (node[0] === '!') {\n      all.push(pref)\n      node = node.slice(1) //ok, we tried. remove it.\n    }\n    const matches = node.split(/([A-Z0-9,]+)/g)\n    for (let i = 0; i < matches.length; i += 2) {\n      const str = matches[i]\n      const ref = matches[i + 1]\n      if (!str) {\n        continue\n      }\n      const have = pref + str\n      //branch's end\n      if (ref === ',' || ref === undefined) {\n        all.push(have)\n        continue\n      }\n      const newIndex = indexFromRef(trie, ref, index)\n      crawl(newIndex, have)\n    }\n  }\n  crawl(0, '')\n  return all\n}\n\n//PackedTrie - Trie traversal of the Trie packed-string representation.\nconst unpack = function (str) {\n  const trie = {\n    nodes: str.split(';'),\n    syms: [],\n    symCount: 0\n  }\n  //process symbols, if they have them\n  if (str.match(':')) {\n    parseSymbols(trie)\n  }\n  return toArray(trie)\n}\n\nexport default unpack\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,cAAc;AACvC,OAAOC,QAAQ,MAAM,gBAAgB;;AAErC;AACA,MAAMC,YAAY,GAAG,SAAAA,CAAUC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAC/C,MAAMC,KAAK,GAAGL,QAAQ,CAACM,aAAa,CAACH,GAAG,CAAC;EACzC,IAAIE,KAAK,GAAGH,IAAI,CAACK,QAAQ,EAAE;IACzB,OAAOL,IAAI,CAACM,IAAI,CAACH,KAAK,CAAC;EACzB;EACA,OAAOD,KAAK,GAAGC,KAAK,GAAG,CAAC,GAAGH,IAAI,CAACK,QAAQ;AAC1C,CAAC;AAED,MAAME,OAAO,GAAG,SAAAA,CAAUP,IAAI,EAAE;EAC9B,MAAMQ,GAAG,GAAG,EAAE;EACd,MAAMC,KAAK,GAAGA,CAACP,KAAK,EAAEQ,IAAI,KAAK;IAC7B,IAAIC,IAAI,GAAGX,IAAI,CAACY,KAAK,CAACV,KAAK,CAAC;IAC5B,IAAIS,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACnBH,GAAG,CAACK,IAAI,CAACH,IAAI,CAAC;MACdC,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,EAAC;IACvB;IACA,MAAMC,OAAO,GAAGJ,IAAI,CAACK,KAAK,CAAC,eAAe,CAAC;IAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC1C,MAAME,GAAG,GAAGJ,OAAO,CAACE,CAAC,CAAC;MACtB,MAAMhB,GAAG,GAAGc,OAAO,CAACE,CAAC,GAAG,CAAC,CAAC;MAC1B,IAAI,CAACE,GAAG,EAAE;QACR;MACF;MACA,MAAMC,IAAI,GAAGV,IAAI,GAAGS,GAAG;MACvB;MACA,IAAIlB,GAAG,KAAK,GAAG,IAAIA,GAAG,KAAKoB,SAAS,EAAE;QACpCb,GAAG,CAACK,IAAI,CAACO,IAAI,CAAC;QACd;MACF;MACA,MAAME,QAAQ,GAAGvB,YAAY,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,CAAC;MAC/CO,KAAK,CAACa,QAAQ,EAAEF,IAAI,CAAC;IACvB;EACF,CAAC;EACDX,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACZ,OAAOD,GAAG;AACZ,CAAC;;AAED;AACA,MAAMe,MAAM,GAAG,SAAAA,CAAUJ,GAAG,EAAE;EAC5B,MAAMnB,IAAI,GAAG;IACXY,KAAK,EAAEO,GAAG,CAACH,KAAK,CAAC,GAAG,CAAC;IACrBV,IAAI,EAAE,EAAE;IACRD,QAAQ,EAAE;EACZ,CAAC;EACD;EACA,IAAIc,GAAG,CAACK,KAAK,CAAC,GAAG,CAAC,EAAE;IAClB3B,YAAY,CAACG,IAAI,CAAC;EACpB;EACA,OAAOO,OAAO,CAACP,IAAI,CAAC;AACtB,CAAC;AAED,eAAeuB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}