{"ast":null,"code":"/*\n  Important notice - \n  this method makes many assumptions about gender-identity, in-order to assign grammatical gender.\n  it should not be used for any other purposes, other than resolving pronouns in english\n*/\nconst m = 'male';\nconst f = 'female';\n\n// known gendered honorifics\nconst honorifics = {\n  mr: m,\n  mrs: f,\n  miss: f,\n  madam: f,\n  // british stuff\n  king: m,\n  queen: f,\n  duke: m,\n  duchess: f,\n  baron: m,\n  baroness: f,\n  count: m,\n  countess: f,\n  prince: m,\n  princess: f,\n  sire: m,\n  dame: f,\n  lady: f,\n  ayatullah: m,\n  //i think?\n\n  congressman: m,\n  congresswoman: f,\n  'first lady': f,\n  // marked as non-binary\n  mx: null\n};\nconst predictGender = function (parsed, person) {\n  let {\n    firstName,\n    honorific\n  } = parsed;\n  // use first-name as signal-signal\n  if (firstName.has('#FemaleName')) {\n    return f;\n  }\n  if (firstName.has('#MaleName')) {\n    return m;\n  }\n  // use honorics as gender-signal\n  if (honorific.found) {\n    let hon = honorific.text('normal');\n    hon = hon.replace(/\\./g, ''); //clean it up a bit\n    if (honorifics.hasOwnProperty(hon)) {\n      return honorifics[hon];\n    }\n    // her excelency\n    if (/^her /.test(hon)) {\n      return f;\n    }\n    if (/^his /.test(hon)) {\n      return m;\n    }\n  }\n  // offer used-pronouns as a signal\n  let after = person.after();\n  if (!after.has('#Person') && after.has('#Pronoun')) {\n    let pro = after.match('#Pronoun');\n    // manual use of gender-neutral\n    if (pro.has('(they|their)')) {\n      return null;\n    }\n    let hasMasc = pro.has('(he|his)');\n    let hasFem = pro.has('(she|her|hers)');\n    if (hasMasc && !hasFem) {\n      return m;\n    }\n    if (hasFem && !hasMasc) {\n      return f;\n    }\n  }\n  return null;\n};\nexport default predictGender;","map":{"version":3,"names":["m","f","honorifics","mr","mrs","miss","madam","king","queen","duke","duchess","baron","baroness","count","countess","prince","princess","sire","dame","lady","ayatullah","congressman","congresswoman","mx","predictGender","parsed","person","firstName","honorific","has","found","hon","text","replace","hasOwnProperty","test","after","pro","match","hasMasc","hasFem"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/topics/people/gender.js"],"sourcesContent":["/*\n  Important notice - \n  this method makes many assumptions about gender-identity, in-order to assign grammatical gender.\n  it should not be used for any other purposes, other than resolving pronouns in english\n*/\nconst m = 'male'\nconst f = 'female'\n\n// known gendered honorifics\nconst honorifics = {\n  mr: m,\n  mrs: f,\n  miss: f,\n  madam: f,\n\n  // british stuff\n  king: m,\n  queen: f,\n  duke: m,\n  duchess: f,\n  baron: m,\n  baroness: f,\n  count: m,\n  countess: f,\n  prince: m,\n  princess: f,\n  sire: m,\n  dame: f,\n  lady: f,\n\n  ayatullah: m, //i think?\n\n  congressman: m,\n  congresswoman: f,\n  'first lady': f,\n\n  // marked as non-binary\n  mx: null,\n}\n\nconst predictGender = function (parsed, person) {\n  let { firstName, honorific } = parsed\n  // use first-name as signal-signal\n  if (firstName.has('#FemaleName')) {\n    return f\n  }\n  if (firstName.has('#MaleName')) {\n    return m\n  }\n  // use honorics as gender-signal\n  if (honorific.found) {\n    let hon = honorific.text('normal')\n    hon = hon.replace(/\\./g, '') //clean it up a bit\n    if (honorifics.hasOwnProperty(hon)) {\n      return honorifics[hon]\n    }\n    // her excelency\n    if (/^her /.test(hon)) {\n      return f\n    }\n    if (/^his /.test(hon)) {\n      return m\n    }\n  }\n  // offer used-pronouns as a signal\n  let after = person.after()\n  if (!after.has('#Person') && after.has('#Pronoun')) {\n    let pro = after.match('#Pronoun')\n    // manual use of gender-neutral\n    if (pro.has('(they|their)')) {\n      return null\n    }\n    let hasMasc = pro.has('(he|his)')\n    let hasFem = pro.has('(she|her|hers)')\n    if (hasMasc && !hasFem) {\n      return m\n    }\n    if (hasFem && !hasMasc) {\n      return f\n    }\n  }\n  return null\n}\nexport default predictGender\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,CAAC,GAAG,MAAM;AAChB,MAAMC,CAAC,GAAG,QAAQ;;AAElB;AACA,MAAMC,UAAU,GAAG;EACjBC,EAAE,EAAEH,CAAC;EACLI,GAAG,EAAEH,CAAC;EACNI,IAAI,EAAEJ,CAAC;EACPK,KAAK,EAAEL,CAAC;EAER;EACAM,IAAI,EAAEP,CAAC;EACPQ,KAAK,EAAEP,CAAC;EACRQ,IAAI,EAAET,CAAC;EACPU,OAAO,EAAET,CAAC;EACVU,KAAK,EAAEX,CAAC;EACRY,QAAQ,EAAEX,CAAC;EACXY,KAAK,EAAEb,CAAC;EACRc,QAAQ,EAAEb,CAAC;EACXc,MAAM,EAAEf,CAAC;EACTgB,QAAQ,EAAEf,CAAC;EACXgB,IAAI,EAAEjB,CAAC;EACPkB,IAAI,EAAEjB,CAAC;EACPkB,IAAI,EAAElB,CAAC;EAEPmB,SAAS,EAAEpB,CAAC;EAAE;;EAEdqB,WAAW,EAAErB,CAAC;EACdsB,aAAa,EAAErB,CAAC;EAChB,YAAY,EAAEA,CAAC;EAEf;EACAsB,EAAE,EAAE;AACN,CAAC;AAED,MAAMC,aAAa,GAAG,SAAAA,CAAUC,MAAM,EAAEC,MAAM,EAAE;EAC9C,IAAI;IAAEC,SAAS;IAAEC;EAAU,CAAC,GAAGH,MAAM;EACrC;EACA,IAAIE,SAAS,CAACE,GAAG,CAAC,aAAa,CAAC,EAAE;IAChC,OAAO5B,CAAC;EACV;EACA,IAAI0B,SAAS,CAACE,GAAG,CAAC,WAAW,CAAC,EAAE;IAC9B,OAAO7B,CAAC;EACV;EACA;EACA,IAAI4B,SAAS,CAACE,KAAK,EAAE;IACnB,IAAIC,GAAG,GAAGH,SAAS,CAACI,IAAI,CAAC,QAAQ,CAAC;IAClCD,GAAG,GAAGA,GAAG,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,EAAC;IAC7B,IAAI/B,UAAU,CAACgC,cAAc,CAACH,GAAG,CAAC,EAAE;MAClC,OAAO7B,UAAU,CAAC6B,GAAG,CAAC;IACxB;IACA;IACA,IAAI,OAAO,CAACI,IAAI,CAACJ,GAAG,CAAC,EAAE;MACrB,OAAO9B,CAAC;IACV;IACA,IAAI,OAAO,CAACkC,IAAI,CAACJ,GAAG,CAAC,EAAE;MACrB,OAAO/B,CAAC;IACV;EACF;EACA;EACA,IAAIoC,KAAK,GAAGV,MAAM,CAACU,KAAK,CAAC,CAAC;EAC1B,IAAI,CAACA,KAAK,CAACP,GAAG,CAAC,SAAS,CAAC,IAAIO,KAAK,CAACP,GAAG,CAAC,UAAU,CAAC,EAAE;IAClD,IAAIQ,GAAG,GAAGD,KAAK,CAACE,KAAK,CAAC,UAAU,CAAC;IACjC;IACA,IAAID,GAAG,CAACR,GAAG,CAAC,cAAc,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;IACA,IAAIU,OAAO,GAAGF,GAAG,CAACR,GAAG,CAAC,UAAU,CAAC;IACjC,IAAIW,MAAM,GAAGH,GAAG,CAACR,GAAG,CAAC,gBAAgB,CAAC;IACtC,IAAIU,OAAO,IAAI,CAACC,MAAM,EAAE;MACtB,OAAOxC,CAAC;IACV;IACA,IAAIwC,MAAM,IAAI,CAACD,OAAO,EAAE;MACtB,OAAOtC,CAAC;IACV;EACF;EACA,OAAO,IAAI;AACb,CAAC;AACD,eAAeuB,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}