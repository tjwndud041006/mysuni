{"ast":null,"code":"'use strict';\n\nconst types = require('pg-types');\nconst matchRegexp = /^([A-Za-z]+)(?: (\\d+))?(?: (\\d+))?/;\n\n// result object returned from query\n// in the 'end' event and also\n// passed as second argument to provided callback\nclass Result {\n  constructor(rowMode, types) {\n    this.command = null;\n    this.rowCount = null;\n    this.oid = null;\n    this.rows = [];\n    this.fields = [];\n    this._parsers = undefined;\n    this._types = types;\n    this.RowCtor = null;\n    this.rowAsArray = rowMode === 'array';\n    if (this.rowAsArray) {\n      this.parseRow = this._parseRowAsArray;\n    }\n    this._prebuiltEmptyResultObject = null;\n  }\n\n  // adds a command complete message\n  addCommandComplete(msg) {\n    let match;\n    if (msg.text) {\n      // pure javascript\n      match = matchRegexp.exec(msg.text);\n    } else {\n      // native bindings\n      match = matchRegexp.exec(msg.command);\n    }\n    if (match) {\n      this.command = match[1];\n      if (match[3]) {\n        // COMMAND OID ROWS\n        this.oid = parseInt(match[2], 10);\n        this.rowCount = parseInt(match[3], 10);\n      } else if (match[2]) {\n        // COMMAND ROWS\n        this.rowCount = parseInt(match[2], 10);\n      }\n    }\n  }\n  _parseRowAsArray(rowData) {\n    const row = new Array(rowData.length);\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i];\n      if (rawValue !== null) {\n        row[i] = this._parsers[i](rawValue);\n      } else {\n        row[i] = null;\n      }\n    }\n    return row;\n  }\n  parseRow(rowData) {\n    const row = {\n      ...this._prebuiltEmptyResultObject\n    };\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i];\n      const field = this.fields[i].name;\n      if (rawValue !== null) {\n        const v = this.fields[i].format === 'binary' ? Buffer.from(rawValue) : rawValue;\n        row[field] = this._parsers[i](v);\n      } else {\n        row[field] = null;\n      }\n    }\n    return row;\n  }\n  addRow(row) {\n    this.rows.push(row);\n  }\n  addFields(fieldDescriptions) {\n    // clears field definitions\n    // multiple query statements in 1 action can result in multiple sets\n    // of rowDescriptions...eg: 'select NOW(); select 1::int;'\n    // you need to reset the fields\n    this.fields = fieldDescriptions;\n    if (this.fields.length) {\n      this._parsers = new Array(fieldDescriptions.length);\n    }\n    const row = {};\n    for (let i = 0; i < fieldDescriptions.length; i++) {\n      const desc = fieldDescriptions[i];\n      row[desc.name] = null;\n      if (this._types) {\n        this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text');\n      } else {\n        this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text');\n      }\n    }\n    this._prebuiltEmptyResultObject = {\n      ...row\n    };\n  }\n}\nmodule.exports = Result;","map":{"version":3,"names":["types","require","matchRegexp","Result","constructor","rowMode","command","rowCount","oid","rows","fields","_parsers","undefined","_types","RowCtor","rowAsArray","parseRow","_parseRowAsArray","_prebuiltEmptyResultObject","addCommandComplete","msg","match","text","exec","parseInt","rowData","row","Array","length","i","len","rawValue","field","name","v","format","Buffer","from","addRow","push","addFields","fieldDescriptions","desc","getTypeParser","dataTypeID","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg/lib/result.js"],"sourcesContent":["'use strict'\n\nconst types = require('pg-types')\n\nconst matchRegexp = /^([A-Za-z]+)(?: (\\d+))?(?: (\\d+))?/\n\n// result object returned from query\n// in the 'end' event and also\n// passed as second argument to provided callback\nclass Result {\n  constructor(rowMode, types) {\n    this.command = null\n    this.rowCount = null\n    this.oid = null\n    this.rows = []\n    this.fields = []\n    this._parsers = undefined\n    this._types = types\n    this.RowCtor = null\n    this.rowAsArray = rowMode === 'array'\n    if (this.rowAsArray) {\n      this.parseRow = this._parseRowAsArray\n    }\n    this._prebuiltEmptyResultObject = null\n  }\n\n  // adds a command complete message\n  addCommandComplete(msg) {\n    let match\n    if (msg.text) {\n      // pure javascript\n      match = matchRegexp.exec(msg.text)\n    } else {\n      // native bindings\n      match = matchRegexp.exec(msg.command)\n    }\n    if (match) {\n      this.command = match[1]\n      if (match[3]) {\n        // COMMAND OID ROWS\n        this.oid = parseInt(match[2], 10)\n        this.rowCount = parseInt(match[3], 10)\n      } else if (match[2]) {\n        // COMMAND ROWS\n        this.rowCount = parseInt(match[2], 10)\n      }\n    }\n  }\n\n  _parseRowAsArray(rowData) {\n    const row = new Array(rowData.length)\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i]\n      if (rawValue !== null) {\n        row[i] = this._parsers[i](rawValue)\n      } else {\n        row[i] = null\n      }\n    }\n    return row\n  }\n\n  parseRow(rowData) {\n    const row = { ...this._prebuiltEmptyResultObject }\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i]\n      const field = this.fields[i].name\n      if (rawValue !== null) {\n        const v = this.fields[i].format === 'binary' ? Buffer.from(rawValue) : rawValue\n        row[field] = this._parsers[i](v)\n      } else {\n        row[field] = null\n      }\n    }\n    return row\n  }\n\n  addRow(row) {\n    this.rows.push(row)\n  }\n\n  addFields(fieldDescriptions) {\n    // clears field definitions\n    // multiple query statements in 1 action can result in multiple sets\n    // of rowDescriptions...eg: 'select NOW(); select 1::int;'\n    // you need to reset the fields\n    this.fields = fieldDescriptions\n    if (this.fields.length) {\n      this._parsers = new Array(fieldDescriptions.length)\n    }\n\n    const row = {}\n\n    for (let i = 0; i < fieldDescriptions.length; i++) {\n      const desc = fieldDescriptions[i]\n      row[desc.name] = null\n\n      if (this._types) {\n        this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text')\n      } else {\n        this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text')\n      }\n    }\n\n    this._prebuiltEmptyResultObject = { ...row }\n  }\n}\n\nmodule.exports = Result\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAU,CAAC;AAEjC,MAAMC,WAAW,GAAG,oCAAoC;;AAExD;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACXC,WAAWA,CAACC,OAAO,EAAEL,KAAK,EAAE;IAC1B,IAAI,CAACM,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,GAAG,GAAG,IAAI;IACf,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,QAAQ,GAAGC,SAAS;IACzB,IAAI,CAACC,MAAM,GAAGb,KAAK;IACnB,IAAI,CAACc,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,UAAU,GAAGV,OAAO,KAAK,OAAO;IACrC,IAAI,IAAI,CAACU,UAAU,EAAE;MACnB,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACC,gBAAgB;IACvC;IACA,IAAI,CAACC,0BAA0B,GAAG,IAAI;EACxC;;EAEA;EACAC,kBAAkBA,CAACC,GAAG,EAAE;IACtB,IAAIC,KAAK;IACT,IAAID,GAAG,CAACE,IAAI,EAAE;MACZ;MACAD,KAAK,GAAGnB,WAAW,CAACqB,IAAI,CAACH,GAAG,CAACE,IAAI,CAAC;IACpC,CAAC,MAAM;MACL;MACAD,KAAK,GAAGnB,WAAW,CAACqB,IAAI,CAACH,GAAG,CAACd,OAAO,CAAC;IACvC;IACA,IAAIe,KAAK,EAAE;MACT,IAAI,CAACf,OAAO,GAAGe,KAAK,CAAC,CAAC,CAAC;MACvB,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACZ;QACA,IAAI,CAACb,GAAG,GAAGgB,QAAQ,CAACH,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACjC,IAAI,CAACd,QAAQ,GAAGiB,QAAQ,CAACH,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACxC,CAAC,MAAM,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACnB;QACA,IAAI,CAACd,QAAQ,GAAGiB,QAAQ,CAACH,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACxC;IACF;EACF;EAEAJ,gBAAgBA,CAACQ,OAAO,EAAE;IACxB,MAAMC,GAAG,GAAG,IAAIC,KAAK,CAACF,OAAO,CAACG,MAAM,CAAC;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGL,OAAO,CAACG,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,MAAME,QAAQ,GAAGN,OAAO,CAACI,CAAC,CAAC;MAC3B,IAAIE,QAAQ,KAAK,IAAI,EAAE;QACrBL,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,CAAClB,QAAQ,CAACkB,CAAC,CAAC,CAACE,QAAQ,CAAC;MACrC,CAAC,MAAM;QACLL,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI;MACf;IACF;IACA,OAAOH,GAAG;EACZ;EAEAV,QAAQA,CAACS,OAAO,EAAE;IAChB,MAAMC,GAAG,GAAG;MAAE,GAAG,IAAI,CAACR;IAA2B,CAAC;IAClD,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGL,OAAO,CAACG,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,MAAME,QAAQ,GAAGN,OAAO,CAACI,CAAC,CAAC;MAC3B,MAAMG,KAAK,GAAG,IAAI,CAACtB,MAAM,CAACmB,CAAC,CAAC,CAACI,IAAI;MACjC,IAAIF,QAAQ,KAAK,IAAI,EAAE;QACrB,MAAMG,CAAC,GAAG,IAAI,CAACxB,MAAM,CAACmB,CAAC,CAAC,CAACM,MAAM,KAAK,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAACN,QAAQ,CAAC,GAAGA,QAAQ;QAC/EL,GAAG,CAACM,KAAK,CAAC,GAAG,IAAI,CAACrB,QAAQ,CAACkB,CAAC,CAAC,CAACK,CAAC,CAAC;MAClC,CAAC,MAAM;QACLR,GAAG,CAACM,KAAK,CAAC,GAAG,IAAI;MACnB;IACF;IACA,OAAON,GAAG;EACZ;EAEAY,MAAMA,CAACZ,GAAG,EAAE;IACV,IAAI,CAACjB,IAAI,CAAC8B,IAAI,CAACb,GAAG,CAAC;EACrB;EAEAc,SAASA,CAACC,iBAAiB,EAAE;IAC3B;IACA;IACA;IACA;IACA,IAAI,CAAC/B,MAAM,GAAG+B,iBAAiB;IAC/B,IAAI,IAAI,CAAC/B,MAAM,CAACkB,MAAM,EAAE;MACtB,IAAI,CAACjB,QAAQ,GAAG,IAAIgB,KAAK,CAACc,iBAAiB,CAACb,MAAM,CAAC;IACrD;IAEA,MAAMF,GAAG,GAAG,CAAC,CAAC;IAEd,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,iBAAiB,CAACb,MAAM,EAAEC,CAAC,EAAE,EAAE;MACjD,MAAMa,IAAI,GAAGD,iBAAiB,CAACZ,CAAC,CAAC;MACjCH,GAAG,CAACgB,IAAI,CAACT,IAAI,CAAC,GAAG,IAAI;MAErB,IAAI,IAAI,CAACpB,MAAM,EAAE;QACf,IAAI,CAACF,QAAQ,CAACkB,CAAC,CAAC,GAAG,IAAI,CAAChB,MAAM,CAAC8B,aAAa,CAACD,IAAI,CAACE,UAAU,EAAEF,IAAI,CAACP,MAAM,IAAI,MAAM,CAAC;MACtF,CAAC,MAAM;QACL,IAAI,CAACxB,QAAQ,CAACkB,CAAC,CAAC,GAAG7B,KAAK,CAAC2C,aAAa,CAACD,IAAI,CAACE,UAAU,EAAEF,IAAI,CAACP,MAAM,IAAI,MAAM,CAAC;MAChF;IACF;IAEA,IAAI,CAACjB,0BAA0B,GAAG;MAAE,GAAGQ;IAAI,CAAC;EAC9C;AACF;AAEAmB,MAAM,CAACC,OAAO,GAAG3C,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}