{"ast":null,"code":"import { noop, getTense, getSubject } from '../lib.js';\nconst haveHas = function (vb, parsed) {\n  let subj = getSubject(vb, parsed);\n  let m = subj.subject;\n  if (m.has('(i|we|you)')) {\n    return 'have';\n  }\n  // the dog has\n  if (subj.plural === false) {\n    return 'has';\n  }\n  // spencer has\n  if (m.has('he') || m.has('she') || m.has('#Person')) {\n    return 'has';\n  }\n  return 'have';\n};\n\n// walk-> has walked\nconst simple = (vb, parsed) => {\n  const {\n    conjugate,\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const {\n    root,\n    auxiliary\n  } = parsed;\n  // 'i may'\n  if (root.has('#Modal')) {\n    return vb;\n  }\n  let str = root.text({\n    keepPunct: false\n  });\n  str = toInfinitive(str, vb.model, getTense(root));\n  let all = conjugate(str, vb.model);\n  // 'driven' || 'drove'\n  str = all.Participle || all.PastTense;\n  if (str) {\n    vb = vb.replace(root, str);\n    // 'have/had/has eaten'\n    let have = haveHas(vb, parsed);\n    vb.prepend(have).match(have).tag('Auxiliary');\n    vb.remove(auxiliary);\n  }\n  return vb;\n};\nconst forms = {\n  // walk -> walked\n  'infinitive': simple,\n  // he walks -> he walked\n  'simple-present': simple,\n  // he walked\n  // 'simple-past': noop,\n  // he will walk -> he walked\n  'simple-future': (vb, parsed) => vb.replace('will', haveHas(vb, parsed)),\n  // he is walking\n  // 'present-progressive': noop,\n  // he was walking\n  // 'past-progressive': noop,\n  // he will be walking\n  // 'future-progressive': noop,\n\n  // has walked -> had walked (?)\n  'present-perfect': noop,\n  // had walked\n  'past-perfect': noop,\n  // will have walked -> had walked\n  'future-perfect': (vb, parsed) => vb.replace('will have', haveHas(vb, parsed)),\n  // has been walking -> had been\n  'present-perfect-progressive': noop,\n  // had been walking\n  'past-perfect-progressive': noop,\n  // will have been -> had\n  'future-perfect-progressive': noop\n\n  // got walked\n  // 'passive-past': noop,\n  // is being walked  -> 'was being walked'\n  // 'passive-present': noop,\n  // will be walked -> had been walked\n  // 'passive-future': noop,\n\n  // would be walked -> 'would have been walked'\n  // 'present-conditional': noop,\n  // would have been walked\n  // 'past-conditional': noop,\n\n  // is going to drink -> was going to drink\n  // 'auxiliary-future': noop,\n  // used to walk\n  // 'auxiliary-past': noop,\n  // we do walk -> we did walk\n  // 'auxiliary-present': noop,\n\n  // must walk -> 'must have walked'\n  // 'modal-infinitive': noop,\n  // must have walked\n  // 'modal-past': noop,\n  // wanted to walk\n  // 'want-infinitive': noop,\n  // started looking\n  // 'gerund-phrase': noop,\n};\nconst toPast = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed);\n    vb.fullSentence().compute(['tagger', 'chunks']);\n    return vb;\n  }\n  // do the simple form\n  vb = simple(vb, parsed, form);\n  vb.fullSentence().compute(['tagger', 'chunks']);\n  // do nothing, then\n  return vb;\n};\nexport default toPast;","map":{"version":3,"names":["noop","getTense","getSubject","haveHas","vb","parsed","subj","m","subject","has","plural","simple","conjugate","toInfinitive","methods","two","transform","verb","root","auxiliary","str","text","keepPunct","model","all","Participle","PastTense","replace","have","prepend","match","tag","remove","forms","simple-future","future-perfect","toPast","form","hasOwnProperty","fullSentence","compute"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toParticiple.js"],"sourcesContent":["import { noop, getTense, getSubject } from '../lib.js'\n\nconst haveHas = function (vb, parsed) {\n  let subj = getSubject(vb, parsed)\n  let m = subj.subject\n  if (m.has('(i|we|you)')) {\n    return 'have'\n  }\n  // the dog has\n  if (subj.plural === false) {\n    return 'has'\n  }\n  // spencer has\n  if (m.has('he') || m.has('she') || m.has('#Person')) {\n    return 'has'\n  }\n  return 'have'\n}\n\n// walk-> has walked\nconst simple = (vb, parsed) => {\n  const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n  const { root, auxiliary } = parsed\n  // 'i may'\n  if (root.has('#Modal')) {\n    return vb\n  }\n  let str = root.text({ keepPunct: false })\n  str = toInfinitive(str, vb.model, getTense(root))\n  let all = conjugate(str, vb.model)\n  // 'driven' || 'drove'\n  str = all.Participle || all.PastTense\n\n  if (str) {\n    vb = vb.replace(root, str)\n    // 'have/had/has eaten'\n    let have = haveHas(vb, parsed)\n    vb.prepend(have).match(have).tag('Auxiliary')\n    vb.remove(auxiliary)\n  }\n\n  return vb\n}\n\n\n\nconst forms = {\n  // walk -> walked\n  'infinitive': simple,\n  // he walks -> he walked\n  'simple-present': simple,\n  // he walked\n  // 'simple-past': noop,\n  // he will walk -> he walked\n  'simple-future': (vb, parsed) => vb.replace('will', haveHas(vb, parsed)),\n\n  // he is walking\n  // 'present-progressive': noop,\n  // he was walking\n  // 'past-progressive': noop,\n  // he will be walking\n  // 'future-progressive': noop,\n\n  // has walked -> had walked (?)\n  'present-perfect': noop,\n  // had walked\n  'past-perfect': noop,\n  // will have walked -> had walked\n  'future-perfect': (vb, parsed) => vb.replace('will have', haveHas(vb, parsed)),\n\n  // has been walking -> had been\n  'present-perfect-progressive': noop,\n  // had been walking\n  'past-perfect-progressive': noop,\n  // will have been -> had\n  'future-perfect-progressive': noop,\n\n  // got walked\n  // 'passive-past': noop,\n  // is being walked  -> 'was being walked'\n  // 'passive-present': noop,\n  // will be walked -> had been walked\n  // 'passive-future': noop,\n\n  // would be walked -> 'would have been walked'\n  // 'present-conditional': noop,\n  // would have been walked\n  // 'past-conditional': noop,\n\n  // is going to drink -> was going to drink\n  // 'auxiliary-future': noop,\n  // used to walk\n  // 'auxiliary-past': noop,\n  // we do walk -> we did walk\n  // 'auxiliary-present': noop,\n\n  // must walk -> 'must have walked'\n  // 'modal-infinitive': noop,\n  // must have walked\n  // 'modal-past': noop,\n  // wanted to walk\n  // 'want-infinitive': noop,\n  // started looking\n  // 'gerund-phrase': noop,\n}\n\nconst toPast = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed)\n    vb.fullSentence().compute(['tagger', 'chunks'])\n    return vb\n  }\n  // do the simple form\n  vb = simple(vb, parsed, form)\n  vb.fullSentence().compute(['tagger', 'chunks'])\n  // do nothing, then\n  return vb\n}\nexport default toPast\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}