{"ast":null,"code":"/*\n  Rule templates that provide metadata for generating transformation rules\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict';\n\nconst ruleTemplates = {\n  // Predicates as used in the English rules in data/English/tr_from_posjs.txt\n  'NEXT-TAG': {\n    // maps to the predicate function\n    function: nextTagIs,\n    // Minimum required space before or after current position to be a relevant predicate\n    window: [0, 1],\n    // The number of parameters the predicate takes\n    nrParameters: 1,\n    // Function that returns relevant values for parameter 1\n    parameter1Values: nextTagParameterValues\n  },\n  'NEXT-WORD-IS-CAP': {\n    function: nextWordIsCap,\n    window: [0, 1],\n    nrParameters: 0\n  },\n  'PREV-1-OR-2-OR-3-TAG': {\n    function: prev1Or2Or3Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  'PREV-1-OR-2-TAG': {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  'NEXT-WORD-IS-TAG': {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  'PREV-TAG': {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  /*\n  \"CURRENT-WORD-IS-TAG\": {\n   \"function\": current_word_is_tag,\n   \"window\": [0],\n   \"nrParameter\": 1,\n   \"parameter1Values\": currentTagParameterValues\n   },\n  */\n  'PREV-WORD-IS-CAP': {\n    function: prevWordIsCap,\n    window: [-1, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-CAP': {\n    function: currentWordIsCap,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-NUMBER': {\n    function: currentWordIsNumber,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-URL': {\n    function: currentWordIsURL,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-ENDS-WITH': {\n    function: currentWordEndsWith,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordEndsWithParameterValues\n  },\n  'PREV-WORD-IS': {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  // Predicates as used in the Dutch rules in data/Dutch/brill_CONTEXTRULES.jg\n  PREVTAG: {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  NEXT1OR2TAG: {\n    function: next1Or2TagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2TagIsParameterValues\n  },\n  NEXTTAG: {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  PREV1OR2TAG: {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  WDAND2TAGAFT: {\n    function: currentWordAnd2TagAfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  NEXT1OR2OR3TAG: {\n    function: next1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the right\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2Or3TagParameterValues\n  },\n  CURWD: {\n    function: currentWordIs,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordParameterValues\n  },\n  SURROUNDTAG: {\n    function: surroundedByTags,\n    window: [-1, 1],\n    nrParameters: 2,\n    parameter1Values: prevTagParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2OR3TAG: {\n    function: prev1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the left\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  WDNEXTTAG: {\n    function: currentWordAndNextTagAre,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2WD: {\n    function: prev1Or2WordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2WordParameterValues\n  },\n  NEXTWD: {\n    function: nextWordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextWordParameterValues\n  },\n  PREVWD: {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  NEXT2TAG: {\n    function: next2TagIs,\n    window: [0, 2],\n    nrParameters: 1,\n    parameter1Values: next2TagParameterValues\n  },\n  WDAND2TAGBFR: {\n    function: currentWordAnd2TagBeforeAre,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagBeforeParameterValues\n  },\n  WDAND2AFT: {\n    function: currentWordAnd2AfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  WDPREVTAG: {\n    function: currentWordAndPrevTagAre,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  RBIGRAM: {\n    function: rightBigramIs,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextWordParameterValues\n  },\n  LBIGRAM: {\n    function: leftBigramIs,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: prevWordParameterValues,\n    parameter2Values: currentWordParameterValues\n  },\n  NEXTBIGRAM: {\n    function: nextBigramIs,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: nextWordParameterValues,\n    parameter2Values: twoWordAfterParameterValues\n  },\n  PREVBIGRAM: {\n    function: prevBigramIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoWordBeforeParameterValues,\n    parameter2Values: prevWordParameterValues\n  },\n  PREV2TAG: {\n    function: prev2TagIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoTagBeforeParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  NEXT1OR2WD: {\n    function: next1Or2WordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2WordParameterValues\n  },\n  DEFAULT: {\n    function: defaultPredicate,\n    window: [0, 0],\n    nrParameters: 0\n  }\n};\n\n// ==================================\n// Predicates that start with words\n// ==================================\nfunction nextWordIsCap(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    const nextWord = sentence.taggedWords[i + 1].token;\n    return nextWord[0] === nextWord[0].toUpperCase();\n  }\n  return false;\n}\nfunction nextWordIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return sentence.taggedWords[i + 1].token === parameter;\n  }\n}\nfunction nextWordParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].token];\n  } else {\n    return [];\n  }\n}\nfunction prevWordIsCap(sentence, i, parameter) {\n  let prevWord = null;\n  if (i > 0) {\n    prevWord = sentence.taggedWords[i - 1].token;\n    return prevWord[0] === prevWord[0].toUpperCase();\n  }\n  return false;\n}\nfunction currentWordIsCap(sentence, i, parameter) {\n  const currentWord = sentence.taggedWords[i].token;\n  return currentWord[0] === currentWord[0].toUpperCase();\n}\nfunction currentWordParameterValues(sentence, i) {\n  return [sentence[i].token];\n}\nfunction currentWordIs(sentence, i, parameter) {\n  return sentence.taggedWords[i].token === parameter;\n}\nfunction isNumeric(num) {\n  return !isNaN(num);\n}\nfunction currentWordIsNumber(sentence, i, parameter) {\n  let isNumber = isNumeric(sentence.taggedWords[i].token);\n  // Attempt to parse it as a float\n  if (!isNumber) {\n    isNumber = parseFloat(sentence.taggedWords[i].token);\n  }\n  return parameter === 'YES' ? isNumber : !isNumber;\n}\n\n// Checks if the current word is a url\n// Adapted from the original Javascript Brill tagger\nfunction currentWordIsURL(sentence, i, parameter) {\n  let isURL = false;\n  if (sentence.taggedWords[i].token.indexOf('.') > -1) {\n    // url if there are two contiguous alpha characters\n    if (/[a-zA-Z]{2}/.test(sentence.taggedWords[i].token)) {\n      isURL = true;\n    }\n  }\n  return parameter === 'YES' ? isURL : !isURL;\n}\nfunction currentWordAnd2TagAfterAre(sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 2) {\n    if (sentence.taggedWords[i + 2][1] === parameter2) {\n      return sentence.taggedWords[i].token === parameter1;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\nfunction twoTagAfterParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag];\n  } else {\n    return [];\n  }\n}\nfunction currentWordAndNextTagAre(sentence, i, parameter1, parameter2) {\n  let nextTag = false;\n  // check current word\n  const currentWord = sentence.taggedWords[i].token === parameter1;\n  // check next tag\n  if (i < sentence.taggedWords.length - 1) {\n    nextTag = sentence.taggedWords[i + 1].tag === parameter2;\n  }\n  return currentWord && nextTag;\n}\nfunction currentWordAndPrevTagAre(sentence, i, parameter1, parameter2) {\n  let prevTag = false;\n  // check current word\n  const currentWord = sentence.taggedWords[i].token === parameter2;\n  // check prev tag\n  if (i > 0) {\n    prevTag = sentence.taggedWords[i - 1].tag === parameter1;\n  }\n  return currentWord && prevTag;\n}\nfunction currentWordAnd2TagBeforeAre(sentence, i, parameter1, parameter2) {\n  let twoTagsBefore = false;\n  // check current word\n  const currentWord = sentence.taggedWords[i].token === parameter2;\n  if (i > 1) {\n    // check two tags before\n    twoTagsBefore = sentence.taggedWords[i - 2].tag === parameter1;\n  }\n  return currentWord && twoTagsBefore;\n}\nfunction twoTagBeforeParameterValues(sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].tag];\n  } else {\n    return [];\n  }\n}\nfunction currentWordAnd2AfterAre(sentence, i, parameter1, parameter2) {\n  let twoWordsAfter = false;\n  // check current word\n  const currentWord = sentence.taggedWords[i].token === parameter1;\n  if (i < sentence.taggedWords.length - 2) {\n    twoWordsAfter = sentence.taggedWords[i + 2].token === parameter2;\n  }\n  return currentWord && twoWordsAfter;\n}\nfunction prevWordIs(sentence, i, parameter) {\n  if (i > 0) {\n    return sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase();\n  } else {\n    return false;\n  }\n}\n\n// Returns the right value for parameter 1 of prevWordIs\nfunction prevWordParameterValues(sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].token];\n  } else {\n    return [];\n  }\n}\nfunction prev1Or2WordIs(sentence, i, parameter) {\n  let prev1 = false;\n  let prev2 = false;\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase();\n  }\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].token.toLowerCase() === parameter.toLowerCase();\n  }\n  return prev1 || prev2;\n}\nfunction prev1Or2WordParameterValues(sentence, i) {\n  const values = [];\n  if (i > 0) {\n    values.push(sentence[i - 1].token);\n  }\n  if (i > 1) {\n    values.push(sentence[i - 2].token);\n  }\n  return values;\n}\n\n// Indicates whether or not this string ends with the specified string.\n// Adapted from the original Javascript Brill tagger\nfunction currentWordEndsWith(sentence, i, parameter) {\n  const word = sentence.taggedWords[i].token;\n  if (!parameter || parameter.length > word.length) {\n    return false;\n  }\n  return word.indexOf(parameter) === word.length - parameter.length;\n}\n\n// sentence is an array of token records\nfunction currentWordEndsWithParameterValues(sentence, i) {\n  const values = ['ing'];\n  return values;\n}\nfunction rightBigramIs(sentence, i, parameter1, parameter2) {\n  const word1 = sentence.taggedWords[i].token === parameter1;\n  let word2 = false;\n  if (i < sentence.taggedWords.length - 1) {\n    word2 = sentence.taggedWords[i + 1].token === parameter2;\n  }\n  return word1 && word2;\n}\nfunction leftBigramIs(sentence, i, parameter1, parameter2) {\n  let word1 = false;\n  const word2 = sentence.taggedWords[i].token === parameter2;\n  if (i > 0) {\n    word1 = sentence.taggedWords[i - 1].token === parameter1;\n  }\n  return word1 && word2;\n}\nfunction nextBigramIs(sentence, i, parameter1, parameter2) {\n  let word1 = false;\n  let word2 = false;\n  if (i < sentence.taggedWords.length - 1) {\n    word1 = sentence.taggedWords[i + 1].token === parameter1;\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    word2 = sentence.taggedWords[i + 2].token === parameter2;\n  }\n  return word1 && word2;\n}\nfunction twoWordAfterParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].token];\n  } else {\n    return [];\n  }\n}\nfunction prevBigramIs(sentence, i, parameter1, parameter2) {\n  let word1 = false;\n  let word2 = false;\n  if (i > 1) {\n    word1 = sentence.taggedWords[i - 2].token === parameter1;\n  }\n  if (i > 0) {\n    word2 = sentence.taggedWords[i - 1].token === parameter2;\n  }\n  return word1 && word2;\n}\nfunction twoWordBeforeParameterValues(sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].token];\n  } else {\n    return [];\n  }\n}\nfunction next1Or2WordIs(sentence, i, parameter1, parameter2) {\n  let next1 = false;\n  let next2 = false;\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = sentence.taggedWords[i + 1].token === parameter1;\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = sentence.taggedWords[i + 2].token === parameter2;\n  }\n  return next1 || next2;\n}\nfunction next1Or2WordParameterValues(sentence, i) {\n  const values = [];\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].token);\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].token);\n  }\n  return values;\n}\n\n// ==================================\n// Predicates about tags\n// ==================================\nfunction nextTagIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return sentence.taggedWords[i + 1].tag === parameter;\n  } else {\n    return false;\n  }\n}\nfunction nextTagParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].tag];\n  } else {\n    return [];\n  }\n}\nfunction next2TagIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 2) {\n    return sentence.taggedWords[i + 2].tag === parameter;\n  } else {\n    return false;\n  }\n}\nfunction next2TagParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag];\n  } else {\n    return [];\n  }\n}\nfunction next1Or2TagIs(sentence, i, parameter) {\n  let next1 = false;\n  let next2 = false;\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = sentence.taggedWords[i + 1].tag === parameter;\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = sentence.taggedWords[i + 2].tag === parameter;\n  }\n  return next1 || next2;\n}\nfunction next1Or2TagIsParameterValues(sentence, i) {\n  const values = [];\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].tag);\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].tag);\n  }\n  return values;\n}\nfunction next1Or2Or3Tag(sentence, i, parameter) {\n  let next3 = false;\n  if (i < sentence.taggedWords.length - 3) {\n    next3 = sentence.taggedWords[i + 3].tag === parameter;\n  }\n  return next1Or2TagIs(sentence, i, parameter) || next3;\n}\nfunction next1Or2Or3TagParameterValues(sentence, i) {\n  const values = next1Or2TagIsParameterValues(sentence, i);\n  if (i < sentence.taggedWords.length - 3) {\n    values.push(sentence.taggedWords[i + 3].tag);\n  }\n  return values;\n}\nfunction surroundedByTags(sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 1) {\n    // check next tag\n    if (sentence.taggedWords[i + 1].tag === parameter2) {\n      // check previous tag\n      if (i > 0) {\n        return sentence.taggedWords[i - 1].tag === parameter1;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\nfunction prev1Or2Or3Tag(sentence, i, parameter) {\n  let prev3 = null;\n  if (i > 2) {\n    prev3 = sentence.taggedWords[i - 3].tag;\n  }\n  return prev1Or2Tag(sentence, i, parameter) || prev3 === parameter;\n}\nfunction prev1Or2Or3TagParameterValues(sentence, i) {\n  const values = prev1Or2TagParameterValues(sentence, i);\n  if (i > 2) {\n    values.push(sentence.taggedWords[i - 3].tag);\n  }\n  return values;\n}\nfunction prev1Or2Tag(sentence, i, parameter) {\n  let prev1 = null;\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].tag;\n  }\n  let prev2 = null;\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag;\n  }\n  return prev1 === parameter || prev2 === parameter;\n}\nfunction prev1Or2TagParameterValues(sentence, i) {\n  const values = [];\n  if (i > 0) {\n    values.push(sentence.taggedWords[i - 1].tag);\n  }\n  if (i > 1) {\n    values.push(sentence.taggedWords[i - 2].tag);\n  }\n  return values;\n}\nfunction prevTagIs(sentence, i, parameter) {\n  let prev = false;\n  if (i > 0) {\n    prev = sentence.taggedWords[i - 1].tag === parameter;\n  }\n  return prev;\n}\nfunction prevTagParameterValues(sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].tag];\n  } else {\n    return [];\n  }\n}\n\n// Looks like a useless predicate because transformation already take the\n// current tag into account\n/*\nfunction currentWordIsTag (sentence, i, parameter) {\n  return (sentence.taggedWords[i].tag === parameter)\n}\n*/\n\nfunction prev2TagIs(sentence, i, parameter) {\n  let prev2 = false;\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag === parameter;\n  }\n  return prev2;\n}\nfunction defaultPredicate(sentence, i, parameter) {\n  return false;\n}\nmodule.exports = ruleTemplates;","map":{"version":3,"names":["ruleTemplates","function","nextTagIs","window","nrParameters","parameter1Values","nextTagParameterValues","nextWordIsCap","prev1Or2Or3Tag","prev1Or2Or3TagParameterValues","prev1Or2Tag","prev1Or2TagParameterValues","prevTagIs","prevTagParameterValues","prevWordIsCap","currentWordIsCap","currentWordIsNumber","currentWordIsURL","currentWordEndsWith","currentWordEndsWithParameterValues","prevWordIs","prevWordParameterValues","PREVTAG","NEXT1OR2TAG","next1Or2TagIs","next1Or2TagIsParameterValues","NEXTTAG","PREV1OR2TAG","WDAND2TAGAFT","currentWordAnd2TagAfterAre","currentWordParameterValues","parameter2Values","twoTagAfterParameterValues","NEXT1OR2OR3TAG","next1Or2Or3Tag","next1Or2Or3TagParameterValues","CURWD","currentWordIs","SURROUNDTAG","surroundedByTags","PREV1OR2OR3TAG","WDNEXTTAG","currentWordAndNextTagAre","PREV1OR2WD","prev1Or2WordIs","prev1Or2WordParameterValues","NEXTWD","nextWordIs","nextWordParameterValues","PREVWD","NEXT2TAG","next2TagIs","next2TagParameterValues","WDAND2TAGBFR","currentWordAnd2TagBeforeAre","twoTagBeforeParameterValues","WDAND2AFT","currentWordAnd2AfterAre","WDPREVTAG","currentWordAndPrevTagAre","RBIGRAM","rightBigramIs","LBIGRAM","leftBigramIs","NEXTBIGRAM","nextBigramIs","twoWordAfterParameterValues","PREVBIGRAM","prevBigramIs","twoWordBeforeParameterValues","PREV2TAG","prev2TagIs","NEXT1OR2WD","next1Or2WordIs","next1Or2WordParameterValues","DEFAULT","defaultPredicate","sentence","i","parameter","taggedWords","length","nextWord","token","toUpperCase","prevWord","currentWord","isNumeric","num","isNaN","isNumber","parseFloat","isURL","indexOf","test","parameter1","parameter2","tag","nextTag","prevTag","twoTagsBefore","twoWordsAfter","toLowerCase","prev1","prev2","values","push","word","word1","word2","next1","next2","next3","prev3","prev","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/brill_pos_tagger/lib/RuleTemplates.js"],"sourcesContent":["/*\n  Rule templates that provide metadata for generating transformation rules\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst ruleTemplates = {\n  // Predicates as used in the English rules in data/English/tr_from_posjs.txt\n  'NEXT-TAG': {\n    // maps to the predicate function\n    function: nextTagIs,\n    // Minimum required space before or after current position to be a relevant predicate\n    window: [0, 1],\n    // The number of parameters the predicate takes\n    nrParameters: 1,\n    // Function that returns relevant values for parameter 1\n    parameter1Values: nextTagParameterValues\n  },\n  'NEXT-WORD-IS-CAP': {\n    function: nextWordIsCap,\n    window: [0, 1],\n    nrParameters: 0\n  },\n  'PREV-1-OR-2-OR-3-TAG': {\n    function: prev1Or2Or3Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  'PREV-1-OR-2-TAG': {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  'NEXT-WORD-IS-TAG': {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  'PREV-TAG': {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  /*\n \"CURRENT-WORD-IS-TAG\": {\n   \"function\": current_word_is_tag,\n   \"window\": [0],\n   \"nrParameter\": 1,\n   \"parameter1Values\": currentTagParameterValues\n   },\n  */\n  'PREV-WORD-IS-CAP': {\n    function: prevWordIsCap,\n    window: [-1, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-CAP': {\n    function: currentWordIsCap,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-NUMBER': {\n    function: currentWordIsNumber,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-URL': {\n    function: currentWordIsURL,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-ENDS-WITH': {\n    function: currentWordEndsWith,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordEndsWithParameterValues\n  },\n  'PREV-WORD-IS': {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n\n  // Predicates as used in the Dutch rules in data/Dutch/brill_CONTEXTRULES.jg\n  PREVTAG: {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  NEXT1OR2TAG: {\n    function: next1Or2TagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2TagIsParameterValues\n  },\n  NEXTTAG: {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  PREV1OR2TAG: {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  WDAND2TAGAFT: {\n    function: currentWordAnd2TagAfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  NEXT1OR2OR3TAG: {\n    function: next1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the right\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2Or3TagParameterValues\n  },\n  CURWD: {\n    function: currentWordIs,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordParameterValues\n  },\n  SURROUNDTAG: {\n    function: surroundedByTags,\n    window: [-1, 1],\n    nrParameters: 2,\n    parameter1Values: prevTagParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2OR3TAG: {\n    function: prev1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the left\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  WDNEXTTAG: {\n    function: currentWordAndNextTagAre,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2WD: {\n    function: prev1Or2WordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2WordParameterValues\n  },\n  NEXTWD: {\n    function: nextWordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextWordParameterValues\n  },\n  PREVWD: {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  NEXT2TAG: {\n    function: next2TagIs,\n    window: [0, 2],\n    nrParameters: 1,\n    parameter1Values: next2TagParameterValues\n  },\n  WDAND2TAGBFR: {\n    function: currentWordAnd2TagBeforeAre,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagBeforeParameterValues\n  },\n  WDAND2AFT: {\n    function: currentWordAnd2AfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  WDPREVTAG: {\n    function: currentWordAndPrevTagAre,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  RBIGRAM: {\n    function: rightBigramIs,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextWordParameterValues\n  },\n  LBIGRAM: {\n    function: leftBigramIs,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: prevWordParameterValues,\n    parameter2Values: currentWordParameterValues\n  },\n  NEXTBIGRAM: {\n    function: nextBigramIs,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: nextWordParameterValues,\n    parameter2Values: twoWordAfterParameterValues\n  },\n  PREVBIGRAM: {\n    function: prevBigramIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoWordBeforeParameterValues,\n    parameter2Values: prevWordParameterValues\n  },\n  PREV2TAG: {\n    function: prev2TagIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoTagBeforeParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  NEXT1OR2WD: {\n    function: next1Or2WordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2WordParameterValues\n  },\n  DEFAULT: {\n    function: defaultPredicate,\n    window: [0, 0],\n    nrParameters: 0\n  }\n}\n\n// ==================================\n// Predicates that start with words\n// ==================================\nfunction nextWordIsCap (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    const nextWord = sentence.taggedWords[i + 1].token\n    return (nextWord[0] === nextWord[0].toUpperCase())\n  }\n  return (false)\n}\n\nfunction nextWordIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return (sentence.taggedWords[i + 1].token === parameter)\n  }\n}\n\nfunction nextWordParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].token]\n  } else {\n    return []\n  }\n}\n\nfunction prevWordIsCap (sentence, i, parameter) {\n  let prevWord = null\n  if (i > 0) {\n    prevWord = sentence.taggedWords[i - 1].token\n    return (prevWord[0] === prevWord[0].toUpperCase())\n  }\n  return (false)\n}\n\nfunction currentWordIsCap (sentence, i, parameter) {\n  const currentWord = sentence.taggedWords[i].token\n  return (currentWord[0] === currentWord[0].toUpperCase())\n}\n\nfunction currentWordParameterValues (sentence, i) {\n  return [sentence[i].token]\n}\n\nfunction currentWordIs (sentence, i, parameter) {\n  return (sentence.taggedWords[i].token === parameter)\n}\n\nfunction isNumeric (num) {\n  return (!isNaN(num))\n}\n\nfunction currentWordIsNumber (sentence, i, parameter) {\n  let isNumber = isNumeric(sentence.taggedWords[i].token)\n  // Attempt to parse it as a float\n  if (!isNumber) {\n    isNumber = parseFloat(sentence.taggedWords[i].token)\n  }\n  return ((parameter === 'YES') ? isNumber : !isNumber)\n}\n\n// Checks if the current word is a url\n// Adapted from the original Javascript Brill tagger\nfunction currentWordIsURL (sentence, i, parameter) {\n  let isURL = false\n  if (sentence.taggedWords[i].token.indexOf('.') > -1) {\n    // url if there are two contiguous alpha characters\n    if (/[a-zA-Z]{2}/.test(sentence.taggedWords[i].token)) {\n      isURL = true\n    }\n  }\n  return ((parameter === 'YES') ? isURL : !isURL)\n}\n\nfunction currentWordAnd2TagAfterAre (sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 2) {\n    if (sentence.taggedWords[i + 2][1] === parameter2) {\n      return (sentence.taggedWords[i].token === parameter1)\n    } else {\n      return (false)\n    }\n  } else {\n    return (false)\n  }\n}\n\nfunction twoTagAfterParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction currentWordAndNextTagAre (sentence, i, parameter1, parameter2) {\n  let nextTag = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter1)\n  // check next tag\n  if (i < sentence.taggedWords.length - 1) {\n    nextTag = (sentence.taggedWords[i + 1].tag === parameter2)\n  }\n  return (currentWord && nextTag)\n}\n\nfunction currentWordAndPrevTagAre (sentence, i, parameter1, parameter2) {\n  let prevTag = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter2)\n  // check prev tag\n  if (i > 0) {\n    prevTag = (sentence.taggedWords[i - 1].tag === parameter1)\n  }\n  return (currentWord && prevTag)\n}\n\nfunction currentWordAnd2TagBeforeAre (sentence, i, parameter1, parameter2) {\n  let twoTagsBefore = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter2)\n  if (i > 1) {\n    // check two tags before\n    twoTagsBefore = (sentence.taggedWords[i - 2].tag === parameter1)\n  }\n  return (currentWord && twoTagsBefore)\n}\n\nfunction twoTagBeforeParameterValues (sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction currentWordAnd2AfterAre (sentence, i, parameter1, parameter2) {\n  let twoWordsAfter = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter1)\n  if (i < sentence.taggedWords.length - 2) {\n    twoWordsAfter = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (currentWord && twoWordsAfter)\n}\n\nfunction prevWordIs (sentence, i, parameter) {\n  if (i > 0) {\n    return (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())\n  } else {\n    return (false)\n  }\n}\n\n// Returns the right value for parameter 1 of prevWordIs\nfunction prevWordParameterValues (sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].token]\n  } else {\n    return []\n  }\n}\n\nfunction prev1Or2WordIs (sentence, i, parameter) {\n  let prev1 = false\n  let prev2 = false\n  if (i > 0) {\n    prev1 = (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())\n  }\n  if (i > 1) {\n    prev2 = (sentence.taggedWords[i - 2].token.toLowerCase() === parameter.toLowerCase())\n  }\n  return (prev1 || prev2)\n}\n\nfunction prev1Or2WordParameterValues (sentence, i) {\n  const values = []\n  if (i > 0) {\n    values.push(sentence[i - 1].token)\n  }\n  if (i > 1) {\n    values.push(sentence[i - 2].token)\n  }\n  return values\n}\n\n// Indicates whether or not this string ends with the specified string.\n// Adapted from the original Javascript Brill tagger\nfunction currentWordEndsWith (sentence, i, parameter) {\n  const word = sentence.taggedWords[i].token\n  if (!parameter || (parameter.length > word.length)) {\n    return false\n  }\n  return (word.indexOf(parameter) === (word.length - parameter.length))\n}\n\n// sentence is an array of token records\nfunction currentWordEndsWithParameterValues (sentence, i) {\n  const values = ['ing']\n\n  return values\n}\n\nfunction rightBigramIs (sentence, i, parameter1, parameter2) {\n  const word1 = (sentence.taggedWords[i].token === parameter1)\n  let word2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    word2 = (sentence.taggedWords[i + 1].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction leftBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  const word2 = (sentence.taggedWords[i].token === parameter2)\n  if (i > 0) {\n    word1 = (sentence.taggedWords[i - 1].token === parameter1)\n  }\n  return (word1 && word2)\n}\n\nfunction nextBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  let word2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    word1 = (sentence.taggedWords[i + 1].token === parameter1)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    word2 = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction twoWordAfterParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].token]\n  } else {\n    return []\n  }\n}\n\nfunction prevBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  let word2 = false\n  if (i > 1) {\n    word1 = (sentence.taggedWords[i - 2].token === parameter1)\n  }\n  if (i > 0) {\n    word2 = (sentence.taggedWords[i - 1].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction twoWordBeforeParameterValues (sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].token]\n  } else {\n    return []\n  }\n}\n\nfunction next1Or2WordIs (sentence, i, parameter1, parameter2) {\n  let next1 = false\n  let next2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = (sentence.taggedWords[i + 1].token === parameter1)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (next1 || next2)\n}\n\nfunction next1Or2WordParameterValues (sentence, i) {\n  const values = []\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].token)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].token)\n  }\n  return values\n}\n\n// ==================================\n// Predicates about tags\n// ==================================\nfunction nextTagIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return (sentence.taggedWords[i + 1].tag === parameter)\n  } else {\n    return (false)\n  }\n}\n\nfunction nextTagParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].tag]\n  } else {\n    return []\n  }\n}\n\nfunction next2TagIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 2) {\n    return (sentence.taggedWords[i + 2].tag === parameter)\n  } else {\n    return (false)\n  }\n}\n\nfunction next2TagParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction next1Or2TagIs (sentence, i, parameter) {\n  let next1 = false\n  let next2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = (sentence.taggedWords[i + 1].tag === parameter)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = (sentence.taggedWords[i + 2].tag === parameter)\n  }\n  return (next1 || next2)\n}\n\nfunction next1Or2TagIsParameterValues (sentence, i) {\n  const values = []\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].tag)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].tag)\n  }\n  return values\n}\n\nfunction next1Or2Or3Tag (sentence, i, parameter) {\n  let next3 = false\n  if (i < sentence.taggedWords.length - 3) {\n    next3 = (sentence.taggedWords[i + 3].tag === parameter)\n  }\n  return (next1Or2TagIs(sentence, i, parameter) || next3)\n}\n\nfunction next1Or2Or3TagParameterValues (sentence, i) {\n  const values = next1Or2TagIsParameterValues(sentence, i)\n  if (i < sentence.taggedWords.length - 3) {\n    values.push(sentence.taggedWords[i + 3].tag)\n  }\n  return values\n}\n\nfunction surroundedByTags (sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 1) {\n    // check next tag\n    if (sentence.taggedWords[i + 1].tag === parameter2) {\n      // check previous tag\n      if (i > 0) {\n        return (sentence.taggedWords[i - 1].tag === parameter1)\n      } else {\n        return (false)\n      }\n    } else {\n      return (false)\n    }\n  } else {\n    return (false)\n  }\n}\n\nfunction prev1Or2Or3Tag (sentence, i, parameter) {\n  let prev3 = null\n  if (i > 2) {\n    prev3 = sentence.taggedWords[i - 3].tag\n  }\n  return (prev1Or2Tag(sentence, i, parameter) || (prev3 === parameter))\n}\n\nfunction prev1Or2Or3TagParameterValues (sentence, i) {\n  const values = prev1Or2TagParameterValues(sentence, i)\n  if (i > 2) {\n    values.push(sentence.taggedWords[i - 3].tag)\n  }\n  return values\n}\n\nfunction prev1Or2Tag (sentence, i, parameter) {\n  let prev1 = null\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].tag\n  }\n  let prev2 = null\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag\n  }\n  return ((prev1 === parameter) || (prev2 === parameter))\n}\n\nfunction prev1Or2TagParameterValues (sentence, i) {\n  const values = []\n  if (i > 0) {\n    values.push(sentence.taggedWords[i - 1].tag)\n  }\n  if (i > 1) {\n    values.push(sentence.taggedWords[i - 2].tag)\n  }\n  return values\n}\n\nfunction prevTagIs (sentence, i, parameter) {\n  let prev = false\n  if (i > 0) {\n    prev = (sentence.taggedWords[i - 1].tag === parameter)\n  }\n  return (prev)\n}\n\nfunction prevTagParameterValues (sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].tag]\n  } else {\n    return []\n  }\n}\n\n// Looks like a useless predicate because transformation already take the\n// current tag into account\n/*\nfunction currentWordIsTag (sentence, i, parameter) {\n  return (sentence.taggedWords[i].tag === parameter)\n}\n*/\n\nfunction prev2TagIs (sentence, i, parameter) {\n  let prev2 = false\n  if (i > 1) {\n    prev2 = (sentence.taggedWords[i - 2].tag === parameter)\n  }\n  return (prev2)\n}\n\nfunction defaultPredicate (sentence, i, parameter) {\n  return (false)\n}\n\nmodule.exports = ruleTemplates\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}