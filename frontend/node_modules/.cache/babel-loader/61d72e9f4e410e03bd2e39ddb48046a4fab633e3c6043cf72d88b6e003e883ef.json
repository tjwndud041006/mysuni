{"ast":null,"code":"import splice from './_splice.js';\nimport apostropheS from './apostrophe-s.js';\nimport apostropheD from './apostrophe-d.js';\nimport apostropheT from './apostrophe-t.js';\nimport isPossessive from './isPossessive.js';\nconst byApostrophe = /'/;\n\n// poor-mans reindexing of this sentence only\nconst reIndex = function (terms) {\n  terms.forEach((t, i) => {\n    if (t.index) {\n      t.index[1] = i;\n    }\n  });\n};\n\n// run tagger on our new implicit terms\nconst reTag = function (terms, view, start, len) {\n  let tmp = view.update();\n  tmp.document = [terms];\n  // offer to re-tag neighbours, too\n  let end = start + len;\n  if (start > 0) {\n    start -= 1;\n  }\n  if (terms[end]) {\n    end += 1;\n  }\n  tmp.ptrs = [[0, start, end]];\n  tmp.compute(['freeze', 'lexicon', 'preTagger', 'unfreeze']);\n  // don't for a reindex of the whole document\n  reIndex(terms);\n};\nconst byEnd = {\n  // how'd\n  d: (terms, i) => apostropheD(terms, i),\n  // we ain't\n  t: (terms, i) => apostropheT(terms, i),\n  // bob's\n  s: (terms, i, world) => {\n    // [bob's house] vs [bob's cool]\n    if (isPossessive(terms, i)) {\n      return world.methods.one.setTag([terms[i]], 'Possessive', world, null, '2-contraction');\n    }\n    return apostropheS(terms, i);\n  }\n};\nconst toDocs = function (words, view) {\n  let doc = view.fromText(words.join(' '));\n  doc.compute('id');\n  return doc.docs[0];\n};\n\n//really easy ones\nconst contractionTwo = view => {\n  let {\n    world,\n    document\n  } = view;\n  // each sentence\n  document.forEach((terms, n) => {\n    // loop through terms backwards\n    for (let i = terms.length - 1; i >= 0; i -= 1) {\n      // is it already a contraction\n      if (terms[i].implicit) {\n        continue;\n      }\n      let after = null;\n      if (byApostrophe.test(terms[i].normal) === true) {\n        after = terms[i].normal.split(byApostrophe)[1];\n      }\n      let words = null;\n      // any known-ones, like 'dunno'?\n      if (byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world);\n      }\n      // actually insert the new terms\n      if (words) {\n        words = toDocs(words, view);\n        splice(document, [n, i], words);\n        reTag(document[n], view, i, words.length);\n        continue;\n      }\n    }\n  });\n};\nexport default {\n  contractionTwo\n};","map":{"version":3,"names":["splice","apostropheS","apostropheD","apostropheT","isPossessive","byApostrophe","reIndex","terms","forEach","t","i","index","reTag","view","start","len","tmp","update","document","end","ptrs","compute","byEnd","d","s","world","methods","one","setTag","toDocs","words","doc","fromText","join","docs","contractionTwo","n","length","implicit","after","test","normal","split","hasOwnProperty"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/contraction-two/compute/index.js"],"sourcesContent":["import splice from './_splice.js'\nimport apostropheS from './apostrophe-s.js'\nimport apostropheD from './apostrophe-d.js'\nimport apostropheT from './apostrophe-t.js'\nimport isPossessive from './isPossessive.js'\n\nconst byApostrophe = /'/\n\n// poor-mans reindexing of this sentence only\nconst reIndex = function (terms) {\n  terms.forEach((t, i) => {\n    if (t.index) {\n      t.index[1] = i\n    }\n  })\n}\n\n// run tagger on our new implicit terms\nconst reTag = function (terms, view, start, len) {\n  let tmp = view.update()\n  tmp.document = [terms]\n  // offer to re-tag neighbours, too\n  let end = start + len\n  if (start > 0) {\n    start -= 1\n  }\n  if (terms[end]) {\n    end += 1\n  }\n  tmp.ptrs = [[0, start, end]]\n  tmp.compute(['freeze', 'lexicon', 'preTagger', 'unfreeze'])\n  // don't for a reindex of the whole document\n  reIndex(terms)\n}\n\nconst byEnd = {\n  // how'd\n  d: (terms, i) => apostropheD(terms, i),\n  // we ain't\n  t: (terms, i) => apostropheT(terms, i),\n  // bob's\n  s: (terms, i, world) => {\n    // [bob's house] vs [bob's cool]\n    if (isPossessive(terms, i)) {\n      return world.methods.one.setTag([terms[i]], 'Possessive', world, null, '2-contraction')\n    }\n    return apostropheS(terms, i)\n  },\n}\n\nconst toDocs = function (words, view) {\n  let doc = view.fromText(words.join(' '))\n  doc.compute('id')\n  return doc.docs[0]\n}\n\n//really easy ones\nconst contractionTwo = view => {\n  let { world, document } = view\n  // each sentence\n  document.forEach((terms, n) => {\n    // loop through terms backwards\n    for (let i = terms.length - 1; i >= 0; i -= 1) {\n      // is it already a contraction\n      if (terms[i].implicit) {\n        continue\n      }\n      let after = null\n      if (byApostrophe.test(terms[i].normal) === true) {\n        after = terms[i].normal.split(byApostrophe)[1]\n      }\n      let words = null\n      // any known-ones, like 'dunno'?\n      if (byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world)\n      }\n      // actually insert the new terms\n      if (words) {\n        words = toDocs(words, view)\n        splice(document, [n, i], words)\n        reTag(document[n], view, i, words.length)\n        continue\n      }\n    }\n  })\n}\nexport default { contractionTwo }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}