{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst {\n  parse,\n  serialize\n} = require('pg-protocol');\nconst {\n  getStream,\n  getSecureStream\n} = require('./stream');\nconst flushBuffer = serialize.flush();\nconst syncBuffer = serialize.sync();\nconst endBuffer = serialize.end();\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.stream = config.stream || getStream(config.ssl);\n    if (typeof this.stream === 'function') {\n      this.stream = this.stream(config);\n    }\n    this._keepAlive = config.keepAlive;\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    this.lastBuffer = false;\n    this.parsedStatements = {};\n    this.ssl = config.ssl || false;\n    this._ending = false;\n    this._emitMessage = false;\n    const self = this;\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n  }\n  connect(port, host) {\n    const self = this;\n    this._connecting = true;\n    this.stream.setNoDelay(true);\n    this.stream.connect(port, host);\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n      }\n      self.emit('connect');\n    });\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return;\n      }\n      self.emit('error', error);\n    };\n    this.stream.on('error', reportStreamError);\n    this.stream.on('close', function () {\n      self.emit('end');\n    });\n    if (!this.ssl) {\n      return this.attachListeners(this.stream);\n    }\n    this.stream.once('data', function (buffer) {\n      const responseCode = buffer.toString('utf8');\n      switch (responseCode) {\n        case 'S':\n          // Server supports SSL connections, continue with a secure connection\n          break;\n        case 'N':\n          // Server does not support SSL connections\n          self.stream.end();\n          return self.emit('error', new Error('The server does not support SSL connections'));\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end();\n          return self.emit('error', new Error('There was an error establishing an SSL connection'));\n      }\n      const options = {\n        socket: self.stream\n      };\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl);\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key;\n        }\n      }\n      const net = require('net');\n      if (net.isIP && net.isIP(host) === 0) {\n        options.servername = host;\n      }\n      try {\n        self.stream = getSecureStream(options);\n      } catch (err) {\n        return self.emit('error', err);\n      }\n      self.attachListeners(self.stream);\n      self.stream.on('error', reportStreamError);\n      self.emit('sslconnect');\n    });\n  }\n  attachListeners(stream) {\n    parse(stream, msg => {\n      const eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n      if (this._emitMessage) {\n        this.emit('message', msg);\n      }\n      this.emit(eventName, msg);\n    });\n  }\n  requestSsl() {\n    this.stream.write(serialize.requestSsl());\n  }\n  startup(config) {\n    this.stream.write(serialize.startup(config));\n  }\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey));\n  }\n  password(password) {\n    this._send(serialize.password(password));\n  }\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n  }\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n  }\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false;\n    }\n    return this.stream.write(buffer);\n  }\n  query(text) {\n    this._send(serialize.query(text));\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query));\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config));\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config));\n  }\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer);\n    }\n  }\n  sync() {\n    this._ending = true;\n    this._send(syncBuffer);\n  }\n  ref() {\n    this.stream.ref();\n  }\n  unref() {\n    this.stream.unref();\n  }\n  end() {\n    // 0x58 = 'X'\n    this._ending = true;\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end();\n      return;\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end();\n    });\n  }\n  close(msg) {\n    this._send(serialize.close(msg));\n  }\n  describe(msg) {\n    this._send(serialize.describe(msg));\n  }\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk));\n  }\n  endCopyFrom() {\n    this._send(serialize.copyDone());\n  }\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg));\n  }\n}\nmodule.exports = Connection;","map":{"version":3,"names":["EventEmitter","require","parse","serialize","getStream","getSecureStream","flushBuffer","flush","syncBuffer","sync","endBuffer","end","Connection","constructor","config","stream","ssl","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","_ending","_emitMessage","self","on","eventName","connect","port","host","_connecting","setNoDelay","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","Error","options","socket","Object","assign","key","net","isIP","servername","err","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","ref","unref","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg/lib/connection.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\n\nconst { parse, serialize } = require('pg-protocol')\nconst { getStream, getSecureStream } = require('./stream')\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n\n    this.stream = config.stream || getStream(config.ssl)\n    if (typeof this.stream === 'function') {\n      this.stream = this.stream(config)\n    }\n\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    const self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    const self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      const responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      const net = require('net')\n      if (net.isIP && net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = getSecureStream(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    parse(stream, (msg) => {\n      const eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(syncBuffer)\n  }\n\n  ref() {\n    this.stream.ref()\n  }\n\n  unref() {\n    this.stream.unref()\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}