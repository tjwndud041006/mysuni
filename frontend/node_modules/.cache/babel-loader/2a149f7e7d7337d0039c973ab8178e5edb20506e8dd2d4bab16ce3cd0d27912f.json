{"ast":null,"code":"/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n'use strict';\n\nconst TransformationRule = require('./TransformationRule');\nconst RuleSet = require('./RuleSet');\nconst Sentence = require('./Sentence');\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nconst minScore = 0;\n// After training rules with a score below scoreThreshold are pruned\n\nclass BrillPOSTrainer {\n  constructor(ruleScoreThreshold) {\n    if (ruleScoreThreshold) {\n      this.ruleScoreThreshold = ruleScoreThreshold;\n    } else {\n      this.ruleScoreThreshold = 1;\n    }\n  }\n\n  // Return the highest scoring rule from the rule set\n  selectHighRule() {\n    let highestRule = null;\n\n    // Walk through the map and find the rule with highest score\n    this.positiveRules.getRules().forEach(function (rule) {\n      if (highestRule === null) {\n        if (!rule.hasBeenSelectedAsHighRuleBefore) {\n          highestRule = rule;\n        }\n      } else {\n        if (rule.score() > highestRule.score() && !rule.hasBeenSelectedAsHighRuleBefore) {\n          highestRule = rule;\n        }\n      }\n    });\n    if (highestRule !== null) {\n      highestRule.hasBeenSelectedAsHighRuleBefore = true;\n    }\n    // Return the rule with the highest score\n    return highestRule;\n  }\n  mapRuleToSite(rule, i, j) {\n    if (!this.mapRuleToSites[rule.key()]) {\n      this.mapRuleToSites[rule.key()] = {};\n    }\n    if (!this.mapRuleToSites[rule.key()][i]) {\n      this.mapRuleToSites[rule.key()][i] = {};\n    }\n    this.mapRuleToSites[rule.key()][i][j] = true;\n  }\n  mapSiteToRule(i, j, rule) {\n    if (!this.mapSiteToRules[i]) {\n      this.mapSiteToRules[i] = {};\n    }\n    if (!this.mapSiteToRules[i][j]) {\n      this.mapSiteToRules[i][j] = {};\n    }\n    this.mapSiteToRules[i][j][rule.key()] = rule;\n  }\n  associateSiteWithRule(i, j, rule) {\n    this.mapRuleToSite(rule, i, j);\n    this.mapSiteToRule(i, j, rule);\n  }\n  siteIsAssociatedWithRule(i, j, rule) {\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        if (this.mapSiteToRules[i][j][rule.key()]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // Returns an array of all sites associated with rule\n  getSites(rule) {\n    const that = this;\n    const result = [];\n    Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n      Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n        // Unary plus the convert hash keys i and j to integer\n        result.push([+i, +j]);\n      });\n    });\n    // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n    return result;\n  }\n\n  // Returns an array of all rules associated with the site\n  getRules(i, j) {\n    let result = [];\n    const that = this;\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n          return that.mapSiteToRules[i][j][key];\n        });\n      }\n    }\n    return result;\n  }\n  disconnectSiteFromRule(i, j, rule) {\n    // mapRuleToSites\n    if (this.mapRuleToSites[rule.key()]) {\n      if (this.mapRuleToSites[rule.key()][i]) {\n        if (this.mapRuleToSites[rule.key()][i][j]) {\n          delete this.mapRuleToSites[rule.key()][i][j];\n        }\n      }\n    }\n\n    // mapSiteToRules\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        if (this.mapSiteToRules[i][j][rule.key()]) {\n          delete this.mapSiteToRules[i][j][rule.key()];\n        }\n      }\n    }\n  }\n\n  // Adjusts the score of the rule at position i, j of the corpus\n  scoreRule(rule, i, j) {\n    // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n    const token = this.corpus.sentences[i].taggedWords[j];\n    const rightTag = token.tag;\n    const oldTag = token.testTag;\n    const newTag = token.newTag;\n    if (rightTag !== oldTag) {\n      // Old tag is wrong\n      if (newTag === rightTag) {\n        // New tag is right\n        rule.positive++;\n        // If the score changes, it may be selected again as highest scoring rule\n        rule.hasBeenSelectedAsHighRuleBefore = false;\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n      } else {\n        // New tag is wrong as well --> neutral\n        rule.neutral++;\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n      }\n    } else {\n      // Old tag is right\n      if (newTag === rightTag) {\n        // New tag is right --> neutral\n        rule.neutral++;\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n      } else {\n        // New tag is false\n        rule.negative++;\n        // If the score changes, it may be selected again as highest scoring rule\n        rule.hasBeenSelectedAsHighRuleBefore = false;\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n      }\n    }\n    // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n  }\n\n  // Generate positive rules for this given site using templates\n  generatePositiveRules(i, j) {\n    const sentence = this.corpus.sentences[i];\n    const token = sentence.taggedWords[j];\n    // A positive rule should trigger on the currently assigned testTag\n    const oldTag = token.testTag;\n    // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n    // It should assign the right tag as given by the corpus\n    const newTag = token.tag;\n    // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n    const newRules = new RuleSet();\n    // Exit if testTag already is the right tag --> will not result in positive rules\n    if (oldTag === newTag) {\n      return newRules;\n    }\n    this.templates.forEach(function (template) {\n      if (template.windowFitsSite(sentence, j)) {\n        if (template.meta.nrParameters === 1) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value) {\n            newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value));\n          });\n        } else {\n          if (template.meta.nrParameters === 2) {\n            template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n              template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n                newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2));\n              });\n            });\n          } else {\n            // 0 paramaters\n            newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName));\n          }\n        }\n      }\n    });\n    return newRules;\n  }\n\n  // Finds all rules that are applicable at some site\n  scanForPositiveRules() {\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n    const that = this;\n    this.corpus.sentences.forEach(function (sentence, i) {\n      sentence.taggedWords.forEach(function (token, j) {\n        // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n        const newRules = that.generatePositiveRules(i, j);\n        newRules.getRules().forEach(function (rule) {\n          that.positiveRules.addRule(rule);\n          // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n        });\n      });\n    });\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n  }\n\n  // Find all sites where the rules can be applied, register these sites and\n  // update the scores\n  scanForSites() {\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n    const that = this;\n\n    // Scan the corpus\n    this.corpus.sentences.forEach(function (sentence, i) {\n      if (i % 100 === 0) {\n        // logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n      }\n      const taggedSentence = new Sentence();\n      sentence.taggedWords.forEach(function (wordObject) {\n        taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag);\n      });\n      sentence.taggedWords.forEach(function (token, j) {\n        that.positiveRules.getRules().forEach(function (rule) {\n          if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n            that.associateSiteWithRule(i, j, rule);\n            that.scoreRule(rule, i, j);\n            // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n          }\n        });\n      });\n    });\n\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n  }\n\n  // Returns a list of sites that may have been touched by a changing tag\n  neighbourhood(i, j) {\n    const sentenceLength = this.corpus.sentences[i].length;\n    const list = [];\n    if (this.index > 2) {\n      list.push([i, j - 3]);\n    }\n    if (this.index > 1) {\n      list.push([i, j - 2]);\n    }\n    if (this.index > 0) {\n      list.push([i, j - 1]);\n    }\n    if (this.index < sentenceLength - 1) {\n      list.push([i, j + 1]);\n    }\n    if (this.index < sentenceLength - 2) {\n      list.push([i, j + 2]);\n    }\n    if (this.index > sentenceLength - 3) {\n      list.push([i, j + 3]);\n    }\n    return list;\n  }\n\n  // corpus: an array of token arrays\n  // templates: an array of rule templates\n  // lexicon: lexicon that provides method tagWord(word)\n  train(corpus, templates, lexicon) {\n    this.corpus = corpus;\n    this.templates = templates;\n    this.positiveRules = new RuleSet();\n    this.mapRuleToSites = {};\n    this.mapSiteToRules = {};\n\n    // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n    this.corpus.tag(lexicon);\n    this.scanForPositiveRules();\n    // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n    this.scanForSites();\n    let highRule = this.selectHighRule();\n    let iterationNumber = 0;\n    const that = this;\n    while (highRule !== null && highRule.score() > minScore) {\n      if (iterationNumber % 5 === 0) {\n        // logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n      }\n      // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n      // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n      // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n\n      // Apply the high rule to each change site on its site list\n      this.getSites(highRule).forEach(function (site) {\n        // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n        // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n        highRule.applyAt(that.corpus.sentences[site[0]], site[1]);\n      });\n      const unseenRules = new RuleSet();\n      this.getSites(highRule).forEach(function (site) {\n        that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n          // Generate positive rules for testSite\n          const newRules = that.generatePositiveRules(testSite[0], testSite[1]);\n\n          // Disconnect test site from its rules\n          // because highrule has been applied\n          that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n            if (!newRules.hasRule(rule)) {\n              that.disconnectSiteFromRule(testSite[0], testSite[1], rule);\n            }\n          });\n\n          // Connect new rules not already connected to the test site\n          newRules.getRules().forEach(function (rule) {\n            if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n              if (that.positiveRules.hasRule(rule)) {\n                that.associateSiteWithRule(testSite[0], testSite[1], rule);\n              } else {\n                unseenRules.addRule(rule);\n              }\n            }\n          });\n\n          // Process unseen rules\n          if (unseenRules.nrRules() > 0) {\n            unseenRules.getRules().forEach(function (rule) {\n              that.positiveRules.addRule(rule);\n            });\n            that.corpus.sentences.forEach(function (sentence, i) {\n              const taggedSentence = sentence.map(function (token) {\n                return [token.token, token.testTag];\n              });\n              sentence.forEach(function (token, j) {\n                unseenRules.getRules().forEach(function (rule) {\n                  if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                    that.associateSiteWithRule(i, j, rule);\n                    that.scoreRule(rule, i, j);\n                  }\n                });\n              });\n            });\n          }\n        });\n      });\n\n      // Select next highest scoring rule\n      highRule = this.selectHighRule();\n      iterationNumber++;\n    }\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n    // Remove rules having a non-positive score\n    this.positiveRules.getRules().forEach(function (rule) {\n      if (rule.score() < that.ruleScoreThreshold) {\n        that.positiveRules.removeRule(rule);\n      }\n    });\n\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n    return this.positiveRules;\n  }\n  printRulesWithScores() {\n    let result = '';\n    function compareRules(a, b) {\n      if (a.score() > b.score()) {\n        return -1;\n      } else {\n        if (a.score() < b.score()) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    }\n    const rules = this.positiveRules.getRules();\n    const sortedRules = rules.sort(compareRules);\n    sortedRules.forEach(function (rule) {\n      // if (rule.score() > 0) {\n      result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n';\n      // }\n    });\n    return result;\n  }\n}\nmodule.exports = BrillPOSTrainer;","map":{"version":3,"names":["TransformationRule","require","RuleSet","Sentence","minScore","BrillPOSTrainer","constructor","ruleScoreThreshold","selectHighRule","highestRule","positiveRules","getRules","forEach","rule","hasBeenSelectedAsHighRuleBefore","score","mapRuleToSite","i","j","mapRuleToSites","key","mapSiteToRule","mapSiteToRules","associateSiteWithRule","siteIsAssociatedWithRule","getSites","that","result","Object","keys","push","map","disconnectSiteFromRule","scoreRule","token","corpus","sentences","taggedWords","rightTag","tag","oldTag","testTag","newTag","positive","neutral","negative","generatePositiveRules","sentence","newRules","templates","template","windowFitsSite","meta","nrParameters","parameter1Values","value","addRule","predicateName","value1","parameter2Values","value2","scanForPositiveRules","scanForSites","taggedSentence","wordObject","addTaggedWord","isApplicableAt","neighbourhood","sentenceLength","length","list","index","train","lexicon","highRule","iterationNumber","site","applyAt","unseenRules","testSite","hasRule","nrRules","removeRule","printRulesWithScores","compareRules","a","b","rules","sortedRules","sort","prettyPrint","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js"],"sourcesContent":["/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n'use strict'\n\nconst TransformationRule = require('./TransformationRule')\nconst RuleSet = require('./RuleSet')\nconst Sentence = require('./Sentence')\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nconst minScore = 0\n// After training rules with a score below scoreThreshold are pruned\n\nclass BrillPOSTrainer {\n  constructor (ruleScoreThreshold) {\n    if (ruleScoreThreshold) {\n      this.ruleScoreThreshold = ruleScoreThreshold\n    } else {\n      this.ruleScoreThreshold = 1\n    }\n  }\n\n  // Return the highest scoring rule from the rule set\n  selectHighRule () {\n    let highestRule = null\n\n    // Walk through the map and find the rule with highest score\n    this.positiveRules.getRules().forEach(function (rule) {\n      if (highestRule === null) {\n        if (!rule.hasBeenSelectedAsHighRuleBefore) {\n          highestRule = rule\n        }\n      } else {\n        if ((rule.score() > highestRule.score()) &&\n          !rule.hasBeenSelectedAsHighRuleBefore) {\n          highestRule = rule\n        }\n      }\n    })\n\n    if (highestRule !== null) {\n      highestRule.hasBeenSelectedAsHighRuleBefore = true\n    }\n    // Return the rule with the highest score\n    return highestRule\n  }\n\n  mapRuleToSite (rule, i, j) {\n    if (!this.mapRuleToSites[rule.key()]) {\n      this.mapRuleToSites[rule.key()] = {}\n    }\n    if (!this.mapRuleToSites[rule.key()][i]) {\n      this.mapRuleToSites[rule.key()][i] = {}\n    }\n    this.mapRuleToSites[rule.key()][i][j] = true\n  }\n\n  mapSiteToRule (i, j, rule) {\n    if (!this.mapSiteToRules[i]) {\n      this.mapSiteToRules[i] = {}\n    }\n    if (!this.mapSiteToRules[i][j]) {\n      this.mapSiteToRules[i][j] = {}\n    }\n    this.mapSiteToRules[i][j][rule.key()] = rule\n  }\n\n  associateSiteWithRule (i, j, rule) {\n    this.mapRuleToSite(rule, i, j)\n    this.mapSiteToRule(i, j, rule)\n  }\n\n  siteIsAssociatedWithRule (i, j, rule) {\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        if (this.mapSiteToRules[i][j][rule.key()]) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  // Returns an array of all sites associated with rule\n  getSites (rule) {\n    const that = this\n    const result = []\n    Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n      Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n        // Unary plus the convert hash keys i and j to integer\n        result.push([+i, +j])\n      })\n    })\n    // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n    return (result)\n  }\n\n  // Returns an array of all rules associated with the site\n  getRules (i, j) {\n    let result = []\n    const that = this\n\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n          return that.mapSiteToRules[i][j][key]\n        })\n      }\n    }\n    return result\n  }\n\n  disconnectSiteFromRule (i, j, rule) {\n    // mapRuleToSites\n    if (this.mapRuleToSites[rule.key()]) {\n      if (this.mapRuleToSites[rule.key()][i]) {\n        if (this.mapRuleToSites[rule.key()][i][j]) {\n          delete this.mapRuleToSites[rule.key()][i][j]\n        }\n      }\n    }\n\n    // mapSiteToRules\n    if (this.mapSiteToRules[i]) {\n      if (this.mapSiteToRules[i][j]) {\n        if (this.mapSiteToRules[i][j][rule.key()]) {\n          delete this.mapSiteToRules[i][j][rule.key()]\n        }\n      }\n    }\n  }\n\n  // Adjusts the score of the rule at position i, j of the corpus\n  scoreRule (rule, i, j) {\n    // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n    const token = this.corpus.sentences[i].taggedWords[j]\n    const rightTag = token.tag\n    const oldTag = token.testTag\n    const newTag = token.newTag\n    if (rightTag !== oldTag) {\n      // Old tag is wrong\n      if (newTag === rightTag) {\n        // New tag is right\n        rule.positive++\n        // If the score changes, it may be selected again as highest scoring rule\n        rule.hasBeenSelectedAsHighRuleBefore = false\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n      } else {\n        // New tag is wrong as well --> neutral\n        rule.neutral++\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n      }\n    } else {\n      // Old tag is right\n      if (newTag === rightTag) {\n        // New tag is right --> neutral\n        rule.neutral++\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n      } else {\n        // New tag is false\n        rule.negative++\n        // If the score changes, it may be selected again as highest scoring rule\n        rule.hasBeenSelectedAsHighRuleBefore = false\n        // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n      }\n    }\n    // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n  }\n\n  // Generate positive rules for this given site using templates\n  generatePositiveRules (i, j) {\n    const sentence = this.corpus.sentences[i]\n    const token = sentence.taggedWords[j]\n    // A positive rule should trigger on the currently assigned testTag\n    const oldTag = token.testTag\n    // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n    // It should assign the right tag as given by the corpus\n    const newTag = token.tag\n    // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n    const newRules = new RuleSet()\n    // Exit if testTag already is the right tag --> will not result in positive rules\n    if (oldTag === newTag) {\n      return newRules\n    }\n\n    this.templates.forEach(function (template) {\n      if (template.windowFitsSite(sentence, j)) {\n        if (template.meta.nrParameters === 1) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value) {\n            newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value))\n          })\n        } else {\n          if (template.meta.nrParameters === 2) {\n            template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n              template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n                newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2))\n              })\n            })\n          } else {\n            // 0 paramaters\n            newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName))\n          }\n        }\n      }\n    })\n    return newRules\n  }\n\n  // Finds all rules that are applicable at some site\n  scanForPositiveRules () {\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n    const that = this\n    this.corpus.sentences.forEach(function (sentence, i) {\n      sentence.taggedWords.forEach(function (token, j) {\n        // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n        const newRules = that.generatePositiveRules(i, j)\n        newRules.getRules().forEach(function (rule) {\n          that.positiveRules.addRule(rule)\n          // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n        })\n      })\n    })\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n  }\n\n  // Find all sites where the rules can be applied, register these sites and\n  // update the scores\n  scanForSites () {\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n    const that = this\n\n    // Scan the corpus\n    this.corpus.sentences.forEach(function (sentence, i) {\n      if (i % 100 === 0) {\n        // logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n      }\n\n      const taggedSentence = new Sentence()\n      sentence.taggedWords.forEach(function (wordObject) {\n        taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag)\n      })\n\n      sentence.taggedWords.forEach(function (token, j) {\n        that.positiveRules.getRules().forEach(function (rule) {\n          if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n            that.associateSiteWithRule(i, j, rule)\n            that.scoreRule(rule, i, j)\n            // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n          }\n        })\n      })\n    })\n\n    // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n  }\n\n  // Returns a list of sites that may have been touched by a changing tag\n  neighbourhood (i, j) {\n    const sentenceLength = this.corpus.sentences[i].length\n    const list = []\n\n    if (this.index > 2) {\n      list.push([i, j - 3])\n    }\n    if (this.index > 1) {\n      list.push([i, j - 2])\n    }\n    if (this.index > 0) {\n      list.push([i, j - 1])\n    }\n    if (this.index < sentenceLength - 1) {\n      list.push([i, j + 1])\n    }\n    if (this.index < sentenceLength - 2) {\n      list.push([i, j + 2])\n    }\n    if (this.index > sentenceLength - 3) {\n      list.push([i, j + 3])\n    }\n    return list\n  }\n\n  // corpus: an array of token arrays\n  // templates: an array of rule templates\n  // lexicon: lexicon that provides method tagWord(word)\n  train (corpus, templates, lexicon) {\n    this.corpus = corpus\n    this.templates = templates\n    this.positiveRules = new RuleSet()\n    this.mapRuleToSites = {}\n    this.mapSiteToRules = {}\n\n    // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n    this.corpus.tag(lexicon)\n    this.scanForPositiveRules()\n    // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n    this.scanForSites()\n\n    let highRule = this.selectHighRule()\n    let iterationNumber = 0\n    const that = this\n    while ((highRule !== null) && (highRule.score() > minScore)) {\n      if ((iterationNumber % 5) === 0) {\n        // logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n      }\n      // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n      // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n      // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n\n      // Apply the high rule to each change site on its site list\n      this.getSites(highRule).forEach(function (site) {\n        // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n        // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n        highRule.applyAt(that.corpus.sentences[site[0]], site[1])\n      })\n\n      const unseenRules = new RuleSet()\n      this.getSites(highRule).forEach(function (site) {\n        that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n          // Generate positive rules for testSite\n          const newRules = that.generatePositiveRules(testSite[0], testSite[1])\n\n          // Disconnect test site from its rules\n          // because highrule has been applied\n          that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n            if (!newRules.hasRule(rule)) {\n              that.disconnectSiteFromRule(testSite[0], testSite[1], rule)\n            }\n          })\n\n          // Connect new rules not already connected to the test site\n          newRules.getRules().forEach(function (rule) {\n            if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n              if (that.positiveRules.hasRule(rule)) {\n                that.associateSiteWithRule(testSite[0], testSite[1], rule)\n              } else {\n                unseenRules.addRule(rule)\n              }\n            }\n          })\n\n          // Process unseen rules\n          if (unseenRules.nrRules() > 0) {\n            unseenRules.getRules().forEach(function (rule) {\n              that.positiveRules.addRule(rule)\n            })\n            that.corpus.sentences.forEach(function (sentence, i) {\n              const taggedSentence = sentence.map(function (token) {\n                return [token.token, token.testTag]\n              })\n              sentence.forEach(function (token, j) {\n                unseenRules.getRules().forEach(function (rule) {\n                  if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                    that.associateSiteWithRule(i, j, rule)\n                    that.scoreRule(rule, i, j)\n                  }\n                })\n              })\n            })\n          }\n        })\n      })\n\n      // Select next highest scoring rule\n      highRule = this.selectHighRule()\n      iterationNumber++\n    }\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n    // Remove rules having a non-positive score\n    this.positiveRules.getRules().forEach(function (rule) {\n      if (rule.score() < that.ruleScoreThreshold) {\n        that.positiveRules.removeRule(rule)\n      }\n    })\n\n    // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n    return this.positiveRules\n  }\n\n  printRulesWithScores () {\n    let result = ''\n\n    function compareRules (a, b) {\n      if (a.score() > b.score()) {\n        return -1\n      } else {\n        if (a.score() < b.score()) {\n          return 1\n        } else {\n          return 0\n        }\n      }\n    }\n\n    const rules = this.positiveRules.getRules()\n    const sortedRules = rules.sort(compareRules)\n\n    sortedRules.forEach(function (rule) {\n      // if (rule.score() > 0) {\n      result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n'\n      // }\n    })\n    return result\n  }\n}\n\nmodule.exports = BrillPOSTrainer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}