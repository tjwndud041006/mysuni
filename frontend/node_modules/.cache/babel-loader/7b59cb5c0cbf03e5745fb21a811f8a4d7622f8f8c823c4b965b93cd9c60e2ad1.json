{"ast":null,"code":"import doesMatch from '../../term/doesMatch.js';\n\n// for greedy checking, we no longer care about the reg.start\n// value, and leaving it can cause failures for anchored greedy\n// matches.  ditto for end-greedy matches: we need an earlier non-\n// ending match to succceed until we get to the actual end.\nconst getGreedy = function (state, endReg) {\n  let reg = Object.assign({}, state.regs[state.r], {\n    start: false,\n    end: false\n  });\n  let start = state.t;\n  for (; state.t < state.terms.length; state.t += 1) {\n    //stop for next-reg match\n    if (endReg && doesMatch(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) {\n      return state.t;\n    }\n    let count = state.t - start + 1;\n    // is it max-length now?\n    if (reg.max !== undefined && count === reg.max) {\n      return state.t;\n    }\n    //stop here\n    if (doesMatch(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {\n      // is it too short?\n      if (reg.min !== undefined && count < reg.min) {\n        return null;\n      }\n      return state.t;\n    }\n  }\n  return state.t;\n};\nconst greedyTo = function (state, nextReg) {\n  let t = state.t;\n  //if there's no next one, just go off the end!\n  if (!nextReg) {\n    return state.terms.length;\n  }\n  //otherwise, we're looking for the next one\n  for (; t < state.terms.length; t += 1) {\n    if (doesMatch(state.terms[t], nextReg, state.start_i + t, state.phrase_length) === true) {\n      // console.log(`greedyTo ${state.terms[t].normal}`)\n      return t;\n    }\n  }\n  //guess it doesn't exist, then.\n  return null;\n};\nconst isEndGreedy = function (reg, state) {\n  if (reg.end === true && reg.greedy === true) {\n    if (state.start_i + state.t < state.phrase_length - 1) {\n      let tmpReg = Object.assign({}, reg, {\n        end: false\n      });\n      if (doesMatch(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) {\n        // console.log(`endGreedy ${state.terms[state.t].normal}`)\n        return true;\n      }\n    }\n  }\n  return false;\n};\nexport { isEndGreedy, greedyTo, getGreedy };","map":{"version":3,"names":["doesMatch","getGreedy","state","endReg","reg","Object","assign","regs","r","start","end","t","terms","length","start_i","phrase_length","count","max","undefined","min","greedyTo","nextReg","isEndGreedy","greedy","tmpReg"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/steps/logic/greedy.js"],"sourcesContent":["import doesMatch from '../../term/doesMatch.js'\n\n// for greedy checking, we no longer care about the reg.start\n// value, and leaving it can cause failures for anchored greedy\n// matches.  ditto for end-greedy matches: we need an earlier non-\n// ending match to succceed until we get to the actual end.\nconst getGreedy = function (state, endReg) {\n  let reg = Object.assign({}, state.regs[state.r], { start: false, end: false })\n  let start = state.t\n  for (; state.t < state.terms.length; state.t += 1) {\n    //stop for next-reg match\n    if (endReg && doesMatch(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) {\n      return state.t\n    }\n    let count = state.t - start + 1\n    // is it max-length now?\n    if (reg.max !== undefined && count === reg.max) {\n      return state.t\n    }\n    //stop here\n    if (doesMatch(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {\n      // is it too short?\n      if (reg.min !== undefined && count < reg.min) {\n        return null\n      }\n      return state.t\n    }\n  }\n  return state.t\n}\n\nconst greedyTo = function (state, nextReg) {\n  let t = state.t\n  //if there's no next one, just go off the end!\n  if (!nextReg) {\n    return state.terms.length\n  }\n  //otherwise, we're looking for the next one\n  for (; t < state.terms.length; t += 1) {\n    if (doesMatch(state.terms[t], nextReg, state.start_i + t, state.phrase_length) === true) {\n      // console.log(`greedyTo ${state.terms[t].normal}`)\n      return t\n    }\n  }\n  //guess it doesn't exist, then.\n  return null\n}\n\nconst isEndGreedy = function (reg, state) {\n  if (reg.end === true && reg.greedy === true) {\n    if (state.start_i + state.t < state.phrase_length - 1) {\n      let tmpReg = Object.assign({}, reg, { end: false })\n      if (doesMatch(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) {\n        // console.log(`endGreedy ${state.terms[state.t].normal}`)\n        return true\n      }\n    }\n  }\n  return false\n}\n\nexport { isEndGreedy, greedyTo, getGreedy }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}