{"ast":null,"code":"const isClass = /^\\../;\nconst isId = /^#./;\nconst escapeXml = str => {\n  str = str.replace(/&/g, '&amp;');\n  str = str.replace(/</g, '&lt;');\n  str = str.replace(/>/g, '&gt;');\n  str = str.replace(/\"/g, '&quot;');\n  str = str.replace(/'/g, '&apos;');\n  return str;\n};\n\n// interpret .class, #id, tagName\nconst toTag = function (k) {\n  let start = '';\n  let end = '</span>';\n  k = escapeXml(k);\n  if (isClass.test(k)) {\n    start = `<span class=\"${k.replace(/^\\./, '')}\"`;\n  } else if (isId.test(k)) {\n    start = `<span id=\"${k.replace(/^#/, '')}\"`;\n  } else {\n    start = `<${k}`;\n    end = `</${k}>`;\n  }\n  start += '>';\n  return {\n    start,\n    end\n  };\n};\nconst getIndex = function (doc, obj) {\n  let starts = {};\n  let ends = {};\n  Object.keys(obj).forEach(k => {\n    let res = obj[k];\n    let tag = toTag(k);\n    if (typeof res === 'string') {\n      res = doc.match(res);\n    }\n    res.docs.forEach(terms => {\n      // don't highlight implicit terms\n      if (terms.every(t => t.implicit)) {\n        return;\n      }\n      let a = terms[0].id;\n      starts[a] = starts[a] || [];\n      starts[a].push(tag.start);\n      let b = terms[terms.length - 1].id;\n      ends[b] = ends[b] || [];\n      ends[b].push(tag.end);\n    });\n  });\n  return {\n    starts,\n    ends\n  };\n};\nconst html = function (obj) {\n  // index ids to highlight\n  let {\n    starts,\n    ends\n  } = getIndex(this, obj);\n  // create the text output\n  let out = '';\n  this.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      let t = terms[i];\n      // do a span tag\n      if (starts.hasOwnProperty(t.id)) {\n        out += starts[t.id].join('');\n      }\n      out += t.pre || '';\n      out += t.text || '';\n      if (ends.hasOwnProperty(t.id)) {\n        out += ends[t.id].join('');\n      }\n      out += t.post || '';\n    }\n  });\n  return out;\n};\nexport default {\n  html\n};","map":{"version":3,"names":["isClass","isId","escapeXml","str","replace","toTag","k","start","end","test","getIndex","doc","obj","starts","ends","Object","keys","forEach","res","tag","match","docs","terms","every","t","implicit","a","id","push","b","length","html","out","i","hasOwnProperty","join","pre","text","post"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/output/api/html.js"],"sourcesContent":["const isClass = /^\\../\nconst isId = /^#./\n\nconst escapeXml = str => {\n  str = str.replace(/&/g, '&amp;')\n  str = str.replace(/</g, '&lt;')\n  str = str.replace(/>/g, '&gt;')\n  str = str.replace(/\"/g, '&quot;')\n  str = str.replace(/'/g, '&apos;')\n  return str\n}\n\n// interpret .class, #id, tagName\nconst toTag = function (k) {\n  let start = ''\n  let end = '</span>'\n  k = escapeXml(k)\n  if (isClass.test(k)) {\n    start = `<span class=\"${k.replace(/^\\./, '')}\"`\n  } else if (isId.test(k)) {\n    start = `<span id=\"${k.replace(/^#/, '')}\"`\n  } else {\n    start = `<${k}`\n    end = `</${k}>`\n  }\n  start += '>'\n  return { start, end }\n}\n\nconst getIndex = function (doc, obj) {\n  let starts = {}\n  let ends = {}\n  Object.keys(obj).forEach(k => {\n    let res = obj[k]\n    let tag = toTag(k)\n    if (typeof res === 'string') {\n      res = doc.match(res)\n    }\n    res.docs.forEach(terms => {\n      // don't highlight implicit terms\n      if (terms.every(t => t.implicit)) {\n        return\n      }\n      let a = terms[0].id\n      starts[a] = starts[a] || []\n      starts[a].push(tag.start)\n      let b = terms[terms.length - 1].id\n      ends[b] = ends[b] || []\n      ends[b].push(tag.end)\n    })\n  })\n  return { starts, ends }\n}\n\nconst html = function (obj) {\n  // index ids to highlight\n  let { starts, ends } = getIndex(this, obj)\n  // create the text output\n  let out = ''\n  this.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      let t = terms[i]\n      // do a span tag\n      if (starts.hasOwnProperty(t.id)) {\n        out += starts[t.id].join('')\n      }\n      out += t.pre || ''\n      out += t.text || ''\n      if (ends.hasOwnProperty(t.id)) {\n        out += ends[t.id].join('')\n      }\n      out += t.post || ''\n    }\n  })\n  return out\n}\nexport default { html }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}