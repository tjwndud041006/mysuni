{"ast":null,"code":"const toRoot = {\n  // 'spencer's' -> 'spencer'\n  'Possessive': term => {\n    let str = term.machine || term.normal || term.text;\n    str = str.replace(/'s$/, '');\n    return str;\n  },\n  // 'drinks' -> 'drink'\n  'Plural': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.noun.toSingular(str, world.model);\n  },\n  // ''\n  'Copula': () => {\n    return 'is';\n  },\n  // 'walked' -> 'walk'\n  'PastTense': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PastTense');\n  },\n  // 'walking' -> 'walk'\n  'Gerund': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'Gerund');\n  },\n  // 'walks' -> 'walk'\n  'PresentTense': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    if (term.tags.has('Infinitive')) {\n      return str;\n    }\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PresentTense');\n  },\n  // 'quieter' -> 'quiet'\n  'Comparative': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.adjective.fromComparative(str, world.model);\n  },\n  // 'quietest' -> 'quiet'\n  'Superlative': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.adjective.fromSuperlative(str, world.model);\n  },\n  // 'suddenly' -> 'sudden'\n  'Adverb': (term, world) => {\n    const {\n      fromAdverb\n    } = world.methods.two.transform.adjective;\n    let str = term.machine || term.normal || term.text;\n    return fromAdverb(str);\n  }\n};\nconst getRoot = function (view) {\n  const world = view.world;\n  const keys = Object.keys(toRoot);\n  view.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      const term = terms[i];\n      for (let k = 0; k < keys.length; k += 1) {\n        if (term.tags.has(keys[k])) {\n          const fn = toRoot[keys[k]];\n          let root = fn(term, world);\n          if (term.normal !== root) {\n            term.root = root;\n          }\n          break;\n        }\n      }\n    }\n  });\n};\nexport default getRoot;","map":{"version":3,"names":["toRoot","term","str","machine","normal","text","replace","Plural","world","methods","two","transform","noun","toSingular","model","Copula","PastTense","verb","toInfinitive","Gerund","PresentTense","tags","has","Comparative","adjective","fromComparative","Superlative","fromSuperlative","Adverb","fromAdverb","getRoot","view","keys","Object","docs","forEach","terms","i","length","k","fn","root"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/compute/root.js"],"sourcesContent":["const toRoot = {\n  // 'spencer's' -> 'spencer'\n  'Possessive': (term) => {\n    let str = term.machine || term.normal || term.text\n    str = str.replace(/'s$/, '')\n    return str\n  },\n  // 'drinks' -> 'drink'\n  'Plural': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.noun.toSingular(str, world.model)\n  },\n  // ''\n  'Copula': () => {\n    return 'is'\n  },\n  // 'walked' -> 'walk'\n  'PastTense': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PastTense')\n  },\n  // 'walking' -> 'walk'\n  'Gerund': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'Gerund')\n  },\n  // 'walks' -> 'walk'\n  'PresentTense': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    if (term.tags.has('Infinitive')) {\n      return str\n    }\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PresentTense')\n  },\n  // 'quieter' -> 'quiet'\n  'Comparative': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.adjective.fromComparative(str, world.model)\n  },\n  // 'quietest' -> 'quiet'\n  'Superlative': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.adjective.fromSuperlative(str, world.model)\n  },\n  // 'suddenly' -> 'sudden'\n  'Adverb': (term, world) => {\n    const { fromAdverb } = world.methods.two.transform.adjective\n    let str = term.machine || term.normal || term.text\n    return fromAdverb(str)\n  },\n}\n\nconst getRoot = function (view) {\n  const world = view.world\n  const keys = Object.keys(toRoot)\n  view.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      const term = terms[i]\n      for (let k = 0; k < keys.length; k += 1) {\n        if (term.tags.has(keys[k])) {\n          const fn = toRoot[keys[k]]\n          let root = fn(term, world)\n          if (term.normal !== root) {\n            term.root = root\n          }\n          break\n        }\n      }\n    }\n  })\n}\nexport default getRoot"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}