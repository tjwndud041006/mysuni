{"ast":null,"code":"const isTitleCase = str => /^\\p{Lu}[\\p{Ll}'’]/u.test(str);\nconst isPossessive = /'s$/;\n\n// words that can fit inside a place\nconst placeCont = new Set(['athletic', 'city', 'community', 'eastern', 'federal', 'financial', 'great', 'historic', 'historical', 'local', 'memorial', 'municipal', 'national', 'northern', 'provincial', 'southern', 'state', 'western', 'spring', 'pine', 'sunset', 'view', 'oak', 'maple', 'spruce', 'cedar', 'willow']);\n// center of...\nconst noBefore = new Set(['center', 'centre', 'way', 'range', 'bar', 'bridge', 'field', 'pit']);\nconst isPlace = function (term, i, yelling) {\n  if (!term) {\n    return false;\n  }\n  let tags = term.tags;\n  if (tags.has('Organization') || tags.has('Possessive') || isPossessive.test(term.normal)) {\n    return false;\n  }\n  if (tags.has('ProperNoun') || tags.has('Place')) {\n    return true;\n  }\n  // allow anything titlecased to be an org\n  if (!yelling && isTitleCase(term.text)) {\n    // only tag a titlecased first-word, if it checks-out\n    if (i === 0) {\n      return tags.has('Singular');\n    }\n    return true;\n  }\n  return false;\n};\nconst tagOrgs = function (terms, i, world, yelling) {\n  const placeWords = world.model.two.placeWords;\n  const setTag = world.methods.one.setTag;\n  let term = terms[i];\n  let str = term.machine || term.normal;\n\n  // 'river', delta, street, etc\n  if (placeWords[str] === true) {\n    //loop backward - 'Foo River ...'\n    for (let n = i - 1; n >= 0; n -= 1) {\n      // 'municipal ...'\n      if (placeCont.has(terms[n].normal)) {\n        continue;\n      }\n      if (isPlace(terms[n], n, yelling)) {\n        setTag(terms.slice(n, i + 1), 'Place', world, null, '3-[place-of-foo]');\n        continue;\n      }\n      break;\n    }\n    //loop forward - 'River of Foo...'\n    // 'center of x'\n    if (noBefore.has(str)) {\n      return false;\n    }\n    for (let n = i + 1; n < terms.length; n += 1) {\n      if (isPlace(terms[n], n, yelling)) {\n        setTag(terms.slice(i, n + 1), 'Place', world, null, '3-[foo-place]');\n        return true;\n      }\n      // 'municipal ...'\n      if (terms[n].normal === 'of' || placeCont.has(terms[n].normal)) {\n        continue;\n      }\n      break;\n    }\n  }\n  return null;\n};\nexport default tagOrgs;","map":{"version":3,"names":["isTitleCase","str","test","isPossessive","placeCont","Set","noBefore","isPlace","term","i","yelling","tags","has","normal","text","tagOrgs","terms","world","placeWords","model","two","setTag","methods","one","machine","n","slice","length"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/04-placeWords.js"],"sourcesContent":["const isTitleCase = str => /^\\p{Lu}[\\p{Ll}'’]/u.test(str)\nconst isPossessive = /'s$/\n\n// words that can fit inside a place\nconst placeCont = new Set([\n  'athletic',\n  'city',\n  'community',\n  'eastern',\n  'federal',\n  'financial',\n  'great',\n  'historic',\n  'historical',\n  'local',\n  'memorial',\n  'municipal',\n  'national',\n  'northern',\n  'provincial',\n  'southern',\n  'state',\n  'western',\n  'spring',\n  'pine',\n  'sunset',\n  'view',\n  'oak',\n  'maple',\n  'spruce',\n  'cedar',\n  'willow',\n])\n// center of...\nconst noBefore = new Set(['center', 'centre', 'way', 'range', 'bar', 'bridge', 'field', 'pit'])\n\nconst isPlace = function (term, i, yelling) {\n  if (!term) {\n    return false\n  }\n  let tags = term.tags\n  if (tags.has('Organization') || tags.has('Possessive') || isPossessive.test(term.normal)) {\n    return false\n  }\n  if (tags.has('ProperNoun') || tags.has('Place')) {\n    return true\n  }\n  // allow anything titlecased to be an org\n  if (!yelling && isTitleCase(term.text)) {\n    // only tag a titlecased first-word, if it checks-out\n    if (i === 0) {\n      return tags.has('Singular')\n    }\n    return true\n  }\n  return false\n}\n\nconst tagOrgs = function (terms, i, world, yelling) {\n  const placeWords = world.model.two.placeWords\n  const setTag = world.methods.one.setTag\n  let term = terms[i]\n  let str = term.machine || term.normal\n\n  // 'river', delta, street, etc\n  if (placeWords[str] === true) {\n    //loop backward - 'Foo River ...'\n    for (let n = i - 1; n >= 0; n -= 1) {\n      // 'municipal ...'\n      if (placeCont.has(terms[n].normal)) {\n        continue\n      }\n      if (isPlace(terms[n], n, yelling)) {\n        setTag(terms.slice(n, i + 1), 'Place', world, null, '3-[place-of-foo]')\n        continue\n      }\n      break\n    }\n    //loop forward - 'River of Foo...'\n    // 'center of x'\n    if (noBefore.has(str)) {\n      return false\n    }\n    for (let n = i + 1; n < terms.length; n += 1) {\n      if (isPlace(terms[n], n, yelling)) {\n        setTag(terms.slice(i, n + 1), 'Place', world, null, '3-[foo-place]')\n        return true\n      }\n      // 'municipal ...'\n      if (terms[n].normal === 'of' || placeCont.has(terms[n].normal)) {\n        continue\n      }\n      break\n    }\n  }\n  return null\n}\nexport default tagOrgs\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}