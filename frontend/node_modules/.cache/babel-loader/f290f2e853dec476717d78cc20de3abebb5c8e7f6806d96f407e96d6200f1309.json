{"ast":null,"code":"import parse from './01-parse.js';\n\n// do some indexing on the list of matches\nconst buildNet = function (matches, world) {\n  // turn match-syntax into json\n  matches = parse(matches, world);\n\n  // collect by wants and needs\n  let hooks = {};\n  matches.forEach(obj => {\n    // add needs\n    obj.needs.forEach(str => {\n      hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : [];\n      hooks[str].push(obj);\n    });\n    // add wants\n    obj.wants.forEach(str => {\n      hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : [];\n      hooks[str].push(obj);\n    });\n  });\n  // remove duplicates\n  Object.keys(hooks).forEach(k => {\n    let already = {};\n    hooks[k] = hooks[k].filter(obj => {\n      if (typeof already[obj.match] === 'boolean') {\n        return false;\n      }\n      already[obj.match] = true;\n      return true;\n    });\n  });\n\n  // keep all un-cacheable matches (those with no needs) \n  let always = matches.filter(o => o.needs.length === 0 && o.wants.length === 0);\n  return {\n    hooks,\n    always\n  };\n};\nexport default buildNet;","map":{"version":3,"names":["parse","buildNet","matches","world","hooks","forEach","obj","needs","str","Array","isArray","push","wants","Object","keys","k","already","filter","match","always","o","length"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js"],"sourcesContent":["import parse from './01-parse.js'\n\n// do some indexing on the list of matches\nconst buildNet = function (matches, world) {\n  // turn match-syntax into json\n  matches = parse(matches, world)\n\n  // collect by wants and needs\n  let hooks = {}\n  matches.forEach(obj => {\n    // add needs\n    obj.needs.forEach(str => {\n      hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : []\n      hooks[str].push(obj)\n    })\n    // add wants\n    obj.wants.forEach(str => {\n      hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : []\n      hooks[str].push(obj)\n    })\n  })\n  // remove duplicates\n  Object.keys(hooks).forEach(k => {\n    let already = {}\n    hooks[k] = hooks[k].filter(obj => {\n      if (typeof already[obj.match] === 'boolean') {\n        return false\n      }\n      already[obj.match] = true\n      return true\n    })\n  })\n\n  // keep all un-cacheable matches (those with no needs) \n  let always = matches.filter(o => o.needs.length === 0 && o.wants.length === 0)\n  return {\n    hooks,\n    always\n  }\n}\n\nexport default buildNet\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,eAAe;;AAEjC;AACA,MAAMC,QAAQ,GAAG,SAAAA,CAAUC,OAAO,EAAEC,KAAK,EAAE;EACzC;EACAD,OAAO,GAAGF,KAAK,CAACE,OAAO,EAAEC,KAAK,CAAC;;EAE/B;EACA,IAAIC,KAAK,GAAG,CAAC,CAAC;EACdF,OAAO,CAACG,OAAO,CAACC,GAAG,IAAI;IACrB;IACAA,GAAG,CAACC,KAAK,CAACF,OAAO,CAACG,GAAG,IAAI;MACvBJ,KAAK,CAACI,GAAG,CAAC,GAAGC,KAAK,CAACC,OAAO,CAACN,KAAK,CAACI,GAAG,CAAC,CAAC,GAAGJ,KAAK,CAACI,GAAG,CAAC,GAAG,EAAE;MACxDJ,KAAK,CAACI,GAAG,CAAC,CAACG,IAAI,CAACL,GAAG,CAAC;IACtB,CAAC,CAAC;IACF;IACAA,GAAG,CAACM,KAAK,CAACP,OAAO,CAACG,GAAG,IAAI;MACvBJ,KAAK,CAACI,GAAG,CAAC,GAAGC,KAAK,CAACC,OAAO,CAACN,KAAK,CAACI,GAAG,CAAC,CAAC,GAAGJ,KAAK,CAACI,GAAG,CAAC,GAAG,EAAE;MACxDJ,KAAK,CAACI,GAAG,CAAC,CAACG,IAAI,CAACL,GAAG,CAAC;IACtB,CAAC,CAAC;EACJ,CAAC,CAAC;EACF;EACAO,MAAM,CAACC,IAAI,CAACV,KAAK,CAAC,CAACC,OAAO,CAACU,CAAC,IAAI;IAC9B,IAAIC,OAAO,GAAG,CAAC,CAAC;IAChBZ,KAAK,CAACW,CAAC,CAAC,GAAGX,KAAK,CAACW,CAAC,CAAC,CAACE,MAAM,CAACX,GAAG,IAAI;MAChC,IAAI,OAAOU,OAAO,CAACV,GAAG,CAACY,KAAK,CAAC,KAAK,SAAS,EAAE;QAC3C,OAAO,KAAK;MACd;MACAF,OAAO,CAACV,GAAG,CAACY,KAAK,CAAC,GAAG,IAAI;MACzB,OAAO,IAAI;IACb,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,IAAIC,MAAM,GAAGjB,OAAO,CAACe,MAAM,CAACG,CAAC,IAAIA,CAAC,CAACb,KAAK,CAACc,MAAM,KAAK,CAAC,IAAID,CAAC,CAACR,KAAK,CAACS,MAAM,KAAK,CAAC,CAAC;EAC9E,OAAO;IACLjB,KAAK;IACLe;EACF,CAAC;AACH,CAAC;AAED,eAAelB,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}