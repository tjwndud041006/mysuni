{"ast":null,"code":"import { doDoes, toInf } from '../lib.js';\nconst keep = {\n  tags: true\n};\n\n// do/does not walk \nconst doesNot = function (vb, parsed) {\n  let does = doDoes(vb, parsed);\n  vb.prepend(does + ' not');\n  return vb;\n};\nconst isWas = function (vb) {\n  // not be\n  let m = vb.match('be');\n  if (m.found) {\n    m.prepend('not');\n    return vb;\n  }\n  // will not\n  m = vb.match('(is|was|am|are|will|were)');\n  if (m.found) {\n    m.append('not');\n    return vb;\n  }\n  return vb;\n};\nconst hasCopula = vb => vb.has('(is|was|am|are|will|were|be)');\n\n//vaguely, turn 'he is cool' into 'he is not cool'\nconst forms = {\n  // he walks' -> 'he does not walk'\n  'simple-present': (vb, parsed) => {\n    // is/was\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed);\n    }\n    // he walk\n    vb = toInf(vb, parsed);\n    // does not \n    vb = doesNot(vb, parsed);\n    return vb;\n  },\n  // 'he walked' -> 'he did not walk'\n  'simple-past': (vb, parsed) => {\n    // is/was\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed);\n    }\n    // he walk\n    vb = toInf(vb, parsed);\n    // vb.debug()\n    // did not walk\n    vb.prepend('did not');\n    return vb;\n  },\n  // walk! -> 'do not walk'\n  'imperative': vb => {\n    vb.prepend('do not');\n    return vb;\n  },\n  // walk -> does not walk\n  'infinitive': (vb, parsed) => {\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed);\n    }\n    return doesNot(vb, parsed);\n  },\n  'passive-past': vb => {\n    // got walked -> did not get walked\n    if (vb.has('got')) {\n      vb.replace('got', 'get', keep);\n      vb.prepend('did not');\n      return vb;\n    }\n    // was walked, were walked\n    // was being walked\n    // had been walked, have been eaten\n    let m = vb.match('(was|were|had|have)');\n    if (m.found) {\n      m.append('not');\n    }\n    return vb;\n  },\n  'auxiliary-past': vb => {\n    // used to walk\n    if (vb.has('used')) {\n      vb.prepend('did not');\n      return vb;\n    }\n    // he did walk\n    let m = vb.match('(did|does|do)');\n    if (m.found) {\n      m.append('not');\n    }\n    return vb;\n  },\n  // wants to walk\n  'want-infinitive': (vb, parsed) => {\n    // does not \n    vb = doesNot(vb, parsed);\n    // want\n    vb = vb.replace('wants', 'want', keep);\n    return vb;\n  }\n};\nconst toNegative = function (vb, parsed, form) {\n  // console.log(form)\n  if (vb.has('#Negative')) {\n    return vb;\n  }\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed);\n    return vb;\n  }\n\n  // 'not be'\n  let m = vb.matchOne('be');\n  if (m.found) {\n    m.prepend('not');\n    return vb;\n  }\n  // is/was not\n  if (hasCopula(vb) === true) {\n    return isWas(vb, parsed);\n  }\n\n  // 'would not'\n  m = vb.matchOne('(will|had|have|has|did|does|do|#Modal)');\n  if (m.found) {\n    m.append('not');\n    return vb;\n  }\n  // do nothing i guess?\n  return vb;\n};\nexport default toNegative;","map":{"version":3,"names":["doDoes","toInf","keep","tags","doesNot","vb","parsed","does","prepend","isWas","m","match","found","append","hasCopula","has","forms","simple-present","simple-past","infinitive","replace","want-infinitive","toNegative","form","hasOwnProperty","matchOne"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toNegative.js"],"sourcesContent":["import { doDoes, toInf } from '../lib.js'\nconst keep = { tags: true }\n\n// do/does not walk \nconst doesNot = function (vb, parsed) {\n  let does = doDoes(vb, parsed)\n  vb.prepend(does + ' not')\n  return vb\n}\n\nconst isWas = function (vb) {\n  // not be\n  let m = vb.match('be')\n  if (m.found) {\n    m.prepend('not')\n    return vb\n  }\n  // will not\n  m = vb.match('(is|was|am|are|will|were)')\n  if (m.found) {\n    m.append('not')\n    return vb\n  }\n  return vb\n}\n\nconst hasCopula = (vb) => vb.has('(is|was|am|are|will|were|be)')\n\n//vaguely, turn 'he is cool' into 'he is not cool'\nconst forms = {\n\n\n  // he walks' -> 'he does not walk'\n  'simple-present': (vb, parsed) => {\n    // is/was\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed)\n    }\n    // he walk\n    vb = toInf(vb, parsed)\n    // does not \n    vb = doesNot(vb, parsed)\n    return vb\n  },\n  // 'he walked' -> 'he did not walk'\n  'simple-past': (vb, parsed) => {\n    // is/was\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed)\n    }\n    // he walk\n    vb = toInf(vb, parsed)\n    // vb.debug()\n    // did not walk\n    vb.prepend('did not')\n    return vb\n  },\n\n  // walk! -> 'do not walk'\n  'imperative': (vb) => {\n    vb.prepend('do not')\n    return vb\n  },\n  // walk -> does not walk\n  'infinitive': (vb, parsed) => {\n    if (hasCopula(vb) === true) {\n      return isWas(vb, parsed)\n    }\n    return doesNot(vb, parsed)\n  },\n\n  'passive-past': (vb) => {\n    // got walked -> did not get walked\n    if (vb.has('got')) {\n      vb.replace('got', 'get', keep)\n      vb.prepend('did not')\n      return vb\n    }\n    // was walked, were walked\n    // was being walked\n    // had been walked, have been eaten\n    let m = vb.match('(was|were|had|have)')\n    if (m.found) {\n      m.append('not')\n    }\n    return vb\n  },\n  'auxiliary-past': (vb) => {\n    // used to walk\n    if (vb.has('used')) {\n      vb.prepend('did not')\n      return vb\n    }\n    // he did walk\n    let m = vb.match('(did|does|do)')\n    if (m.found) {\n      m.append('not')\n    }\n    return vb\n  },\n\n  // wants to walk\n  'want-infinitive': (vb, parsed) => {\n    // does not \n    vb = doesNot(vb, parsed)\n    // want\n    vb = vb.replace('wants', 'want', keep)\n    return vb\n  },\n\n}\n\nconst toNegative = function (vb, parsed, form) {\n  // console.log(form)\n  if (vb.has('#Negative')) {\n    return vb\n  }\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed)\n    return vb\n  }\n\n  // 'not be'\n  let m = vb.matchOne('be')\n  if (m.found) {\n    m.prepend('not')\n    return vb\n  }\n  // is/was not\n  if (hasCopula(vb) === true) {\n    return isWas(vb, parsed)\n  }\n\n  // 'would not'\n  m = vb.matchOne('(will|had|have|has|did|does|do|#Modal)')\n  if (m.found) {\n    m.append('not')\n    return vb\n  }\n  // do nothing i guess?\n  return vb\n}\nexport default toNegative"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}