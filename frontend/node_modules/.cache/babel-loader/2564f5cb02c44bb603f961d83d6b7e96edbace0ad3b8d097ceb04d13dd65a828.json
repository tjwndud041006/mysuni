{"ast":null,"code":"import forms from './forms.js';\nconst cleanUp = function (vb, res) {\n  vb = vb.clone();\n  // remove adverbs\n  if (res.adverbs.post && res.adverbs.post.found) {\n    vb.remove(res.adverbs.post);\n  }\n  if (res.adverbs.pre && res.adverbs.pre.found) {\n    vb.remove(res.adverbs.pre);\n  }\n  // remove negatives\n  if (vb.has('#Negative')) {\n    vb = vb.remove('#Negative');\n  }\n  // remove prefixes like 'anti'\n  if (vb.has('#Prefix')) {\n    vb = vb.remove('#Prefix');\n  }\n  // cut-off phrasal-verb\n  if (res.root.has('#PhrasalVerb #Particle')) {\n    vb.remove('#Particle$');\n  }\n  // did we miss any of these?\n  // vb = vb.remove('#Adverb')\n  vb = vb.not('#Adverb');\n  return vb;\n};\n\n// 'learned [to code]'\nconst isInfinitive = function (vb) {\n  if (vb.has('#Infinitive')) {\n    let m = vb.growLeft('to');\n    if (m.has('^to #Infinitive')) {\n      return true;\n    }\n  }\n  return false;\n};\nconst getGrammar = function (vb, res) {\n  let grammar = {};\n  // make it easy to classify, first\n  vb = cleanUp(vb, res);\n  for (let i = 0; i < forms.length; i += 1) {\n    let todo = forms[i];\n    if (vb.has(todo.match) === true) {\n      grammar.form = todo.name;\n      Object.assign(grammar, todo.data);\n      break; //only match one\n    }\n  }\n  // did we find nothing?\n  if (!grammar.form) {\n    if (vb.has('^#Verb$')) {\n      grammar.form = 'infinitive';\n    }\n  }\n  // fallback to 'naiive' tense detection\n  if (!grammar.tense) {\n    grammar.tense = res.root.has('#PastTense') ? 'PastTense' : 'PresentTense';\n  }\n  grammar.copula = res.root.has('#Copula');\n  // 'learn to code'\n  grammar.isInfinitive = isInfinitive(vb);\n  return grammar;\n};\nexport default getGrammar;","map":{"version":3,"names":["forms","cleanUp","vb","res","clone","adverbs","post","found","remove","pre","has","root","not","isInfinitive","m","growLeft","getGrammar","grammar","i","length","todo","match","form","name","Object","assign","data","tense","copula"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js"],"sourcesContent":["import forms from './forms.js'\n\nconst cleanUp = function (vb, res) {\n  vb = vb.clone()\n  // remove adverbs\n  if (res.adverbs.post && res.adverbs.post.found) {\n    vb.remove(res.adverbs.post)\n  }\n  if (res.adverbs.pre && res.adverbs.pre.found) {\n    vb.remove(res.adverbs.pre)\n  }\n  // remove negatives\n  if (vb.has('#Negative')) {\n    vb = vb.remove('#Negative')\n  }\n  // remove prefixes like 'anti'\n  if (vb.has('#Prefix')) {\n    vb = vb.remove('#Prefix')\n  }\n  // cut-off phrasal-verb\n  if (res.root.has('#PhrasalVerb #Particle')) {\n    vb.remove('#Particle$')\n  }\n  // did we miss any of these?\n  // vb = vb.remove('#Adverb')\n  vb = vb.not('#Adverb')\n  return vb\n}\n\n// 'learned [to code]'\nconst isInfinitive = function (vb) {\n  if (vb.has('#Infinitive')) {\n    let m = vb.growLeft('to')\n    if (m.has('^to #Infinitive')) {\n      return true\n    }\n  }\n  return false\n}\n\nconst getGrammar = function (vb, res) {\n  let grammar = {}\n  // make it easy to classify, first\n  vb = cleanUp(vb, res)\n  for (let i = 0; i < forms.length; i += 1) {\n    let todo = forms[i]\n    if (vb.has(todo.match) === true) {\n      grammar.form = todo.name\n      Object.assign(grammar, todo.data)\n      break //only match one\n    }\n  }\n  // did we find nothing?\n  if (!grammar.form) {\n    if (vb.has('^#Verb$')) {\n      grammar.form = 'infinitive'\n    }\n  }\n  // fallback to 'naiive' tense detection\n  if (!grammar.tense) {\n    grammar.tense = res.root.has('#PastTense') ? 'PastTense' : 'PresentTense'\n  }\n  grammar.copula = res.root.has('#Copula')\n  // 'learn to code'\n  grammar.isInfinitive = isInfinitive(vb)\n  return grammar\n}\n\nexport default getGrammar\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}