{"ast":null,"code":"const hasContraction = /'/;\nconst hasWords = new Set(['been',\n//the meeting's been ..\n'become' //my son's become\n]);\nconst isWords = new Set(['what',\n//it's what\n'how',\n//it's how\n'when', 'if',\n//it's if\n'too']);\nlet adjLike = new Set(['too', 'also', 'enough']);\n\n// the big clue is the tense of the following verb\nconst isOrHas = (terms, i) => {\n  // scan ahead for the next verb or adjective\n  for (let o = i + 1; o < terms.length; o += 1) {\n    let t = terms[o];\n    if (hasWords.has(t.normal)) {\n      return 'has';\n    }\n    if (isWords.has(t.normal)) {\n      return 'is';\n    }\n    // the cat's sleeping\n    if (t.tags.has('Gerund')) {\n      return 'is';\n    }\n    // she's the one\n    if (t.tags.has('Determiner')) {\n      return 'is';\n    }\n    // the food's ready\n    if (t.tags.has('Adjective')) {\n      return 'is';\n    }\n    // the car's parked\n    if (t.switch === 'Adj|Past') {\n      if (terms[o + 1]) {\n        // car's parked too ..\n        if (adjLike.has(terms[o + 1].normal)) {\n          return 'is';\n        }\n        // car's parked on ..\n        if (terms[o + 1].tags.has('Preposition')) {\n          return 'is';\n        }\n      }\n      // return 'is'\n    }\n    // The meeting's scheduled vs The plane's landed\n    if (t.tags.has('PastTense')) {\n      // meeting's scheduled for\n      if (terms[o + 1] && terms[o + 1].normal === 'for') {\n        return 'is';\n      }\n      return 'has';\n    }\n  }\n  return 'is';\n};\n\n// 's -> [possessive, 'has', 'is', 'are', 'us']\nconst apostropheS = function (terms, i) {\n  // possessive, is/has\n  let before = terms[i].normal.split(hasContraction)[0];\n  // let's - >[let, us]\n  if (before === 'let') {\n    return [before, 'us'];\n  }\n  // allow slang \"there's cookies\" -> there are\n  if (before === 'there') {\n    let t = terms[i + 1];\n    if (t && t.tags.has('Plural')) {\n      return [before, 'are'];\n    }\n  }\n  // spencer's got -> spencer has got\n  if (isOrHas(terms, i) === 'has') {\n    return [before, 'has'];\n  }\n  return [before, 'is'];\n};\nexport default apostropheS;","map":{"version":3,"names":["hasContraction","hasWords","Set","isWords","adjLike","isOrHas","terms","i","o","length","t","has","normal","tags","switch","apostropheS","before","split"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-s.js"],"sourcesContent":["const hasContraction = /'/\n\nconst hasWords = new Set([\n  'been', //the meeting's been ..\n  'become', //my son's become\n])\nconst isWords = new Set([\n  'what', //it's what\n  'how', //it's how\n  'when',\n  'if', //it's if\n  'too',\n])\nlet adjLike = new Set(['too', 'also', 'enough'])\n\n// the big clue is the tense of the following verb\nconst isOrHas = (terms, i) => {\n  // scan ahead for the next verb or adjective\n  for (let o = i + 1; o < terms.length; o += 1) {\n    let t = terms[o]\n    if (hasWords.has(t.normal)) {\n      return 'has'\n    }\n    if (isWords.has(t.normal)) {\n      return 'is'\n    }\n    // the cat's sleeping\n    if (t.tags.has('Gerund')) {\n      return 'is'\n    }\n    // she's the one\n    if (t.tags.has('Determiner')) {\n      return 'is'\n    }\n    // the food's ready\n    if (t.tags.has('Adjective')) {\n      return 'is'\n    }\n    // the car's parked\n    if (t.switch === 'Adj|Past') {\n      if (terms[o + 1]) {\n        // car's parked too ..\n        if (adjLike.has(terms[o + 1].normal)) {\n          return 'is'\n        }\n        // car's parked on ..\n        if (terms[o + 1].tags.has('Preposition')) {\n          return 'is'\n        }\n      }\n      // return 'is'\n    }\n    // The meeting's scheduled vs The plane's landed\n    if (t.tags.has('PastTense')) {\n      // meeting's scheduled for\n      if (terms[o + 1] && terms[o + 1].normal === 'for') {\n        return 'is'\n      }\n      return 'has'\n    }\n  }\n  return 'is'\n}\n\n// 's -> [possessive, 'has', 'is', 'are', 'us']\nconst apostropheS = function (terms, i) {\n  // possessive, is/has\n  let before = terms[i].normal.split(hasContraction)[0]\n  // let's - >[let, us]\n  if (before === 'let') {\n    return [before, 'us']\n  }\n  // allow slang \"there's cookies\" -> there are\n  if (before === 'there') {\n    let t = terms[i + 1]\n    if (t && t.tags.has('Plural')) {\n      return [before, 'are']\n    }\n  }\n  // spencer's got -> spencer has got\n  if (isOrHas(terms, i) === 'has') {\n    return [before, 'has']\n  }\n  return [before, 'is']\n}\nexport default apostropheS\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}