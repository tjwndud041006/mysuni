{"ast":null,"code":"import colons from './1st-pass/01-colons.js';\nimport hyphens from './1st-pass/02-hyphens.js';\nimport tagSwitch from './2nd-pass/00-tagSwitch.js';\nimport checkCase from './2nd-pass/01-case.js';\nimport checkSuffix from './2nd-pass/02-suffix.js';\nimport checkRegex from './2nd-pass/03-regex.js';\nimport checkPrefix from './2nd-pass/04-prefix.js';\nimport checkYear from './2nd-pass/05-year.js';\nimport verbType from './3rd-pass/07-verb-type.js';\nimport fillTags from './3rd-pass/_fillTags.js';\nimport checkAcronym from './3rd-pass/01-acronym.js';\nimport neighbours from './3rd-pass/02-neighbours.js';\nimport orgWords from './3rd-pass/03-orgWords.js';\nimport placeWords from './3rd-pass/04-placeWords.js';\nimport nounFallback from './3rd-pass/05-fallback.js';\nimport switches from './3rd-pass/06-switches.js';\nimport imperative from './3rd-pass/08-imperative.js';\n\n// is it all yelling-case?\nconst ignoreCase = function (terms) {\n  // allow 'John F Kennedy'\n  if (terms.filter(t => !t.tags.has('ProperNoun')).length <= 3) {\n    return false;\n  }\n  const lowerCase = /^[a-z]/;\n  return terms.every(t => !lowerCase.test(t.text));\n};\n\n// taggers with no clause-splitting\nconst firstPass = function (docs, model, world) {\n  docs.forEach(terms => {\n    // check whitespace/punctuation\n    colons(terms, 0, model, world);\n  });\n};\n\n// these methods don't care about word-neighbours\nconst secondPass = function (terms, model, world, isYelling) {\n  for (let i = 0; i < terms.length; i += 1) {\n    // skip frozen terms, for now\n    if (terms[i].frozen === true) {\n      continue;\n    }\n    // mark Noun|Verb on term metadata\n    tagSwitch(terms, i, model);\n    //  is it titlecased?\n    if (isYelling === false) {\n      checkCase(terms, i, model);\n    }\n    // look at word ending\n    checkSuffix(terms, i, model);\n    // try look-like rules\n    checkRegex(terms, i, model, world);\n    // check for recognized prefix, like 'micro-'\n    checkPrefix(terms, i, model);\n    // turn '1993' into a year\n    checkYear(terms, i, model);\n  }\n};\n\n// neighbour-based tagging\nconst thirdPass = function (terms, model, world, isYelling) {\n  for (let i = 0; i < terms.length; i += 1) {\n    // let these tags get layered\n    let found = checkAcronym(terms, i, model);\n    // deduce parent tags\n    fillTags(terms, i, model);\n    // look left+right for hints\n    found = found || neighbours(terms, i, model);\n    //  ¯\\_(ツ)_/¯ - found nothing\n    found = found || nounFallback(terms, i, model);\n  }\n  for (let i = 0; i < terms.length; i += 1) {\n    // skip these\n    if (terms[i].frozen === true) {\n      continue;\n    }\n    // Johnson LLC\n    orgWords(terms, i, world, isYelling);\n    // Wawel Castle\n    placeWords(terms, i, world, isYelling);\n    // verb-noun disambiguation, etc\n    switches(terms, i, world);\n    // give bare verbs more tags\n    verbType(terms, i, model, world);\n    // hard-nosed\n    hyphens(terms, i, model, world);\n  }\n  // place tea bags\n  imperative(terms, world);\n};\nconst preTagger = function (view) {\n  const {\n    methods,\n    model,\n    world\n  } = view;\n  let docs = view.docs;\n  // try some early stuff\n  firstPass(docs, model, world);\n  // roughly split sentences up by clause\n  let document = methods.two.quickSplit(docs);\n  // start with all terms\n  for (let n = 0; n < document.length; n += 1) {\n    let terms = document[n];\n    // is it all upper-case?\n    const isYelling = ignoreCase(terms);\n    // guess by the letters\n    secondPass(terms, model, world, isYelling);\n    // guess by the neighbours\n    thirdPass(terms, model, world, isYelling);\n  }\n  return document;\n};\nexport default preTagger;","map":{"version":3,"names":["colons","hyphens","tagSwitch","checkCase","checkSuffix","checkRegex","checkPrefix","checkYear","verbType","fillTags","checkAcronym","neighbours","orgWords","placeWords","nounFallback","switches","imperative","ignoreCase","terms","filter","t","tags","has","length","lowerCase","every","test","text","firstPass","docs","model","world","forEach","secondPass","isYelling","i","frozen","thirdPass","found","preTagger","view","methods","document","two","quickSplit","n"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/compute/tagger/index.js"],"sourcesContent":["import colons from './1st-pass/01-colons.js'\nimport hyphens from './1st-pass/02-hyphens.js'\n\nimport tagSwitch from './2nd-pass/00-tagSwitch.js'\nimport checkCase from './2nd-pass/01-case.js'\nimport checkSuffix from './2nd-pass/02-suffix.js'\nimport checkRegex from './2nd-pass/03-regex.js'\nimport checkPrefix from './2nd-pass/04-prefix.js'\nimport checkYear from './2nd-pass/05-year.js'\nimport verbType from './3rd-pass/07-verb-type.js'\n\nimport fillTags from './3rd-pass/_fillTags.js'\nimport checkAcronym from './3rd-pass/01-acronym.js'\nimport neighbours from './3rd-pass/02-neighbours.js'\nimport orgWords from './3rd-pass/03-orgWords.js'\nimport placeWords from './3rd-pass/04-placeWords.js'\nimport nounFallback from './3rd-pass/05-fallback.js'\nimport switches from './3rd-pass/06-switches.js'\nimport imperative from './3rd-pass/08-imperative.js'\n\n// is it all yelling-case?\nconst ignoreCase = function (terms) {\n  // allow 'John F Kennedy'\n  if (terms.filter(t => !t.tags.has('ProperNoun')).length <= 3) {\n    return false\n  }\n  const lowerCase = /^[a-z]/\n  return terms.every(t => !lowerCase.test(t.text))\n}\n\n// taggers with no clause-splitting\nconst firstPass = function (docs, model, world) {\n  docs.forEach(terms => {\n    // check whitespace/punctuation\n    colons(terms, 0, model, world)\n  })\n}\n\n// these methods don't care about word-neighbours\nconst secondPass = function (terms, model, world, isYelling) {\n  for (let i = 0; i < terms.length; i += 1) {\n    // skip frozen terms, for now\n    if (terms[i].frozen === true) {\n      continue\n    }\n    // mark Noun|Verb on term metadata\n    tagSwitch(terms, i, model)\n    //  is it titlecased?\n    if (isYelling === false) {\n      checkCase(terms, i, model)\n    }\n    // look at word ending\n    checkSuffix(terms, i, model)\n    // try look-like rules\n    checkRegex(terms, i, model, world)\n    // check for recognized prefix, like 'micro-'\n    checkPrefix(terms, i, model)\n    // turn '1993' into a year\n    checkYear(terms, i, model)\n  }\n}\n\n// neighbour-based tagging\nconst thirdPass = function (terms, model, world, isYelling) {\n  for (let i = 0; i < terms.length; i += 1) {\n    // let these tags get layered\n    let found = checkAcronym(terms, i, model)\n    // deduce parent tags\n    fillTags(terms, i, model)\n    // look left+right for hints\n    found = found || neighbours(terms, i, model)\n    //  ¯\\_(ツ)_/¯ - found nothing\n    found = found || nounFallback(terms, i, model)\n  }\n  for (let i = 0; i < terms.length; i += 1) {\n    // skip these\n    if (terms[i].frozen === true) {\n      continue\n    }\n    // Johnson LLC\n    orgWords(terms, i, world, isYelling)\n    // Wawel Castle\n    placeWords(terms, i, world, isYelling)\n    // verb-noun disambiguation, etc\n    switches(terms, i, world)\n    // give bare verbs more tags\n    verbType(terms, i, model, world)\n    // hard-nosed\n    hyphens(terms, i, model, world)\n  }\n  // place tea bags\n  imperative(terms, world)\n}\n\nconst preTagger = function (view) {\n  const { methods, model, world } = view\n  let docs = view.docs\n  // try some early stuff\n  firstPass(docs, model, world)\n  // roughly split sentences up by clause\n  let document = methods.two.quickSplit(docs)\n  // start with all terms\n  for (let n = 0; n < document.length; n += 1) {\n    let terms = document[n]\n    // is it all upper-case?\n    const isYelling = ignoreCase(terms)\n    // guess by the letters\n    secondPass(terms, model, world, isYelling)\n    // guess by the neighbours\n    thirdPass(terms, model, world, isYelling)\n  }\n  return document\n}\n\nexport default preTagger\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}