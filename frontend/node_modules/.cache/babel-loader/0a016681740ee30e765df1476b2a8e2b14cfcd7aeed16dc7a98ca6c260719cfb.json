{"ast":null,"code":"import { indexN } from './_lib.js';\n\n// split a pointer, by match pointer\nconst pivotBy = function (full, m) {\n  let [n, start] = full;\n  let mStart = m[1];\n  let mEnd = m[2];\n  let res = {};\n  // is there space before the match?\n  if (start < mStart) {\n    let end = mStart < full[2] ? mStart : full[2]; // find closest end-point\n    res.before = [n, start, end]; //before segment\n  }\n  res.match = m;\n  // is there space after the match?\n  if (full[2] > mEnd) {\n    res.after = [n, mEnd, full[2]]; //after segment\n  }\n  return res;\n};\nconst doesMatch = function (full, m) {\n  return full[1] <= m[1] && m[2] <= full[2];\n};\nconst splitAll = function (full, m) {\n  let byN = indexN(m);\n  let res = [];\n  full.forEach(ptr => {\n    let [n] = ptr;\n    let matches = byN[n] || [];\n    matches = matches.filter(p => doesMatch(ptr, p));\n    if (matches.length === 0) {\n      res.push({\n        passthrough: ptr\n      });\n      return;\n    }\n    // ensure matches are in-order\n    matches = matches.sort((a, b) => a[1] - b[1]);\n    // start splitting our left-to-right\n    let carry = ptr;\n    matches.forEach((p, i) => {\n      let found = pivotBy(carry, p);\n      // last one\n      if (!matches[i + 1]) {\n        res.push(found);\n      } else {\n        res.push({\n          before: found.before,\n          match: found.match\n        });\n        if (found.after) {\n          carry = found.after;\n        }\n      }\n    });\n  });\n  return res;\n};\nexport default splitAll;","map":{"version":3,"names":["indexN","pivotBy","full","m","n","start","mStart","mEnd","res","end","before","match","after","doesMatch","splitAll","byN","forEach","ptr","matches","filter","p","length","push","passthrough","sort","a","b","carry","i","found"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/pointers/api/lib/split.js"],"sourcesContent":["import { indexN } from './_lib.js'\n\n// split a pointer, by match pointer\nconst pivotBy = function (full, m) {\n  let [n, start] = full\n  let mStart = m[1]\n  let mEnd = m[2]\n  let res = {}\n  // is there space before the match?\n  if (start < mStart) {\n    let end = mStart < full[2] ? mStart : full[2] // find closest end-point\n    res.before = [n, start, end] //before segment\n  }\n  res.match = m\n  // is there space after the match?\n  if (full[2] > mEnd) {\n    res.after = [n, mEnd, full[2]] //after segment\n  }\n  return res\n}\n\nconst doesMatch = function (full, m) {\n  return full[1] <= m[1] && m[2] <= full[2]\n}\n\nconst splitAll = function (full, m) {\n  let byN = indexN(m)\n  let res = []\n  full.forEach(ptr => {\n    let [n] = ptr\n    let matches = byN[n] || []\n    matches = matches.filter(p => doesMatch(ptr, p))\n    if (matches.length === 0) {\n      res.push({ passthrough: ptr })\n      return\n    }\n    // ensure matches are in-order\n    matches = matches.sort((a, b) => a[1] - b[1])\n    // start splitting our left-to-right\n    let carry = ptr\n    matches.forEach((p, i) => {\n      let found = pivotBy(carry, p)\n      // last one\n      if (!matches[i + 1]) {\n        res.push(found)\n      } else {\n        res.push({ before: found.before, match: found.match })\n        if (found.after) {\n          carry = found.after\n        }\n      }\n    })\n  })\n  return res\n}\n\nexport default splitAll\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,WAAW;;AAElC;AACA,MAAMC,OAAO,GAAG,SAAAA,CAAUC,IAAI,EAAEC,CAAC,EAAE;EACjC,IAAI,CAACC,CAAC,EAAEC,KAAK,CAAC,GAAGH,IAAI;EACrB,IAAII,MAAM,GAAGH,CAAC,CAAC,CAAC,CAAC;EACjB,IAAII,IAAI,GAAGJ,CAAC,CAAC,CAAC,CAAC;EACf,IAAIK,GAAG,GAAG,CAAC,CAAC;EACZ;EACA,IAAIH,KAAK,GAAGC,MAAM,EAAE;IAClB,IAAIG,GAAG,GAAGH,MAAM,GAAGJ,IAAI,CAAC,CAAC,CAAC,GAAGI,MAAM,GAAGJ,IAAI,CAAC,CAAC,CAAC,EAAC;IAC9CM,GAAG,CAACE,MAAM,GAAG,CAACN,CAAC,EAAEC,KAAK,EAAEI,GAAG,CAAC,EAAC;EAC/B;EACAD,GAAG,CAACG,KAAK,GAAGR,CAAC;EACb;EACA,IAAID,IAAI,CAAC,CAAC,CAAC,GAAGK,IAAI,EAAE;IAClBC,GAAG,CAACI,KAAK,GAAG,CAACR,CAAC,EAAEG,IAAI,EAAEL,IAAI,CAAC,CAAC,CAAC,CAAC,EAAC;EACjC;EACA,OAAOM,GAAG;AACZ,CAAC;AAED,MAAMK,SAAS,GAAG,SAAAA,CAAUX,IAAI,EAAEC,CAAC,EAAE;EACnC,OAAOD,IAAI,CAAC,CAAC,CAAC,IAAIC,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAID,IAAI,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,MAAMY,QAAQ,GAAG,SAAAA,CAAUZ,IAAI,EAAEC,CAAC,EAAE;EAClC,IAAIY,GAAG,GAAGf,MAAM,CAACG,CAAC,CAAC;EACnB,IAAIK,GAAG,GAAG,EAAE;EACZN,IAAI,CAACc,OAAO,CAACC,GAAG,IAAI;IAClB,IAAI,CAACb,CAAC,CAAC,GAAGa,GAAG;IACb,IAAIC,OAAO,GAAGH,GAAG,CAACX,CAAC,CAAC,IAAI,EAAE;IAC1Bc,OAAO,GAAGA,OAAO,CAACC,MAAM,CAACC,CAAC,IAAIP,SAAS,CAACI,GAAG,EAAEG,CAAC,CAAC,CAAC;IAChD,IAAIF,OAAO,CAACG,MAAM,KAAK,CAAC,EAAE;MACxBb,GAAG,CAACc,IAAI,CAAC;QAAEC,WAAW,EAAEN;MAAI,CAAC,CAAC;MAC9B;IACF;IACA;IACAC,OAAO,GAAGA,OAAO,CAACM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C;IACA,IAAIC,KAAK,GAAGV,GAAG;IACfC,OAAO,CAACF,OAAO,CAAC,CAACI,CAAC,EAAEQ,CAAC,KAAK;MACxB,IAAIC,KAAK,GAAG5B,OAAO,CAAC0B,KAAK,EAAEP,CAAC,CAAC;MAC7B;MACA,IAAI,CAACF,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,EAAE;QACnBpB,GAAG,CAACc,IAAI,CAACO,KAAK,CAAC;MACjB,CAAC,MAAM;QACLrB,GAAG,CAACc,IAAI,CAAC;UAAEZ,MAAM,EAAEmB,KAAK,CAACnB,MAAM;UAAEC,KAAK,EAAEkB,KAAK,CAAClB;QAAM,CAAC,CAAC;QACtD,IAAIkB,KAAK,CAACjB,KAAK,EAAE;UACfe,KAAK,GAAGE,KAAK,CAACjB,KAAK;QACrB;MACF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOJ,GAAG;AACZ,CAAC;AAED,eAAeM,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}