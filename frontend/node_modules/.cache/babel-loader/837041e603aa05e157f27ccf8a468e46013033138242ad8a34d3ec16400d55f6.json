{"ast":null,"code":"// roughly, split a document by comma or semicolon\n\nconst splitOn = function (terms, i) {\n  const isNum = /^[0-9]+$/;\n  let term = terms[i];\n  // early on, these may not be dates yet:\n  if (!term) {\n    return false;\n  }\n  const maybeDate = new Set(['may', 'april', 'august', 'jan']);\n  // veggies, like figs\n  if (term.normal === 'like' || maybeDate.has(term.normal)) {\n    return false;\n  }\n  // toronto, canada  - tuesday, march\n  if (term.tags.has('Place') || term.tags.has('Date')) {\n    return false;\n  }\n  if (terms[i - 1]) {\n    let lastTerm = terms[i - 1];\n    // thursday, june\n    if (lastTerm.tags.has('Date') || maybeDate.has(lastTerm.normal)) {\n      return false;\n    }\n    // pretty, nice, and fun\n    if (lastTerm.tags.has('Adjective') || term.tags.has('Adjective')) {\n      return false;\n    }\n  }\n  // don't split numbers, yet\n  let str = term.normal;\n  if (str.length === 1 || str.length === 2 || str.length === 4) {\n    if (isNum.test(str)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// kind-of a dirty sentence chunker\nconst quickSplit = function (document) {\n  const splitHere = /[,:;]/;\n  let arr = [];\n  document.forEach(terms => {\n    let start = 0;\n    terms.forEach((term, i) => {\n      // does it have a comma/semicolon ?\n      if (splitHere.test(term.post) && splitOn(terms, i + 1)) {\n        arr.push(terms.slice(start, i + 1));\n        start = i + 1;\n      }\n    });\n    if (start < terms.length) {\n      arr.push(terms.slice(start, terms.length));\n    }\n  });\n  return arr;\n};\nexport default quickSplit;","map":{"version":3,"names":["splitOn","terms","i","isNum","term","maybeDate","Set","normal","has","tags","lastTerm","str","length","test","quickSplit","document","splitHere","arr","forEach","start","post","push","slice"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/methods/quickSplit.js"],"sourcesContent":["// roughly, split a document by comma or semicolon\n\nconst splitOn = function (terms, i) {\n  const isNum = /^[0-9]+$/\n  let term = terms[i]\n  // early on, these may not be dates yet:\n  if (!term) {\n    return false\n  }\n  const maybeDate = new Set(['may', 'april', 'august', 'jan'])\n  // veggies, like figs\n  if (term.normal === 'like' || maybeDate.has(term.normal)) {\n    return false\n  }\n  // toronto, canada  - tuesday, march\n  if (term.tags.has('Place') || term.tags.has('Date')) {\n    return false\n  }\n  if (terms[i - 1]) {\n    let lastTerm = terms[i - 1]\n    // thursday, june\n    if (lastTerm.tags.has('Date') || maybeDate.has(lastTerm.normal)) {\n      return false\n    }\n    // pretty, nice, and fun\n    if (lastTerm.tags.has('Adjective') || term.tags.has('Adjective')) {\n      return false\n    }\n  }\n  // don't split numbers, yet\n  let str = term.normal\n  if (str.length === 1 || str.length === 2 || str.length === 4) {\n    if (isNum.test(str)) {\n      return false\n    }\n  }\n  return true\n}\n\n// kind-of a dirty sentence chunker\nconst quickSplit = function (document) {\n  const splitHere = /[,:;]/\n  let arr = []\n  document.forEach(terms => {\n    let start = 0\n    terms.forEach((term, i) => {\n      // does it have a comma/semicolon ?\n      if (splitHere.test(term.post) && splitOn(terms, i + 1)) {\n        arr.push(terms.slice(start, i + 1))\n        start = i + 1\n      }\n    })\n    if (start < terms.length) {\n      arr.push(terms.slice(start, terms.length))\n    }\n  })\n  return arr\n}\n\nexport default quickSplit"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAG,SAAAA,CAAUC,KAAK,EAAEC,CAAC,EAAE;EAClC,MAAMC,KAAK,GAAG,UAAU;EACxB,IAAIC,IAAI,GAAGH,KAAK,CAACC,CAAC,CAAC;EACnB;EACA,IAAI,CAACE,IAAI,EAAE;IACT,OAAO,KAAK;EACd;EACA,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;EAC5D;EACA,IAAIF,IAAI,CAACG,MAAM,KAAK,MAAM,IAAIF,SAAS,CAACG,GAAG,CAACJ,IAAI,CAACG,MAAM,CAAC,EAAE;IACxD,OAAO,KAAK;EACd;EACA;EACA,IAAIH,IAAI,CAACK,IAAI,CAACD,GAAG,CAAC,OAAO,CAAC,IAAIJ,IAAI,CAACK,IAAI,CAACD,GAAG,CAAC,MAAM,CAAC,EAAE;IACnD,OAAO,KAAK;EACd;EACA,IAAIP,KAAK,CAACC,CAAC,GAAG,CAAC,CAAC,EAAE;IAChB,IAAIQ,QAAQ,GAAGT,KAAK,CAACC,CAAC,GAAG,CAAC,CAAC;IAC3B;IACA,IAAIQ,QAAQ,CAACD,IAAI,CAACD,GAAG,CAAC,MAAM,CAAC,IAAIH,SAAS,CAACG,GAAG,CAACE,QAAQ,CAACH,MAAM,CAAC,EAAE;MAC/D,OAAO,KAAK;IACd;IACA;IACA,IAAIG,QAAQ,CAACD,IAAI,CAACD,GAAG,CAAC,WAAW,CAAC,IAAIJ,IAAI,CAACK,IAAI,CAACD,GAAG,CAAC,WAAW,CAAC,EAAE;MAChE,OAAO,KAAK;IACd;EACF;EACA;EACA,IAAIG,GAAG,GAAGP,IAAI,CAACG,MAAM;EACrB,IAAII,GAAG,CAACC,MAAM,KAAK,CAAC,IAAID,GAAG,CAACC,MAAM,KAAK,CAAC,IAAID,GAAG,CAACC,MAAM,KAAK,CAAC,EAAE;IAC5D,IAAIT,KAAK,CAACU,IAAI,CAACF,GAAG,CAAC,EAAE;MACnB,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA,MAAMG,UAAU,GAAG,SAAAA,CAAUC,QAAQ,EAAE;EACrC,MAAMC,SAAS,GAAG,OAAO;EACzB,IAAIC,GAAG,GAAG,EAAE;EACZF,QAAQ,CAACG,OAAO,CAACjB,KAAK,IAAI;IACxB,IAAIkB,KAAK,GAAG,CAAC;IACblB,KAAK,CAACiB,OAAO,CAAC,CAACd,IAAI,EAAEF,CAAC,KAAK;MACzB;MACA,IAAIc,SAAS,CAACH,IAAI,CAACT,IAAI,CAACgB,IAAI,CAAC,IAAIpB,OAAO,CAACC,KAAK,EAAEC,CAAC,GAAG,CAAC,CAAC,EAAE;QACtDe,GAAG,CAACI,IAAI,CAACpB,KAAK,CAACqB,KAAK,CAACH,KAAK,EAAEjB,CAAC,GAAG,CAAC,CAAC,CAAC;QACnCiB,KAAK,GAAGjB,CAAC,GAAG,CAAC;MACf;IACF,CAAC,CAAC;IACF,IAAIiB,KAAK,GAAGlB,KAAK,CAACW,MAAM,EAAE;MACxBK,GAAG,CAACI,IAAI,CAACpB,KAAK,CAACqB,KAAK,CAACH,KAAK,EAAElB,KAAK,CAACW,MAAM,CAAC,CAAC;IAC5C;EACF,CAAC,CAAC;EACF,OAAOK,GAAG;AACZ,CAAC;AAED,eAAeH,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}