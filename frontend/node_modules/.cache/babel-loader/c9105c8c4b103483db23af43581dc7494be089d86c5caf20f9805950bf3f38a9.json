{"ast":null,"code":"import doRules from './lib.js';\nconst suffixes = [null, {\n  y: 'ily'\n}, {\n  ly: 'ly',\n  //unchanged\n  ic: 'ically'\n}, {\n  ial: 'ially',\n  ual: 'ually',\n  tle: 'tly',\n  ble: 'bly',\n  ple: 'ply',\n  ary: 'arily'\n}, {}, {}, {}];\nconst exceptions = {\n  cool: 'cooly',\n  whole: 'wholly',\n  full: 'fully',\n  good: 'well',\n  idle: 'idly',\n  public: 'publicly',\n  single: 'singly',\n  special: 'especially'\n};\n\n// a lot of adjectives *don't really* have a adverb\n// 'roomy' -> 'roomily'\n// but here, conjugate what it would be, if it made sense to\nconst toAdverb = function (str) {\n  if (exceptions.hasOwnProperty(str)) {\n    return exceptions[str];\n  }\n  let adv = doRules(str, suffixes);\n  if (!adv) {\n    adv = str + 'ly';\n  }\n  // only return this if it exists in lexicon?\n  // console.log(model.one.lexicon[adv])\n  return adv;\n};\nexport default toAdverb;\n// console.log(toAdverb('unsightly'))","map":{"version":3,"names":["doRules","suffixes","y","ly","ic","ial","ual","tle","ble","ple","ary","exceptions","cool","whole","full","good","idle","public","single","special","toAdverb","str","hasOwnProperty","adv"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/toAdverb.js"],"sourcesContent":["import doRules from './lib.js'\n\nconst suffixes = [\n  null,\n  {\n    y: 'ily'\n  },\n  {\n    ly: 'ly',//unchanged\n    ic: 'ically'\n  },\n  {\n    ial: 'ially',\n    ual: 'ually',\n    tle: 'tly',\n    ble: 'bly',\n    ple: 'ply',\n    ary: 'arily',\n  },\n  {},\n  {},\n  {},\n]\n\nconst exceptions = {\n  cool: 'cooly',\n  whole: 'wholly',\n  full: 'fully',\n  good: 'well',\n  idle: 'idly',\n  public: 'publicly',\n  single: 'singly',\n  special: 'especially',\n}\n\n// a lot of adjectives *don't really* have a adverb\n// 'roomy' -> 'roomily'\n// but here, conjugate what it would be, if it made sense to\nconst toAdverb = function (str) {\n  if (exceptions.hasOwnProperty(str)) {\n    return exceptions[str]\n  }\n  let adv = doRules(str, suffixes)\n  if (!adv) {\n    adv = str + 'ly'\n  }\n  // only return this if it exists in lexicon?\n  // console.log(model.one.lexicon[adv])\n  return adv\n}\nexport default toAdverb\n// console.log(toAdverb('unsightly'))"],"mappings":"AAAA,OAAOA,OAAO,MAAM,UAAU;AAE9B,MAAMC,QAAQ,GAAG,CACf,IAAI,EACJ;EACEC,CAAC,EAAE;AACL,CAAC,EACD;EACEC,EAAE,EAAE,IAAI;EAAC;EACTC,EAAE,EAAE;AACN,CAAC,EACD;EACEC,GAAG,EAAE,OAAO;EACZC,GAAG,EAAE,OAAO;EACZC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE;AACP,CAAC,EACD,CAAC,CAAC,EACF,CAAC,CAAC,EACF,CAAC,CAAC,CACH;AAED,MAAMC,UAAU,GAAG;EACjBC,IAAI,EAAE,OAAO;EACbC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,OAAO;EACbC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,UAAU;EAClBC,MAAM,EAAE,QAAQ;EAChBC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,SAAAA,CAAUC,GAAG,EAAE;EAC9B,IAAIV,UAAU,CAACW,cAAc,CAACD,GAAG,CAAC,EAAE;IAClC,OAAOV,UAAU,CAACU,GAAG,CAAC;EACxB;EACA,IAAIE,GAAG,GAAGvB,OAAO,CAACqB,GAAG,EAAEpB,QAAQ,CAAC;EAChC,IAAI,CAACsB,GAAG,EAAE;IACRA,GAAG,GAAGF,GAAG,GAAG,IAAI;EAClB;EACA;EACA;EACA,OAAOE,GAAG;AACZ,CAAC;AACD,eAAeH,QAAQ;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}