{"ast":null,"code":"// name any [unnamed] capture-groups with a number\nconst nameGroups = function (regs) {\n  let index = 0;\n  let inGroup = null;\n  //'fill in' capture groups between start-end\n  for (let i = 0; i < regs.length; i++) {\n    const token = regs[i];\n    if (token.groupStart === true) {\n      inGroup = token.group;\n      if (inGroup === null) {\n        inGroup = String(index);\n        index += 1;\n      }\n    }\n    if (inGroup !== null) {\n      token.group = inGroup;\n    }\n    if (token.groupEnd === true) {\n      inGroup = null;\n    }\n  }\n  return regs;\n};\n\n// optimize an 'or' lookup, when the (a|b|c) list is simple or multi-word\nconst doFastOrMode = function (tokens) {\n  return tokens.map(token => {\n    if (token.choices !== undefined) {\n      // make sure it's an OR\n      if (token.operator !== 'or') {\n        return token;\n      }\n      if (token.fuzzy === true) {\n        return token;\n      }\n      // are they all straight-up words? then optimize them.\n      let shouldPack = token.choices.every(block => {\n        if (block.length !== 1) {\n          return false;\n        }\n        let reg = block[0];\n        // ~fuzzy~ words need more care\n        if (reg.fuzzy === true) {\n          return false;\n        }\n        // ^ and $ get lost in fastOr\n        if (reg.start || reg.end) {\n          return false;\n        }\n        if (reg.word !== undefined && reg.negative !== true && reg.optional !== true && reg.method !== true) {\n          return true; //reg is simple-enough\n        }\n        return false;\n      });\n      if (shouldPack === true) {\n        token.fastOr = new Set();\n        token.choices.forEach(block => {\n          token.fastOr.add(block[0].word);\n        });\n        delete token.choices;\n      }\n    }\n    return token;\n  });\n};\n\n// support ~(a|b|c)~\nconst fuzzyOr = function (regs) {\n  return regs.map(reg => {\n    if (reg.fuzzy && reg.choices) {\n      // pass fuzzy-data to each OR choice\n      reg.choices.forEach(r => {\n        if (r.length === 1 && r[0].word) {\n          r[0].fuzzy = true;\n          r[0].min = reg.min;\n        }\n      });\n    }\n    return reg;\n  });\n};\nconst postProcess = function (regs) {\n  // ensure all capture groups names are filled between start and end\n  regs = nameGroups(regs);\n  // convert 'choices' format to 'fastOr' format\n  regs = doFastOrMode(regs);\n  // support ~(foo|bar)~\n  regs = fuzzyOr(regs);\n  return regs;\n};\nexport default postProcess;","map":{"version":3,"names":["nameGroups","regs","index","inGroup","i","length","token","groupStart","group","String","groupEnd","doFastOrMode","tokens","map","choices","undefined","operator","fuzzy","shouldPack","every","block","reg","start","end","word","negative","optional","method","fastOr","Set","forEach","add","fuzzyOr","r","min","postProcess"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/parseMatch/05-postProcess.js"],"sourcesContent":["// name any [unnamed] capture-groups with a number\nconst nameGroups = function (regs) {\n  let index = 0\n  let inGroup = null\n  //'fill in' capture groups between start-end\n  for (let i = 0; i < regs.length; i++) {\n    const token = regs[i]\n    if (token.groupStart === true) {\n      inGroup = token.group\n      if (inGroup === null) {\n        inGroup = String(index)\n        index += 1\n      }\n    }\n    if (inGroup !== null) {\n      token.group = inGroup\n    }\n    if (token.groupEnd === true) {\n      inGroup = null\n    }\n  }\n  return regs\n}\n\n// optimize an 'or' lookup, when the (a|b|c) list is simple or multi-word\nconst doFastOrMode = function (tokens) {\n  return tokens.map(token => {\n    if (token.choices !== undefined) {\n      // make sure it's an OR\n      if (token.operator !== 'or') {\n        return token\n      }\n      if (token.fuzzy === true) {\n        return token\n      }\n      // are they all straight-up words? then optimize them.\n      let shouldPack = token.choices.every(block => {\n        if (block.length !== 1) {\n          return false\n        }\n        let reg = block[0]\n        // ~fuzzy~ words need more care\n        if (reg.fuzzy === true) {\n          return false\n        }\n        // ^ and $ get lost in fastOr\n        if (reg.start || reg.end) {\n          return false\n        }\n        if (reg.word !== undefined && reg.negative !== true && reg.optional !== true && reg.method !== true) {\n          return true //reg is simple-enough\n        }\n        return false\n      })\n      if (shouldPack === true) {\n        token.fastOr = new Set()\n        token.choices.forEach(block => {\n          token.fastOr.add(block[0].word)\n        })\n        delete token.choices\n      }\n    }\n    return token\n  })\n}\n\n// support ~(a|b|c)~\nconst fuzzyOr = function (regs) {\n  return regs.map(reg => {\n    if (reg.fuzzy && reg.choices) {\n      // pass fuzzy-data to each OR choice\n      reg.choices.forEach(r => {\n        if (r.length === 1 && r[0].word) {\n          r[0].fuzzy = true\n          r[0].min = reg.min\n        }\n      })\n    }\n    return reg\n  })\n}\n\nconst postProcess = function (regs) {\n  // ensure all capture groups names are filled between start and end\n  regs = nameGroups(regs)\n  // convert 'choices' format to 'fastOr' format\n  regs = doFastOrMode(regs)\n  // support ~(foo|bar)~\n  regs = fuzzyOr(regs)\n  return regs\n}\nexport default postProcess\n"],"mappings":"AAAA;AACA,MAAMA,UAAU,GAAG,SAAAA,CAAUC,IAAI,EAAE;EACjC,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,OAAO,GAAG,IAAI;EAClB;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,MAAME,KAAK,GAAGL,IAAI,CAACG,CAAC,CAAC;IACrB,IAAIE,KAAK,CAACC,UAAU,KAAK,IAAI,EAAE;MAC7BJ,OAAO,GAAGG,KAAK,CAACE,KAAK;MACrB,IAAIL,OAAO,KAAK,IAAI,EAAE;QACpBA,OAAO,GAAGM,MAAM,CAACP,KAAK,CAAC;QACvBA,KAAK,IAAI,CAAC;MACZ;IACF;IACA,IAAIC,OAAO,KAAK,IAAI,EAAE;MACpBG,KAAK,CAACE,KAAK,GAAGL,OAAO;IACvB;IACA,IAAIG,KAAK,CAACI,QAAQ,KAAK,IAAI,EAAE;MAC3BP,OAAO,GAAG,IAAI;IAChB;EACF;EACA,OAAOF,IAAI;AACb,CAAC;;AAED;AACA,MAAMU,YAAY,GAAG,SAAAA,CAAUC,MAAM,EAAE;EACrC,OAAOA,MAAM,CAACC,GAAG,CAACP,KAAK,IAAI;IACzB,IAAIA,KAAK,CAACQ,OAAO,KAAKC,SAAS,EAAE;MAC/B;MACA,IAAIT,KAAK,CAACU,QAAQ,KAAK,IAAI,EAAE;QAC3B,OAAOV,KAAK;MACd;MACA,IAAIA,KAAK,CAACW,KAAK,KAAK,IAAI,EAAE;QACxB,OAAOX,KAAK;MACd;MACA;MACA,IAAIY,UAAU,GAAGZ,KAAK,CAACQ,OAAO,CAACK,KAAK,CAACC,KAAK,IAAI;QAC5C,IAAIA,KAAK,CAACf,MAAM,KAAK,CAAC,EAAE;UACtB,OAAO,KAAK;QACd;QACA,IAAIgB,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC;QAClB;QACA,IAAIC,GAAG,CAACJ,KAAK,KAAK,IAAI,EAAE;UACtB,OAAO,KAAK;QACd;QACA;QACA,IAAII,GAAG,CAACC,KAAK,IAAID,GAAG,CAACE,GAAG,EAAE;UACxB,OAAO,KAAK;QACd;QACA,IAAIF,GAAG,CAACG,IAAI,KAAKT,SAAS,IAAIM,GAAG,CAACI,QAAQ,KAAK,IAAI,IAAIJ,GAAG,CAACK,QAAQ,KAAK,IAAI,IAAIL,GAAG,CAACM,MAAM,KAAK,IAAI,EAAE;UACnG,OAAO,IAAI,EAAC;QACd;QACA,OAAO,KAAK;MACd,CAAC,CAAC;MACF,IAAIT,UAAU,KAAK,IAAI,EAAE;QACvBZ,KAAK,CAACsB,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;QACxBvB,KAAK,CAACQ,OAAO,CAACgB,OAAO,CAACV,KAAK,IAAI;UAC7Bd,KAAK,CAACsB,MAAM,CAACG,GAAG,CAACX,KAAK,CAAC,CAAC,CAAC,CAACI,IAAI,CAAC;QACjC,CAAC,CAAC;QACF,OAAOlB,KAAK,CAACQ,OAAO;MACtB;IACF;IACA,OAAOR,KAAK;EACd,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,MAAM0B,OAAO,GAAG,SAAAA,CAAU/B,IAAI,EAAE;EAC9B,OAAOA,IAAI,CAACY,GAAG,CAACQ,GAAG,IAAI;IACrB,IAAIA,GAAG,CAACJ,KAAK,IAAII,GAAG,CAACP,OAAO,EAAE;MAC5B;MACAO,GAAG,CAACP,OAAO,CAACgB,OAAO,CAACG,CAAC,IAAI;QACvB,IAAIA,CAAC,CAAC5B,MAAM,KAAK,CAAC,IAAI4B,CAAC,CAAC,CAAC,CAAC,CAACT,IAAI,EAAE;UAC/BS,CAAC,CAAC,CAAC,CAAC,CAAChB,KAAK,GAAG,IAAI;UACjBgB,CAAC,CAAC,CAAC,CAAC,CAACC,GAAG,GAAGb,GAAG,CAACa,GAAG;QACpB;MACF,CAAC,CAAC;IACJ;IACA,OAAOb,GAAG;EACZ,CAAC,CAAC;AACJ,CAAC;AAED,MAAMc,WAAW,GAAG,SAAAA,CAAUlC,IAAI,EAAE;EAClC;EACAA,IAAI,GAAGD,UAAU,CAACC,IAAI,CAAC;EACvB;EACAA,IAAI,GAAGU,YAAY,CAACV,IAAI,CAAC;EACzB;EACAA,IAAI,GAAG+B,OAAO,CAAC/B,IAAI,CAAC;EACpB,OAAOA,IAAI;AACb,CAAC;AACD,eAAekC,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}