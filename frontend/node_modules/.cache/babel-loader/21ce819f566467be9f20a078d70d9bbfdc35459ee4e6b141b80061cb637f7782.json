{"ast":null,"code":"import doesMatch from '../../term/doesMatch.js';\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\nexport const doOrBlock = function (state, skipN = 0) {\n  let block = state.regs[state.r];\n  let wasFound = false;\n  // do each multiword sequence\n  for (let c = 0; c < block.choices.length; c += 1) {\n    // try to match this list of tokens\n    let regs = block.choices[c];\n    if (!isArray(regs)) {\n      return false;\n    }\n    wasFound = regs.every((cr, w_index) => {\n      let extra = 0;\n      let t = state.t + w_index + skipN + extra;\n      if (state.terms[t] === undefined) {\n        return false;\n      }\n      let foundBlock = doesMatch(state.terms[t], cr, t + state.start_i, state.phrase_length);\n      // this can be greedy - '(foo+ bar)'\n      if (foundBlock === true && cr.greedy === true) {\n        for (let i = 1; i < state.terms.length; i += 1) {\n          let term = state.terms[t + i];\n          if (term) {\n            let keepGoing = doesMatch(term, cr, state.start_i + i, state.phrase_length);\n            if (keepGoing === true) {\n              extra += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      skipN += extra;\n      return foundBlock;\n    });\n    if (wasFound) {\n      skipN += regs.length;\n      break;\n    }\n  }\n  // we found a match -  is it greedy though?\n  if (wasFound && block.greedy === true) {\n    return doOrBlock(state, skipN); // try it again!\n  }\n  return skipN;\n};\nconst doAndBlock = function (state) {\n  let longest = 0;\n  // all blocks must match, and we return the greediest match\n  let reg = state.regs[state.r];\n  let allDidMatch = reg.choices.every(block => {\n    //  for multi-word blocks, all must match\n    let allWords = block.every((cr, w_index) => {\n      let tryTerm = state.t + w_index;\n      if (state.terms[tryTerm] === undefined) {\n        return false;\n      }\n      return doesMatch(state.terms[tryTerm], cr, tryTerm, state.phrase_length);\n    });\n    if (allWords === true && block.length > longest) {\n      longest = block.length;\n    }\n    return allWords;\n  });\n  if (allDidMatch === true) {\n    // console.log(`doAndBlock ${state.terms[state.t].normal}`)\n    return longest;\n  }\n  return false;\n};\nexport { doAndBlock };","map":{"version":3,"names":["doesMatch","isArray","arr","Object","prototype","toString","call","doOrBlock","state","skipN","block","regs","r","wasFound","c","choices","length","every","cr","w_index","extra","t","terms","undefined","foundBlock","start_i","phrase_length","greedy","i","term","keepGoing","doAndBlock","longest","reg","allDidMatch","allWords","tryTerm"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js"],"sourcesContent":["import doesMatch from '../../term/doesMatch.js'\n\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\nexport const doOrBlock = function (state, skipN = 0) {\n  let block = state.regs[state.r]\n  let wasFound = false\n  // do each multiword sequence\n  for (let c = 0; c < block.choices.length; c += 1) {\n    // try to match this list of tokens\n    let regs = block.choices[c]\n    if (!isArray(regs)) {\n      return false\n    }\n    wasFound = regs.every((cr, w_index) => {\n      let extra = 0\n      let t = state.t + w_index + skipN + extra\n      if (state.terms[t] === undefined) {\n        return false\n      }\n      let foundBlock = doesMatch(state.terms[t], cr, t + state.start_i, state.phrase_length)\n      // this can be greedy - '(foo+ bar)'\n      if (foundBlock === true && cr.greedy === true) {\n        for (let i = 1; i < state.terms.length; i += 1) {\n          let term = state.terms[t + i]\n          if (term) {\n            let keepGoing = doesMatch(term, cr, state.start_i + i, state.phrase_length)\n            if (keepGoing === true) {\n              extra += 1\n            } else {\n              break\n            }\n          }\n        }\n      }\n      skipN += extra\n      return foundBlock\n    })\n    if (wasFound) {\n      skipN += regs.length\n      break\n    }\n  }\n  // we found a match -  is it greedy though?\n  if (wasFound && block.greedy === true) {\n    return doOrBlock(state, skipN) // try it again!\n  }\n  return skipN\n}\n\nconst doAndBlock = function (state) {\n  let longest = 0\n  // all blocks must match, and we return the greediest match\n  let reg = state.regs[state.r]\n  let allDidMatch = reg.choices.every(block => {\n    //  for multi-word blocks, all must match\n    let allWords = block.every((cr, w_index) => {\n      let tryTerm = state.t + w_index\n      if (state.terms[tryTerm] === undefined) {\n        return false\n      }\n      return doesMatch(state.terms[tryTerm], cr, tryTerm, state.phrase_length)\n    })\n    if (allWords === true && block.length > longest) {\n      longest = block.length\n    }\n    return allWords\n  })\n  if (allDidMatch === true) {\n    // console.log(`doAndBlock ${state.terms[state.t].normal}`)\n    return longest\n  }\n  return false\n}\nexport { doAndBlock }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}