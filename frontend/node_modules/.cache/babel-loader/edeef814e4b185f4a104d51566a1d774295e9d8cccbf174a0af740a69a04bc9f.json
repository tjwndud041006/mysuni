{"ast":null,"code":"// do the pointers intersect?\nexport const doesOverlap = function (a, b) {\n  if (a[0] !== b[0]) {\n    return false;\n  }\n  let [, startA, endA] = a;\n  let [, startB, endB] = b;\n  // [a,a,a,-,-,-,]\n  // [-,-,b,b,b,-,]\n  if (startA <= startB && endA > startB) {\n    return true;\n  }\n  // [-,-,-,a,a,-,]\n  // [-,-,b,b,b,-,]\n  if (startB <= startA && endB > startA) {\n    return true;\n  }\n  return false;\n};\n\n// get widest min/max\nexport const getExtent = function (ptrs) {\n  let min = ptrs[0][1];\n  let max = ptrs[0][2];\n  ptrs.forEach(ptr => {\n    if (ptr[1] < min) {\n      min = ptr[1];\n    }\n    if (ptr[2] > max) {\n      max = ptr[2];\n    }\n  });\n  return [ptrs[0][0], min, max];\n};\n\n// collect pointers by sentence number\nexport const indexN = function (ptrs) {\n  let byN = {};\n  ptrs.forEach(ref => {\n    byN[ref[0]] = byN[ref[0]] || [];\n    byN[ref[0]].push(ref);\n  });\n  return byN;\n};\n\n// remove exact duplicates\nexport const uniquePtrs = function (arr) {\n  let obj = {};\n  for (let i = 0; i < arr.length; i += 1) {\n    obj[arr[i].join(',')] = arr[i];\n  }\n  return Object.values(obj);\n};\n\n// a before b\n// console.log(doesOverlap([0, 0, 4], [0, 2, 5]))\n// // b before a\n// console.log(doesOverlap([0, 3, 4], [0, 1, 5]))\n// // disjoint\n// console.log(doesOverlap([0, 0, 3], [0, 4, 5]))\n// neighbours\n// console.log(doesOverlap([0, 1, 3], [0, 3, 5]))\n// console.log(doesOverlap([0, 3, 5], [0, 1, 3]))\n\n// console.log(\n//   getExtent([\n//     [0, 3, 4],\n//     [0, 4, 5],\n//     [0, 1, 2],\n//   ])\n// )","map":{"version":3,"names":["doesOverlap","a","b","startA","endA","startB","endB","getExtent","ptrs","min","max","forEach","ptr","indexN","byN","ref","push","uniquePtrs","arr","obj","i","length","join","Object","values"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/pointers/api/lib/_lib.js"],"sourcesContent":["// do the pointers intersect?\nexport const doesOverlap = function (a, b) {\n  if (a[0] !== b[0]) {\n    return false\n  }\n  let [, startA, endA] = a\n  let [, startB, endB] = b\n  // [a,a,a,-,-,-,]\n  // [-,-,b,b,b,-,]\n  if (startA <= startB && endA > startB) {\n    return true\n  }\n  // [-,-,-,a,a,-,]\n  // [-,-,b,b,b,-,]\n  if (startB <= startA && endB > startA) {\n    return true\n  }\n  return false\n}\n\n// get widest min/max\nexport const getExtent = function (ptrs) {\n  let min = ptrs[0][1]\n  let max = ptrs[0][2]\n  ptrs.forEach(ptr => {\n    if (ptr[1] < min) {\n      min = ptr[1]\n    }\n    if (ptr[2] > max) {\n      max = ptr[2]\n    }\n  })\n  return [ptrs[0][0], min, max]\n}\n\n// collect pointers by sentence number\nexport const indexN = function (ptrs) {\n  let byN = {}\n  ptrs.forEach(ref => {\n    byN[ref[0]] = byN[ref[0]] || []\n    byN[ref[0]].push(ref)\n  })\n  return byN\n}\n\n// remove exact duplicates\nexport const uniquePtrs = function (arr) {\n  let obj = {}\n  for (let i = 0; i < arr.length; i += 1) {\n    obj[arr[i].join(',')] = arr[i]\n  }\n  return Object.values(obj)\n}\n\n// a before b\n// console.log(doesOverlap([0, 0, 4], [0, 2, 5]))\n// // b before a\n// console.log(doesOverlap([0, 3, 4], [0, 1, 5]))\n// // disjoint\n// console.log(doesOverlap([0, 0, 3], [0, 4, 5]))\n// neighbours\n// console.log(doesOverlap([0, 1, 3], [0, 3, 5]))\n// console.log(doesOverlap([0, 3, 5], [0, 1, 3]))\n\n// console.log(\n//   getExtent([\n//     [0, 3, 4],\n//     [0, 4, 5],\n//     [0, 1, 2],\n//   ])\n// )\n"],"mappings":"AAAA;AACA,OAAO,MAAMA,WAAW,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;EACzC,IAAID,CAAC,CAAC,CAAC,CAAC,KAAKC,CAAC,CAAC,CAAC,CAAC,EAAE;IACjB,OAAO,KAAK;EACd;EACA,IAAI,GAAGC,MAAM,EAAEC,IAAI,CAAC,GAAGH,CAAC;EACxB,IAAI,GAAGI,MAAM,EAAEC,IAAI,CAAC,GAAGJ,CAAC;EACxB;EACA;EACA,IAAIC,MAAM,IAAIE,MAAM,IAAID,IAAI,GAAGC,MAAM,EAAE;IACrC,OAAO,IAAI;EACb;EACA;EACA;EACA,IAAIA,MAAM,IAAIF,MAAM,IAAIG,IAAI,GAAGH,MAAM,EAAE;IACrC,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA,OAAO,MAAMI,SAAS,GAAG,SAAAA,CAAUC,IAAI,EAAE;EACvC,IAAIC,GAAG,GAAGD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpB,IAAIE,GAAG,GAAGF,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpBA,IAAI,CAACG,OAAO,CAACC,GAAG,IAAI;IAClB,IAAIA,GAAG,CAAC,CAAC,CAAC,GAAGH,GAAG,EAAE;MAChBA,GAAG,GAAGG,GAAG,CAAC,CAAC,CAAC;IACd;IACA,IAAIA,GAAG,CAAC,CAAC,CAAC,GAAGF,GAAG,EAAE;MAChBA,GAAG,GAAGE,GAAG,CAAC,CAAC,CAAC;IACd;EACF,CAAC,CAAC;EACF,OAAO,CAACJ,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEC,GAAG,EAAEC,GAAG,CAAC;AAC/B,CAAC;;AAED;AACA,OAAO,MAAMG,MAAM,GAAG,SAAAA,CAAUL,IAAI,EAAE;EACpC,IAAIM,GAAG,GAAG,CAAC,CAAC;EACZN,IAAI,CAACG,OAAO,CAACI,GAAG,IAAI;IAClBD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;IAC/BD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACD,GAAG,CAAC;EACvB,CAAC,CAAC;EACF,OAAOD,GAAG;AACZ,CAAC;;AAED;AACA,OAAO,MAAMG,UAAU,GAAG,SAAAA,CAAUC,GAAG,EAAE;EACvC,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACtCD,GAAG,CAACD,GAAG,CAACE,CAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC,GAAGJ,GAAG,CAACE,CAAC,CAAC;EAChC;EACA,OAAOG,MAAM,CAACC,MAAM,CAACL,GAAG,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}