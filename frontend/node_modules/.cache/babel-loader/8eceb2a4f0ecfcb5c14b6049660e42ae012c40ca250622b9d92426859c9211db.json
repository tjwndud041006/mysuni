{"ast":null,"code":"// extract the clear needs for an individual match token\nconst getTokenNeeds = function (reg) {\n  // negatives can't be cached\n  if (reg.optional === true || reg.negative === true) {\n    return null;\n  }\n  if (reg.tag) {\n    return '#' + reg.tag;\n  }\n  if (reg.word) {\n    return reg.word;\n  }\n  if (reg.switch) {\n    return `%${reg.switch}%`;\n  }\n  return null;\n};\nconst getNeeds = function (regs) {\n  let needs = [];\n  regs.forEach(reg => {\n    needs.push(getTokenNeeds(reg));\n    // support AND (foo && tag)\n    if (reg.operator === 'and' && reg.choices) {\n      reg.choices.forEach(oneSide => {\n        oneSide.forEach(r => {\n          needs.push(getTokenNeeds(r));\n        });\n      });\n    }\n  });\n  return needs.filter(str => str);\n};\nconst getWants = function (regs) {\n  let wants = [];\n  let count = 0;\n  regs.forEach(reg => {\n    if (reg.operator === 'or' && !reg.optional && !reg.negative) {\n      // add fast-or terms\n      if (reg.fastOr) {\n        Array.from(reg.fastOr).forEach(w => {\n          wants.push(w);\n        });\n      }\n      // add slow-or\n      if (reg.choices) {\n        reg.choices.forEach(rs => {\n          rs.forEach(r => {\n            let n = getTokenNeeds(r);\n            if (n) {\n              wants.push(n);\n            }\n          });\n        });\n      }\n      count += 1;\n    }\n  });\n  return {\n    wants,\n    count\n  };\n};\nconst parse = function (matches, world) {\n  const parseMatch = world.methods.one.parseMatch;\n  matches.forEach(obj => {\n    obj.regs = parseMatch(obj.match, {}, world);\n    // wrap these ifNo properties into an array\n    if (typeof obj.ifNo === 'string') {\n      obj.ifNo = [obj.ifNo];\n    }\n    if (obj.notIf) {\n      obj.notIf = parseMatch(obj.notIf, {}, world);\n    }\n    // cache any requirements up-front \n    obj.needs = getNeeds(obj.regs);\n    let {\n      wants,\n      count\n    } = getWants(obj.regs);\n    obj.wants = wants;\n    obj.minWant = count;\n    // get rid of tiny sentences\n    obj.minWords = obj.regs.filter(o => !o.optional).length;\n  });\n  return matches;\n};\nexport default parse;","map":{"version":3,"names":["getTokenNeeds","reg","optional","negative","tag","word","switch","getNeeds","regs","needs","forEach","push","operator","choices","oneSide","r","filter","str","getWants","wants","count","fastOr","Array","from","w","rs","n","parse","matches","world","parseMatch","methods","one","obj","match","ifNo","notIf","minWant","minWords","o","length"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/sweep/methods/buildNet/01-parse.js"],"sourcesContent":["// extract the clear needs for an individual match token\nconst getTokenNeeds = function (reg) {\n  // negatives can't be cached\n  if (reg.optional === true || reg.negative === true) {\n    return null\n  }\n  if (reg.tag) {\n    return '#' + reg.tag\n  }\n  if (reg.word) {\n    return reg.word\n  }\n  if (reg.switch) {\n    return `%${reg.switch}%`\n  }\n  return null\n}\n\nconst getNeeds = function (regs) {\n  let needs = []\n  regs.forEach(reg => {\n    needs.push(getTokenNeeds(reg))\n    // support AND (foo && tag)\n    if (reg.operator === 'and' && reg.choices) {\n      reg.choices.forEach(oneSide => {\n        oneSide.forEach(r => {\n          needs.push(getTokenNeeds(r))\n        })\n      })\n    }\n  })\n  return needs.filter(str => str)\n}\n\nconst getWants = function (regs) {\n  let wants = []\n  let count = 0\n  regs.forEach(reg => {\n    if (reg.operator === 'or' && !reg.optional && !reg.negative) {\n      // add fast-or terms\n      if (reg.fastOr) {\n        Array.from(reg.fastOr).forEach(w => {\n          wants.push(w)\n        })\n      }\n      // add slow-or\n      if (reg.choices) {\n        reg.choices.forEach(rs => {\n          rs.forEach(r => {\n            let n = getTokenNeeds(r)\n            if (n) {\n              wants.push(n)\n            }\n          })\n        })\n      }\n      count += 1\n    }\n  })\n  return { wants, count }\n}\n\nconst parse = function (matches, world) {\n  const parseMatch = world.methods.one.parseMatch\n  matches.forEach(obj => {\n    obj.regs = parseMatch(obj.match, {}, world)\n    // wrap these ifNo properties into an array\n    if (typeof obj.ifNo === 'string') {\n      obj.ifNo = [obj.ifNo]\n    }\n    if (obj.notIf) {\n      obj.notIf = parseMatch(obj.notIf, {}, world)\n    }\n    // cache any requirements up-front \n    obj.needs = getNeeds(obj.regs)\n    let { wants, count } = getWants(obj.regs)\n    obj.wants = wants\n    obj.minWant = count\n    // get rid of tiny sentences\n    obj.minWords = obj.regs.filter(o => !o.optional).length\n  })\n  return matches\n}\n\nexport default parse\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}