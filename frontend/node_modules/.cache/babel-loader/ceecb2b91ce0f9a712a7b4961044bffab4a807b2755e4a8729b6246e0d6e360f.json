{"ast":null,"code":"import fns from './fns.js';\nimport pack from './pack.js';\nconst NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|¦]'); //characters banned from entering the trie\n// reserved propery names\nconst internal = {\n  _d: true,\n  _v: true,\n  _c: true,\n  _g: true,\n  _n: true\n};\nconst methods = {\n  // Insert words from one big string, or from an array.\n  insertWords: function (words) {\n    if (words === undefined) {\n      return;\n    }\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/);\n    }\n    for (let i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase();\n    }\n    fns.unique(words);\n    for (let i = 0; i < words.length; i++) {\n      if (words[i].match(NOT_ALLOWED) === null) {\n        this.insert(words[i]);\n      }\n    }\n  },\n  insert: function (word) {\n    this._insert(word, this.root);\n    const lastWord = this.lastWord;\n    this.lastWord = word;\n    const prefix = fns.commonPrefix(word, lastWord);\n    if (prefix === lastWord) {\n      return;\n    }\n    const freeze = this.uniqueNode(lastWord, word, this.root);\n    if (freeze) {\n      this.combineSuffixNode(freeze);\n    }\n  },\n  _insert: function (word, node) {\n    let prefix, next;\n\n    // Duplicate word entry - ignore\n    if (word.length === 0) {\n      return;\n    }\n\n    // Do any existing props share a common prefix?\n    const keys = Object.keys(node);\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i];\n      prefix = fns.commonPrefix(word, prop);\n      if (prefix.length === 0) {\n        continue;\n      }\n      // Prop is a proper prefix - recurse to child node\n      if (prop === prefix && typeof node[prop] === 'object') {\n        this._insert(word.slice(prefix.length), node[prop]);\n        return;\n      }\n      // Duplicate terminal string - ignore\n      if (prop === word && typeof node[prop] === 'number') {\n        return;\n      }\n      next = {};\n      next[prop.slice(prefix.length)] = node[prop];\n      this.addTerminal(next, word = word.slice(prefix.length));\n      delete node[prop];\n      node[prefix] = next;\n      this.wordCount++;\n      return;\n    }\n\n    // No shared prefix.  Enter the word here as a terminal string.\n    this.addTerminal(node, word);\n    this.wordCount++;\n  },\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value == 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal: function (node, prop) {\n    if (prop.length <= 1) {\n      node[prop] = 1;\n      return;\n    }\n    const next = {};\n    node[prop[0]] = next;\n    this.addTerminal(next, prop.slice(1));\n  },\n  // Well ordered list of properties in a node (string or object properties)\n  // Use nodesOnly==true to return only properties of child nodes (not\n  // terminal strings.\n  nodeProps: function (node, nodesOnly) {\n    const props = [];\n    for (const prop in node) {\n      // is it a usuable prop, or a special reserved one?\n      if (prop !== '' && !internal.hasOwnProperty(prop)) {\n        if (!nodesOnly || typeof node[prop] === 'object') {\n          props.push(prop);\n        }\n      }\n    }\n    props.sort();\n    return props;\n  },\n  optimize: function () {\n    this.combineSuffixNode(this.root);\n    this.prepDFS();\n    this.countDegree(this.root);\n    this.prepDFS();\n    this.collapseChains(this.root);\n  },\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode: function (node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node;\n    }\n    // Make sure all children are combined and generate unique node\n    // signature for this node.\n    let sig = [];\n    if (this.isTerminal(node)) {\n      sig.push('!');\n    }\n    const props = this.nodeProps(node);\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (typeof node[prop] === 'object') {\n        node[prop] = this.combineSuffixNode(node[prop]);\n        sig.push(prop);\n        sig.push(node[prop]._c);\n      } else {\n        sig.push(prop);\n      }\n    }\n    sig = sig.join('-');\n    const shared = this.suffixes[sig];\n    if (shared) {\n      return shared;\n    }\n    this.suffixes[sig] = node;\n    node._c = this.cNext++;\n    return node;\n  },\n  prepDFS: function () {\n    this.vCur++;\n  },\n  visited: function (node) {\n    if (node._v === this.vCur) {\n      return true;\n    }\n    node._v = this.vCur;\n    return false;\n  },\n  countDegree: function (node) {\n    if (node._d === undefined) {\n      node._d = 0;\n    }\n    node._d++;\n    if (this.visited(node)) {\n      return;\n    }\n    const props = this.nodeProps(node, true);\n    for (let i = 0; i < props.length; i++) {\n      this.countDegree(node[props[i]]);\n    }\n  },\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains: function (node) {\n    let prop, child, i;\n    if (this.visited(node)) {\n      return;\n    }\n    const props = this.nodeProps(node);\n    for (i = 0; i < props.length; i++) {\n      prop = props[i];\n      child = node[prop];\n      if (typeof child !== 'object') {\n        continue;\n      }\n      this.collapseChains(child);\n      // Hoist the singleton child's single property to the parent\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        delete node[prop];\n        prop += child._g;\n        node[prop] = child[child._g];\n      }\n    }\n    // Identify singleton nodes\n    if (props.length === 1 && !this.isTerminal(node)) {\n      node._g = prop;\n    }\n  },\n  isTerminal: function (node) {\n    return !!node[''];\n  },\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode: function (word, other, node) {\n    const props = this.nodeProps(node, true);\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node[prop];\n        }\n        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop]);\n      }\n    }\n    return undefined;\n  },\n  pack: function () {\n    return pack(this);\n  }\n};\nexport default methods;","map":{"version":3,"names":["fns","pack","NOT_ALLOWED","RegExp","internal","_d","_v","_c","_g","_n","methods","insertWords","words","undefined","split","i","length","toLowerCase","unique","match","insert","word","_insert","root","lastWord","prefix","commonPrefix","freeze","uniqueNode","combineSuffixNode","node","next","keys","Object","prop","slice","addTerminal","wordCount","nodeProps","nodesOnly","props","hasOwnProperty","push","sort","optimize","prepDFS","countDegree","collapseChains","sig","isTerminal","join","shared","suffixes","cNext","vCur","visited","child","other"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/efrt/src/pack/methods.js"],"sourcesContent":["import fns from './fns.js'\nimport pack from './pack.js'\nconst NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|¦]') //characters banned from entering the trie\n// reserved propery names\nconst internal = {\n  _d: true,\n  _v: true,\n  _c: true,\n  _g: true,\n  _n: true,\n}\n\nconst methods = {\n  // Insert words from one big string, or from an array.\n  insertWords: function (words) {\n    if (words === undefined) {\n      return\n    }\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/)\n    }\n    for (let i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase()\n    }\n    fns.unique(words)\n    for (let i = 0; i < words.length; i++) {\n      if (words[i].match(NOT_ALLOWED) === null) {\n        this.insert(words[i])\n      }\n    }\n  },\n\n  insert: function (word) {\n    this._insert(word, this.root)\n    const lastWord = this.lastWord\n    this.lastWord = word\n\n    const prefix = fns.commonPrefix(word, lastWord)\n    if (prefix === lastWord) {\n      return\n    }\n\n    const freeze = this.uniqueNode(lastWord, word, this.root)\n    if (freeze) {\n      this.combineSuffixNode(freeze)\n    }\n  },\n\n  _insert: function (word, node) {\n    let prefix, next\n\n    // Duplicate word entry - ignore\n    if (word.length === 0) {\n      return\n    }\n\n    // Do any existing props share a common prefix?\n    const keys = Object.keys(node)\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i]\n      prefix = fns.commonPrefix(word, prop)\n      if (prefix.length === 0) {\n        continue\n      }\n      // Prop is a proper prefix - recurse to child node\n      if (prop === prefix && typeof node[prop] === 'object') {\n        this._insert(word.slice(prefix.length), node[prop])\n        return\n      }\n      // Duplicate terminal string - ignore\n      if (prop === word && typeof node[prop] === 'number') {\n        return\n      }\n      next = {}\n      next[prop.slice(prefix.length)] = node[prop]\n      this.addTerminal(next, word = word.slice(prefix.length))\n      delete node[prop]\n      node[prefix] = next\n      this.wordCount++\n      return\n    }\n\n    // No shared prefix.  Enter the word here as a terminal string.\n    this.addTerminal(node, word)\n    this.wordCount++\n  },\n\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value == 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal: function (node, prop) {\n    if (prop.length <= 1) {\n      node[prop] = 1\n      return\n    }\n    const next = {}\n    node[prop[0]] = next\n    this.addTerminal(next, prop.slice(1))\n  },\n\n  // Well ordered list of properties in a node (string or object properties)\n  // Use nodesOnly==true to return only properties of child nodes (not\n  // terminal strings.\n  nodeProps: function (node, nodesOnly) {\n    const props = []\n    for (const prop in node) {\n      // is it a usuable prop, or a special reserved one?\n      if (prop !== '' && !internal.hasOwnProperty(prop)) {\n        if (!nodesOnly || typeof node[prop] === 'object') {\n          props.push(prop)\n        }\n      }\n    }\n    props.sort()\n    return props\n  },\n\n  optimize: function () {\n    this.combineSuffixNode(this.root)\n    this.prepDFS()\n    this.countDegree(this.root)\n    this.prepDFS()\n    this.collapseChains(this.root)\n  },\n\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode: function (node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node\n    }\n    // Make sure all children are combined and generate unique node\n    // signature for this node.\n    let sig = []\n    if (this.isTerminal(node)) {\n      sig.push('!')\n    }\n    const props = this.nodeProps(node)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (typeof node[prop] === 'object') {\n        node[prop] = this.combineSuffixNode(node[prop])\n        sig.push(prop)\n        sig.push(node[prop]._c)\n      } else {\n        sig.push(prop)\n      }\n    }\n    sig = sig.join('-')\n\n    const shared = this.suffixes[sig]\n    if (shared) {\n      return shared\n    }\n    this.suffixes[sig] = node\n    node._c = this.cNext++\n    return node\n  },\n\n  prepDFS: function () {\n    this.vCur++\n  },\n\n  visited: function (node) {\n    if (node._v === this.vCur) {\n      return true\n    }\n    node._v = this.vCur\n    return false\n  },\n\n  countDegree: function (node) {\n    if (node._d === undefined) {\n      node._d = 0\n    }\n    node._d++\n    if (this.visited(node)) {\n      return\n    }\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      this.countDegree(node[props[i]])\n    }\n  },\n\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains: function (node) {\n    let prop, child, i\n    if (this.visited(node)) {\n      return\n    }\n    const props = this.nodeProps(node)\n    for (i = 0; i < props.length; i++) {\n      prop = props[i]\n      child = node[prop]\n      if (typeof child !== 'object') {\n        continue\n      }\n      this.collapseChains(child)\n      // Hoist the singleton child's single property to the parent\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        delete node[prop]\n        prop += child._g\n        node[prop] = child[child._g]\n      }\n    }\n    // Identify singleton nodes\n    if (props.length === 1 && !this.isTerminal(node)) {\n      node._g = prop\n    }\n  },\n\n  isTerminal: function (node) {\n    return !!node['']\n  },\n\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode: function (word, other, node) {\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node[prop]\n        }\n        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop])\n      }\n    }\n    return undefined\n  },\n\n  pack: function () {\n    return pack(this)\n  }\n}\nexport default methods\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}