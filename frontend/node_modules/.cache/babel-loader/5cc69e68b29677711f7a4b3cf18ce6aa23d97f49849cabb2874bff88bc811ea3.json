{"ast":null,"code":"import getSubject from './parse/getSubject.js';\nconst noop = vb => vb;\nconst isPlural = (vb, parsed) => {\n  let subj = getSubject(vb, parsed);\n  let m = subj.subject;\n  if (m.has('i') || m.has('we')) {\n    return true;\n  }\n  return subj.plural;\n};\nconst wasWere = (vb, parsed) => {\n  let {\n    subject,\n    plural\n  } = getSubject(vb, parsed);\n  if (plural || subject.has('we')) {\n    return 'were';\n  }\n  return 'was';\n};\n\n// present-tense copula\nconst isAreAm = function (vb, parsed) {\n  // 'people were' -> 'people are'\n  if (vb.has('were')) {\n    return 'are';\n  }\n  // 'i was' -> i am\n  let {\n    subject,\n    plural\n  } = getSubject(vb, parsed);\n  if (subject.has('i')) {\n    return 'am';\n  }\n  if (subject.has('we') || plural) {\n    return 'are';\n  }\n  // 'he was' -> he is\n  return 'is';\n};\nconst doDoes = function (vb, parsed) {\n  let subj = getSubject(vb, parsed);\n  let m = subj.subject;\n  if (m.has('i') || m.has('we')) {\n    return 'do';\n  }\n  if (subj.plural) {\n    return 'do';\n  }\n  return 'does';\n};\nconst getTense = function (m) {\n  if (m.has('#Infinitive')) {\n    return 'Infinitive';\n  }\n  if (m.has('#Participle')) {\n    return 'Participle';\n  }\n  if (m.has('#PastTense')) {\n    return 'PastTense';\n  }\n  if (m.has('#Gerund')) {\n    return 'Gerund';\n  }\n  if (m.has('#PresentTense')) {\n    return 'PresentTense';\n  }\n  return undefined;\n};\nconst toInf = function (vb, parsed) {\n  const {\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  let str = parsed.root.text({\n    keepPunct: false\n  });\n  str = toInfinitive(str, vb.model, getTense(vb));\n  if (str) {\n    vb.replace(parsed.root, str);\n  }\n  return vb;\n};\n\n// i will start looking -> i started looking\n// i will not start looking -> i did not start looking\nconst noWill = vb => {\n  if (vb.has('will not')) {\n    return vb.replace('will not', 'have not');\n  }\n  return vb.remove('will');\n};\nexport { noop, isPlural, isAreAm, doDoes, toInf, getSubject, getTense, wasWere, noWill };","map":{"version":3,"names":["getSubject","noop","vb","isPlural","parsed","subj","m","subject","has","plural","wasWere","isAreAm","doDoes","getTense","undefined","toInf","toInfinitive","methods","two","transform","verb","str","root","text","keepPunct","model","replace","noWill","remove"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/lib.js"],"sourcesContent":["import getSubject from './parse/getSubject.js'\n\nconst noop = vb => vb\n\nconst isPlural = (vb, parsed) => {\n  let subj = getSubject(vb, parsed)\n  let m = subj.subject\n  if (m.has('i') || m.has('we')) {\n    return true\n  }\n  return subj.plural\n}\n\nconst wasWere = (vb, parsed) => {\n  let { subject, plural } = getSubject(vb, parsed)\n  if (plural || subject.has('we')) {\n    return 'were'\n  }\n  return 'was'\n}\n\n// present-tense copula\nconst isAreAm = function (vb, parsed) {\n  // 'people were' -> 'people are'\n  if (vb.has('were')) {\n    return 'are'\n  }\n  // 'i was' -> i am\n  let { subject, plural } = getSubject(vb, parsed)\n  if (subject.has('i')) {\n    return 'am'\n  }\n  if (subject.has('we') || plural) {\n    return 'are'\n  }\n  // 'he was' -> he is\n  return 'is'\n}\n\n\nconst doDoes = function (vb, parsed) {\n  let subj = getSubject(vb, parsed)\n  let m = subj.subject\n  if (m.has('i') || m.has('we')) {\n    return 'do'\n  }\n  if (subj.plural) {\n    return 'do'\n  }\n  return 'does'\n}\n\nconst getTense = function (m) {\n  if (m.has('#Infinitive')) {\n    return 'Infinitive'\n  }\n  if (m.has('#Participle')) {\n    return 'Participle'\n  }\n  if (m.has('#PastTense')) {\n    return 'PastTense'\n  }\n  if (m.has('#Gerund')) {\n    return 'Gerund'\n  }\n  if (m.has('#PresentTense')) {\n    return 'PresentTense'\n  }\n  return undefined\n}\n\nconst toInf = function (vb, parsed) {\n  const { toInfinitive } = vb.methods.two.transform.verb\n  let str = parsed.root.text({ keepPunct: false })\n  str = toInfinitive(str, vb.model, getTense(vb))\n  if (str) {\n    vb.replace(parsed.root, str)\n  }\n  return vb\n}\n\n\n\n// i will start looking -> i started looking\n// i will not start looking -> i did not start looking\nconst noWill = (vb) => {\n  if (vb.has('will not')) {\n    return vb.replace('will not', 'have not')\n  }\n  return vb.remove('will')\n}\n\nexport { noop, isPlural, isAreAm, doDoes, toInf, getSubject, getTense, wasWere, noWill }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}