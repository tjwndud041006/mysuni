{"ast":null,"code":"import { noop, getTense, wasWere, noWill } from '../lib.js';\nconst keep = {\n  tags: true\n};\nconst fns = {\n  noAux: (vb, parsed) => {\n    if (parsed.auxiliary.found) {\n      vb = vb.remove(parsed.auxiliary);\n    }\n    return vb;\n  },\n  // walk->walked\n  simple: (vb, parsed) => {\n    const {\n      conjugate,\n      toInfinitive\n    } = vb.methods.two.transform.verb;\n    const root = parsed.root;\n    // 'i may'\n    if (root.has('#Modal')) {\n      return vb;\n    }\n    let str = root.text({\n      keepPunct: false\n    });\n    str = toInfinitive(str, vb.model, getTense(root));\n    let all = conjugate(str, vb.model);\n    // 'driven' || 'drove'\n    str = all.PastTense;\n    // all.Participle || all.PastTense\n    // but skip the 'is' participle..\n    str = str === 'been' ? 'was' : str;\n    if (str === 'was') {\n      str = wasWere(vb, parsed);\n    }\n    if (str) {\n      vb.replace(root, str, keep);\n    }\n    return vb;\n  },\n  both: function (vb, parsed) {\n    // 'he did not walk'\n    if (parsed.negative.found) {\n      vb.replace('will', 'did');\n      return vb;\n    }\n    // 'he walked'\n    vb = fns.simple(vb, parsed);\n    vb = fns.noAux(vb, parsed);\n    return vb;\n  },\n  hasHad: vb => {\n    vb.replace('has', 'had', keep);\n    return vb;\n  },\n  // some verbs have this weird past-tense form\n  // drive -> driven, (!drove)\n  hasParticiple: (vb, parsed) => {\n    const {\n      conjugate,\n      toInfinitive\n    } = vb.methods.two.transform.verb;\n    const root = parsed.root;\n    let str = root.text('normal');\n    str = toInfinitive(str, vb.model, getTense(root));\n    return conjugate(str, vb.model).Participle;\n  }\n};\nconst forms = {\n  // walk -> walked\n  'infinitive': fns.simple,\n  // he walks -> he walked\n  'simple-present': fns.simple,\n  // he walked\n  'simple-past': noop,\n  // he will walk -> he walked\n  'simple-future': fns.both,\n  // he is walking\n  'present-progressive': vb => {\n    vb.replace('are', 'were', keep);\n    vb.replace('(is|are|am)', 'was', keep);\n    return vb;\n  },\n  // he was walking\n  'past-progressive': noop,\n  // he will be walking\n  'future-progressive': (vb, parsed) => {\n    vb.match(parsed.root).insertBefore('was');\n    vb.remove('(will|be)');\n    return vb;\n  },\n  // has walked -> had walked (?)\n  'present-perfect': fns.hasHad,\n  // had walked\n  'past-perfect': noop,\n  // will have walked -> had walked\n  'future-perfect': (vb, parsed) => {\n    vb.match(parsed.root).insertBefore('had');\n    if (vb.has('will')) {\n      vb = noWill(vb);\n    }\n    vb.remove('have');\n    return vb;\n  },\n  // has been walking -> had been\n  'present-perfect-progressive': fns.hasHad,\n  // had been walking\n  'past-perfect-progressive': noop,\n  // will have been -> had\n  'future-perfect-progressive': vb => {\n    vb.remove('will');\n    vb.replace('have', 'had', keep);\n    return vb;\n  },\n  // got walked\n  'passive-past': vb => {\n    // 'have been walked' -> 'had been walked'\n    vb.replace('have', 'had', keep);\n    return vb;\n  },\n  // is being walked  -> 'was being walked'\n  'passive-present': vb => {\n    vb.replace('(is|are)', 'was', keep);\n    return vb;\n  },\n  // will be walked -> had been walked\n  'passive-future': (vb, parsed) => {\n    if (parsed.auxiliary.has('will be')) {\n      vb.match(parsed.root).insertBefore('had been');\n      vb.remove('(will|be)');\n    }\n    // will have been walked -> had been walked\n    if (parsed.auxiliary.has('will have been')) {\n      vb.replace('have', 'had', keep);\n      vb.remove('will');\n    }\n    return vb;\n  },\n  // would be walked -> 'would have been walked'\n  'present-conditional': vb => {\n    vb.replace('be', 'have been');\n    return vb;\n  },\n  // would have been walked\n  'past-conditional': noop,\n  // is going to drink -> was going to drink\n  'auxiliary-future': vb => {\n    vb.replace('(is|are|am)', 'was', keep);\n    return vb;\n  },\n  // used to walk\n  'auxiliary-past': noop,\n  // we do walk -> we did walk\n  'auxiliary-present': vb => {\n    vb.replace('(do|does)', 'did', keep);\n    return vb;\n  },\n  // must walk -> 'must have walked'\n  'modal-infinitive': (vb, parsed) => {\n    // this modal has a clear tense\n    if (vb.has('can')) {\n      // can drive -> could drive\n      vb.replace('can', 'could', keep);\n    } else {\n      // otherwise, \n      //  walk -> have walked\n      //  drive -> have driven\n      fns.simple(vb, parsed);\n      vb.match('#Modal').insertAfter('have').tag('Auxiliary');\n    }\n    return vb;\n  },\n  // must have walked\n  'modal-past': noop,\n  // wanted to walk\n  'want-infinitive': vb => {\n    vb.replace('(want|wants)', 'wanted', keep);\n    vb.remove('will');\n    return vb;\n  },\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$');\n    fns.simple(vb, parsed);\n    noWill(vb);\n    return vb;\n  }\n};\nconst toPast = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed);\n    vb.fullSentence().compute(['tagger', 'chunks']);\n    return vb;\n  }\n  // do nothing i guess?\n  return vb;\n};\nexport default toPast;","map":{"version":3,"names":["noop","getTense","wasWere","noWill","keep","tags","fns","noAux","vb","parsed","auxiliary","found","remove","simple","conjugate","toInfinitive","methods","two","transform","verb","root","has","str","text","keepPunct","model","all","PastTense","replace","both","negative","hasHad","hasParticiple","Participle","forms","future-progressive","match","insertBefore","future-perfect","passive-future","modal-infinitive","insertAfter","tag","gerund-phrase","not","toPast","form","hasOwnProperty","fullSentence","compute"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toPast.js"],"sourcesContent":["import { noop, getTense, wasWere, noWill } from '../lib.js'\nconst keep = { tags: true }\n\nconst fns = {\n\n  noAux: (vb, parsed) => {\n    if (parsed.auxiliary.found) {\n      vb = vb.remove(parsed.auxiliary)\n    }\n    return vb\n  },\n\n  // walk->walked\n  simple: (vb, parsed) => {\n    const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n    const root = parsed.root\n    // 'i may'\n    if (root.has('#Modal')) {\n      return vb\n    }\n    let str = root.text({ keepPunct: false })\n    str = toInfinitive(str, vb.model, getTense(root))\n    let all = conjugate(str, vb.model)\n    // 'driven' || 'drove'\n    str = all.PastTense\n    // all.Participle || all.PastTense\n    // but skip the 'is' participle..\n    str = str === 'been' ? 'was' : str\n    if (str === 'was') {\n      str = wasWere(vb, parsed)\n    }\n    if (str) {\n      vb.replace(root, str, keep)\n    }\n    return vb\n  },\n\n  both: function (vb, parsed) {\n    // 'he did not walk'\n    if (parsed.negative.found) {\n      vb.replace('will', 'did')\n      return vb\n    }\n    // 'he walked'\n    vb = fns.simple(vb, parsed)\n    vb = fns.noAux(vb, parsed)\n    return vb\n  },\n\n  hasHad: vb => {\n    vb.replace('has', 'had', keep)\n    return vb\n  },\n\n  // some verbs have this weird past-tense form\n  // drive -> driven, (!drove)\n  hasParticiple: (vb, parsed) => {\n    const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n    const root = parsed.root\n    let str = root.text('normal')\n    str = toInfinitive(str, vb.model, getTense(root))\n    return conjugate(str, vb.model).Participle\n  },\n\n\n\n}\n\n\nconst forms = {\n  // walk -> walked\n  'infinitive': fns.simple,\n  // he walks -> he walked\n  'simple-present': fns.simple,\n  // he walked\n  'simple-past': noop,\n  // he will walk -> he walked\n  'simple-future': fns.both,\n\n  // he is walking\n  'present-progressive': vb => {\n    vb.replace('are', 'were', keep)\n    vb.replace('(is|are|am)', 'was', keep)\n    return vb\n  },\n  // he was walking\n  'past-progressive': noop,\n  // he will be walking\n  'future-progressive': (vb, parsed) => {\n    vb.match(parsed.root).insertBefore('was')\n    vb.remove('(will|be)')\n    return vb\n  },\n\n  // has walked -> had walked (?)\n  'present-perfect': fns.hasHad,\n  // had walked\n  'past-perfect': noop,\n  // will have walked -> had walked\n  'future-perfect': (vb, parsed) => {\n    vb.match(parsed.root).insertBefore('had')\n    if (vb.has('will')) {\n      vb = noWill(vb)\n    }\n    vb.remove('have')\n    return vb\n  },\n\n  // has been walking -> had been\n  'present-perfect-progressive': fns.hasHad,\n  // had been walking\n  'past-perfect-progressive': noop,\n  // will have been -> had\n  'future-perfect-progressive': vb => {\n    vb.remove('will')\n    vb.replace('have', 'had', keep)\n    return vb\n  },\n\n  // got walked\n  'passive-past': vb => {\n    // 'have been walked' -> 'had been walked'\n    vb.replace('have', 'had', keep)\n    return vb\n  },\n  // is being walked  -> 'was being walked'\n  'passive-present': vb => {\n    vb.replace('(is|are)', 'was', keep)\n    return vb\n  },\n  // will be walked -> had been walked\n  'passive-future': (vb, parsed) => {\n    if (parsed.auxiliary.has('will be')) {\n      vb.match(parsed.root).insertBefore('had been')\n      vb.remove('(will|be)')\n    }\n    // will have been walked -> had been walked\n    if (parsed.auxiliary.has('will have been')) {\n      vb.replace('have', 'had', keep)\n      vb.remove('will')\n    }\n    return vb\n  },\n\n  // would be walked -> 'would have been walked'\n  'present-conditional': vb => {\n    vb.replace('be', 'have been')\n    return vb\n  },\n  // would have been walked\n  'past-conditional': noop,\n\n  // is going to drink -> was going to drink\n  'auxiliary-future': vb => {\n    vb.replace('(is|are|am)', 'was', keep)\n    return vb\n  },\n  // used to walk\n  'auxiliary-past': noop,\n  // we do walk -> we did walk\n  'auxiliary-present': vb => {\n    vb.replace('(do|does)', 'did', keep)\n    return vb\n  },\n\n  // must walk -> 'must have walked'\n  'modal-infinitive': (vb, parsed) => {\n    // this modal has a clear tense\n    if (vb.has('can')) {\n      // can drive -> could drive\n      vb.replace('can', 'could', keep)\n    } else {\n      // otherwise, \n      //  walk -> have walked\n      //  drive -> have driven\n      fns.simple(vb, parsed)\n      vb.match('#Modal').insertAfter('have').tag('Auxiliary')\n    }\n    return vb\n  },\n  // must have walked\n  'modal-past': noop,\n  // wanted to walk\n  'want-infinitive': vb => {\n    vb.replace('(want|wants)', 'wanted', keep)\n    vb.remove('will')\n    return vb\n  },\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$')\n    fns.simple(vb, parsed)\n    noWill(vb)\n    return vb\n  },\n}\n\nconst toPast = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed)\n    vb.fullSentence().compute(['tagger', 'chunks'])\n    return vb\n  }\n  // do nothing i guess?\n  return vb\n}\nexport default toPast\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}