{"ast":null,"code":"import { noop, isPlural, isAreAm, doDoes, getSubject, toInf, getTense } from '../lib.js';\nconst keep = {\n  tags: true\n};\n\n// walk->walked\nconst simple = (vb, parsed) => {\n  const {\n    conjugate,\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const root = parsed.root;\n  let str = root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  // 'i walk' vs 'he walks'\n  if (isPlural(vb, parsed) === false) {\n    str = conjugate(str, vb.model).PresentTense;\n  }\n  // handle copula\n  if (root.has('#Copula')) {\n    str = isAreAm(vb, parsed);\n  }\n  if (str) {\n    vb = vb.replace(root, str, keep);\n    vb.not('#Particle').tag('PresentTense');\n  }\n  // vb.replace('not ' + str, str + ' not')\n  return vb;\n};\nconst toGerund = (vb, parsed) => {\n  const {\n    conjugate,\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const root = parsed.root;\n  let str = root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  // 'i walk' vs 'he walks'\n  if (isPlural(vb, parsed) === false) {\n    str = conjugate(str, vb.model).Gerund;\n  }\n  if (str) {\n    vb = vb.replace(root, str, keep);\n    vb.not('#Particle').tag('Gerund');\n  }\n  return vb;\n};\nconst vbToInf = (vb, parsed) => {\n  const {\n    toInfinitive\n  } = vb.methods.two.transform.verb;\n  const root = parsed.root;\n  let str = parsed.root.text('normal');\n  str = toInfinitive(str, vb.model, getTense(root));\n  if (str) {\n    vb = vb.replace(parsed.root, str, keep);\n  }\n  return vb;\n};\nconst forms = {\n  // walk\n  'infinitive': simple,\n  // he walks -> he walked\n  'simple-present': (vb, parsed) => {\n    const {\n      conjugate\n    } = vb.methods.two.transform.verb;\n    let {\n      root\n    } = parsed;\n    // is it *only* a infinitive? - 'we buy' etc\n    if (root.has('#Infinitive')) {\n      let subj = getSubject(vb, parsed);\n      let m = subj.subject;\n      if (isPlural(vb, parsed) || m.has('i')) {\n        // keep it infinitive\n        return vb;\n      }\n      let str = root.text('normal');\n      let pres = conjugate(str, vb.model).PresentTense;\n      if (str !== pres) {\n        vb.replace(root, pres, keep);\n      }\n    } else {\n      return simple(vb, parsed);\n    }\n    return vb;\n  },\n  // he walked\n  'simple-past': simple,\n  // he will walk -> he walked\n  'simple-future': (vb, parsed) => {\n    const {\n      root,\n      auxiliary\n    } = parsed;\n    // handle 'will be'\n    if (auxiliary.has('will') && root.has('be')) {\n      let str = isAreAm(vb, parsed);\n      vb.replace(root, str);\n      vb = vb.remove('will');\n      vb.replace('not ' + str, str + ' not');\n    } else {\n      simple(vb, parsed);\n      vb = vb.remove('will');\n    }\n    return vb;\n  },\n  // is walking ->\n  'present-progressive': noop,\n  // was walking -> is walking\n  'past-progressive': (vb, parsed) => {\n    let str = isAreAm(vb, parsed);\n    return vb.replace('(were|was)', str, keep);\n  },\n  // will be walking -> is walking\n  'future-progressive': vb => {\n    vb.match('will').insertBefore('is');\n    vb.remove('be');\n    return vb.remove('will');\n  },\n  // has walked ->  (?)\n  'present-perfect': (vb, parsed) => {\n    simple(vb, parsed);\n    vb = vb.remove('(have|had|has)');\n    return vb;\n  },\n  // had walked -> has walked\n  'past-perfect': (vb, parsed) => {\n    // not 'we has walked'\n    let subj = getSubject(vb, parsed);\n    let m = subj.subject;\n    if (isPlural(vb, parsed) || m.has('i')) {\n      vb = toInf(vb, parsed); // we walk\n      vb.remove('had');\n      return vb;\n    }\n    vb.replace('had', 'has', keep);\n    return vb;\n  },\n  // will have walked -> has walked\n  'future-perfect': vb => {\n    vb.match('will').insertBefore('has');\n    return vb.remove('have').remove('will');\n  },\n  // has been walking\n  'present-perfect-progressive': noop,\n  // had been walking\n  'past-perfect-progressive': vb => vb.replace('had', 'has', keep),\n  // will have been -> has been\n  'future-perfect-progressive': vb => {\n    vb.match('will').insertBefore('has');\n    return vb.remove('have').remove('will');\n  },\n  // got walked -> is walked\n  // was walked -> is walked\n  // had been walked -> is walked\n  'passive-past': (vb, parsed) => {\n    let str = isAreAm(vb, parsed);\n    if (vb.has('(had|have|has)') && vb.has('been')) {\n      vb.replace('(had|have|has)', str, keep);\n      vb.replace('been', 'being');\n      return vb;\n    }\n    return vb.replace('(got|was|were)', str);\n  },\n  // is being walked  ->\n  'passive-present': noop,\n  // will be walked -> is being walked\n  'passive-future': vb => {\n    vb.replace('will', 'is');\n    return vb.replace('be', 'being');\n  },\n  // would be walked ->\n  'present-conditional': noop,\n  // would have been walked ->\n  'past-conditional': vb => {\n    vb.replace('been', 'be');\n    return vb.remove('have');\n  },\n  // is going to drink -> is drinking\n  'auxiliary-future': (vb, parsed) => {\n    toGerund(vb, parsed);\n    vb.remove('(going|to)');\n    return vb;\n  },\n  // used to walk -> is walking\n  // did walk -> is walking\n  'auxiliary-past': (vb, parsed) => {\n    // 'did provide' -> 'does provide'\n    if (parsed.auxiliary.has('did')) {\n      let str = doDoes(vb, parsed);\n      vb.replace(parsed.auxiliary, str);\n      return vb;\n    }\n    toGerund(vb, parsed);\n    vb.replace(parsed.auxiliary, 'is');\n    return vb;\n  },\n  // we do walk ->\n  'auxiliary-present': noop,\n  // must walk -> 'must have walked'\n  'modal-infinitive': noop,\n  // must have walked\n  'modal-past': (vb, parsed) => {\n    vbToInf(vb, parsed);\n    return vb.remove('have');\n  },\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$');\n    simple(vb, parsed);\n    return vb.remove('(will|have)');\n  },\n  // wanted to walk\n  'want-infinitive': (vb, parsed) => {\n    let str = 'wants';\n    if (isPlural(vb, parsed)) {\n      str = 'want'; //we want\n    }\n    vb.replace('(want|wanted|wants)', str, keep);\n    vb.remove('will');\n    return vb;\n  }\n};\nconst toPresent = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed);\n    vb.fullSentence().compute(['tagger', 'chunks']);\n    return vb;\n  }\n  return vb;\n};\nexport default toPresent;","map":{"version":3,"names":["noop","isPlural","isAreAm","doDoes","getSubject","toInf","getTense","keep","tags","simple","vb","parsed","conjugate","toInfinitive","methods","two","transform","verb","root","str","text","model","PresentTense","has","replace","not","tag","toGerund","Gerund","vbToInf","forms","simple-present","subj","m","subject","pres","simple-future","auxiliary","remove","past-progressive","match","insertBefore","present-perfect","past-perfect","passive-past","auxiliary-future","auxiliary-past","modal-past","gerund-phrase","want-infinitive","toPresent","form","hasOwnProperty","fullSentence","compute"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/conjugate/toPresent.js"],"sourcesContent":["import { noop, isPlural, isAreAm, doDoes, getSubject, toInf, getTense } from '../lib.js'\nconst keep = { tags: true }\n\n// walk->walked\nconst simple = (vb, parsed) => {\n  const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n  const root = parsed.root\n  let str = root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  // 'i walk' vs 'he walks'\n  if (isPlural(vb, parsed) === false) {\n    str = conjugate(str, vb.model).PresentTense\n  }\n  // handle copula\n  if (root.has('#Copula')) {\n    str = isAreAm(vb, parsed)\n  }\n  if (str) {\n    vb = vb.replace(root, str, keep)\n    vb.not('#Particle').tag('PresentTense')\n  }\n  // vb.replace('not ' + str, str + ' not')\n  return vb\n}\n\nconst toGerund = (vb, parsed) => {\n  const { conjugate, toInfinitive } = vb.methods.two.transform.verb\n  const root = parsed.root\n  let str = root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  // 'i walk' vs 'he walks'\n  if (isPlural(vb, parsed) === false) {\n    str = conjugate(str, vb.model).Gerund\n  }\n  if (str) {\n    vb = vb.replace(root, str, keep)\n    vb.not('#Particle').tag('Gerund')\n  }\n  return vb\n}\n\nconst vbToInf = (vb, parsed) => {\n  const { toInfinitive } = vb.methods.two.transform.verb\n  const root = parsed.root\n  let str = parsed.root.text('normal')\n  str = toInfinitive(str, vb.model, getTense(root))\n  if (str) {\n    vb = vb.replace(parsed.root, str, keep)\n  }\n  return vb\n}\n\n\n\nconst forms = {\n  // walk\n  'infinitive': simple,\n  // he walks -> he walked\n  'simple-present': (vb, parsed) => {\n    const { conjugate } = vb.methods.two.transform.verb\n    let { root } = parsed\n    // is it *only* a infinitive? - 'we buy' etc\n    if (root.has('#Infinitive')) {\n      let subj = getSubject(vb, parsed)\n      let m = subj.subject\n      if (isPlural(vb, parsed) || m.has('i')) {\n        // keep it infinitive\n        return vb\n      }\n      let str = root.text('normal')\n      let pres = conjugate(str, vb.model).PresentTense\n      if (str !== pres) {\n        vb.replace(root, pres, keep)\n      }\n    } else {\n      return simple(vb, parsed)\n    }\n    return vb\n  },\n  // he walked\n  'simple-past': simple,\n  // he will walk -> he walked\n  'simple-future': (vb, parsed) => {\n    const { root, auxiliary } = parsed\n    // handle 'will be'\n    if (auxiliary.has('will') && root.has('be')) {\n      let str = isAreAm(vb, parsed)\n      vb.replace(root, str)\n      vb = vb.remove('will')\n      vb.replace('not ' + str, str + ' not')\n    } else {\n      simple(vb, parsed)\n      vb = vb.remove('will')\n    }\n    return vb\n  },\n\n  // is walking ->\n  'present-progressive': noop,\n  // was walking -> is walking\n  'past-progressive': (vb, parsed) => {\n    let str = isAreAm(vb, parsed)\n    return vb.replace('(were|was)', str, keep)\n  },\n  // will be walking -> is walking\n  'future-progressive': vb => {\n    vb.match('will').insertBefore('is')\n    vb.remove('be')\n    return vb.remove('will')\n  },\n\n  // has walked ->  (?)\n  'present-perfect': (vb, parsed) => {\n    simple(vb, parsed)\n    vb = vb.remove('(have|had|has)')\n    return vb\n  },\n\n  // had walked -> has walked\n  'past-perfect': (vb, parsed) => {\n    // not 'we has walked'\n    let subj = getSubject(vb, parsed)\n    let m = subj.subject\n    if (isPlural(vb, parsed) || m.has('i')) {\n      vb = toInf(vb, parsed)// we walk\n      vb.remove('had')\n      return vb\n    }\n    vb.replace('had', 'has', keep)\n    return vb\n  },\n  // will have walked -> has walked\n  'future-perfect': vb => {\n    vb.match('will').insertBefore('has')\n    return vb.remove('have').remove('will')\n  },\n\n  // has been walking\n  'present-perfect-progressive': noop,\n  // had been walking\n  'past-perfect-progressive': vb => vb.replace('had', 'has', keep),\n  // will have been -> has been\n  'future-perfect-progressive': vb => {\n    vb.match('will').insertBefore('has')\n    return vb.remove('have').remove('will')\n  },\n\n  // got walked -> is walked\n  // was walked -> is walked\n  // had been walked -> is walked\n  'passive-past': (vb, parsed) => {\n    let str = isAreAm(vb, parsed)\n    if (vb.has('(had|have|has)') && vb.has('been')) {\n      vb.replace('(had|have|has)', str, keep)\n      vb.replace('been', 'being')\n      return vb\n    }\n    return vb.replace('(got|was|were)', str)\n  },\n  // is being walked  ->\n  'passive-present': noop,\n  // will be walked -> is being walked\n  'passive-future': vb => {\n    vb.replace('will', 'is')\n    return vb.replace('be', 'being')\n  },\n\n  // would be walked ->\n  'present-conditional': noop,\n  // would have been walked ->\n  'past-conditional': vb => {\n    vb.replace('been', 'be')\n    return vb.remove('have')\n  },\n\n  // is going to drink -> is drinking\n  'auxiliary-future': (vb, parsed) => {\n    toGerund(vb, parsed)\n    vb.remove('(going|to)')\n    return vb\n  },\n  // used to walk -> is walking\n  // did walk -> is walking\n  'auxiliary-past': (vb, parsed) => {\n    // 'did provide' -> 'does provide'\n    if (parsed.auxiliary.has('did')) {\n      let str = doDoes(vb, parsed)\n      vb.replace(parsed.auxiliary, str)\n      return vb\n    }\n    toGerund(vb, parsed)\n    vb.replace(parsed.auxiliary, 'is')\n    return vb\n  },\n  // we do walk ->\n  'auxiliary-present': noop,\n\n  // must walk -> 'must have walked'\n  'modal-infinitive': noop,\n  // must have walked\n  'modal-past': (vb, parsed) => {\n    vbToInf(vb, parsed)\n    return vb.remove('have')\n  },\n  // started looking\n  'gerund-phrase': (vb, parsed) => {\n    parsed.root = parsed.root.not('#Gerund$')\n    simple(vb, parsed)\n    return vb.remove('(will|have)')\n  },\n  // wanted to walk\n  'want-infinitive': (vb, parsed) => {\n    let str = 'wants'\n    if (isPlural(vb, parsed)) {\n      str = 'want'//we want\n    }\n    vb.replace('(want|wanted|wants)', str, keep)\n    vb.remove('will')\n    return vb\n  },\n}\n\nconst toPresent = function (vb, parsed, form) {\n  // console.log(form)\n  if (forms.hasOwnProperty(form)) {\n    vb = forms[form](vb, parsed)\n    vb.fullSentence().compute(['tagger', 'chunks'])\n    return vb\n  }\n  return vb\n}\nexport default toPresent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}