{"ast":null,"code":"const endS = /s$/;\nimport parseText from '../numbers/parse/toNumber/index.js';\n\n// just using .toNumber() again may risk an infinite-loop\nconst parseNumber = function (m) {\n  let str = m.text('reduced');\n  return parseText(str);\n};\nlet mapping = {\n  half: 2,\n  halve: 2,\n  quarter: 4\n};\nconst slashForm = function (m) {\n  let str = m.text('reduced');\n  let found = str.match(/^([-+]?[0-9]+)\\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);\n  if (found && found[1] && found[0]) {\n    return {\n      numerator: Number(found[1]),\n      denominator: Number(found[2])\n    };\n  }\n  return null;\n};\n\n// parse '4 out of 4'\nconst nOutOfN = function (m) {\n  let found = m.match('[<num>#Value+] out of every? [<den>#Value+]');\n  if (found.found !== true) {\n    return null;\n  }\n  let {\n    num,\n    den\n  } = found.groups();\n  if (!num || !den) {\n    return null;\n  }\n  num = parseNumber(num);\n  den = parseNumber(den);\n  if (!num || !den) {\n    return null;\n  }\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den\n    };\n  }\n  return null;\n};\n\n// parse 'five thirds'\nconst nOrinalth = function (m) {\n  let found = m.match('[<num>(#Cardinal|a)+] [<den>#Fraction+]');\n  if (found.found !== true) {\n    return null;\n  }\n  let {\n    num,\n    den\n  } = found.groups();\n  // -- parse numerator---\n  // quick-support for 'a third'\n  if (num.has('a')) {\n    num = 1;\n  } else {\n    // abuse the number-parser for 'thirty three'\n    // let tmp = num.clone().unTag('Fraction')\n    // num = tmp.numbers().get()[0]\n    num = parseNumber(num);\n  }\n  // -- parse denominator --\n  // turn 'thirds' into third\n  let str = den.text('reduced');\n  if (endS.test(str)) {\n    str = str.replace(endS, '');\n    den = den.replaceWith(str);\n  }\n  // support 'one half' as '1/2'\n  if (mapping.hasOwnProperty(str)) {\n    den = mapping[str];\n  } else {\n    // dem = dem.numbers().get()[0]\n    den = parseNumber(den);\n  }\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den\n    };\n  }\n  return null;\n};\n\n// implied 1 in '100th of a', 'fifth of a'\nconst oneNth = function (m) {\n  let found = m.match('^#Ordinal$');\n  if (found.found !== true) {\n    return null;\n  }\n  // ensure it's '100th of a '\n  if (m.lookAhead('^of .')) {\n    // let num = found.numbers().get()[0]\n    let num = parseNumber(found);\n    return {\n      numerator: 1,\n      denominator: num\n    };\n  }\n  return null;\n};\n\n// 'half'\nconst named = function (m) {\n  let str = m.text('reduced');\n  if (mapping.hasOwnProperty(str)) {\n    return {\n      numerator: 1,\n      denominator: mapping[str]\n    };\n  }\n  return null;\n};\nconst round = n => {\n  let rounded = Math.round(n * 1000) / 1000;\n  // don't round 1 millionth down into 0\n  if (rounded === 0 && n !== 0) {\n    return n;\n  }\n  return rounded;\n};\nconst parseFraction = function (m) {\n  m = m.clone();\n  let res = named(m) || slashForm(m) || nOutOfN(m) || nOrinalth(m) || oneNth(m) || null;\n  if (res !== null) {\n    // do the math\n    if (res.numerator && res.denominator) {\n      res.decimal = res.numerator / res.denominator;\n      res.decimal = round(res.decimal);\n    }\n  }\n  return res;\n};\nexport default parseFraction;","map":{"version":3,"names":["endS","parseText","parseNumber","m","str","text","mapping","half","halve","quarter","slashForm","found","match","numerator","Number","denominator","nOutOfN","num","den","groups","nOrinalth","has","test","replace","replaceWith","hasOwnProperty","oneNth","lookAhead","named","round","n","rounded","Math","parseFraction","clone","res","decimal"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/numbers/fractions/parse.js"],"sourcesContent":["const endS = /s$/\nimport parseText from '../numbers/parse/toNumber/index.js'\n\n// just using .toNumber() again may risk an infinite-loop\nconst parseNumber = function (m) {\n  let str = m.text('reduced')\n  return parseText(str)\n}\n\nlet mapping = {\n  half: 2,\n  halve: 2,\n  quarter: 4,\n}\n\nconst slashForm = function (m) {\n  let str = m.text('reduced')\n  let found = str.match(/^([-+]?[0-9]+)\\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/)\n  if (found && found[1] && found[0]) {\n    return {\n      numerator: Number(found[1]),\n      denominator: Number(found[2]),\n    }\n  }\n  return null\n}\n\n// parse '4 out of 4'\nconst nOutOfN = function (m) {\n  let found = m.match('[<num>#Value+] out of every? [<den>#Value+]')\n  if (found.found !== true) {\n    return null\n  }\n  let { num, den } = found.groups()\n  if (!num || !den) {\n    return null\n  }\n  num = parseNumber(num)\n  den = parseNumber(den)\n  if (!num || !den) {\n    return null\n  }\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den,\n    }\n  }\n  return null\n}\n\n// parse 'five thirds'\nconst nOrinalth = function (m) {\n  let found = m.match('[<num>(#Cardinal|a)+] [<den>#Fraction+]')\n  if (found.found !== true) {\n    return null\n  }\n  let { num, den } = found.groups()\n  // -- parse numerator---\n  // quick-support for 'a third'\n  if (num.has('a')) {\n    num = 1\n  } else {\n    // abuse the number-parser for 'thirty three'\n    // let tmp = num.clone().unTag('Fraction')\n    // num = tmp.numbers().get()[0]\n    num = parseNumber(num)\n  }\n  // -- parse denominator --\n  // turn 'thirds' into third\n  let str = den.text('reduced')\n  if (endS.test(str)) {\n    str = str.replace(endS, '')\n    den = den.replaceWith(str)\n  }\n  // support 'one half' as '1/2'\n  if (mapping.hasOwnProperty(str)) {\n    den = mapping[str]\n  } else {\n    // dem = dem.numbers().get()[0]\n    den = parseNumber(den)\n  }\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den,\n    }\n  }\n  return null\n}\n\n// implied 1 in '100th of a', 'fifth of a'\nconst oneNth = function (m) {\n  let found = m.match('^#Ordinal$')\n  if (found.found !== true) {\n    return null\n  }\n  // ensure it's '100th of a '\n  if (m.lookAhead('^of .')) {\n    // let num = found.numbers().get()[0]\n    let num = parseNumber(found)\n    return {\n      numerator: 1,\n      denominator: num,\n    }\n  }\n  return null\n}\n\n// 'half'\nconst named = function (m) {\n  let str = m.text('reduced')\n  if (mapping.hasOwnProperty(str)) {\n    return { numerator: 1, denominator: mapping[str] }\n  }\n  return null\n}\n\nconst round = n => {\n  let rounded = Math.round(n * 1000) / 1000\n  // don't round 1 millionth down into 0\n  if (rounded === 0 && n !== 0) {\n    return n\n  }\n  return rounded\n}\n\nconst parseFraction = function (m) {\n  m = m.clone()\n  let res = named(m) || slashForm(m) || nOutOfN(m) || nOrinalth(m) || oneNth(m) || null\n  if (res !== null) {\n    // do the math\n    if (res.numerator && res.denominator) {\n      res.decimal = res.numerator / res.denominator\n      res.decimal = round(res.decimal)\n    }\n  }\n  return res\n}\nexport default parseFraction\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}