{"ast":null,"code":"import pluckOutTerm from './lib/remove.js';\nconst fixPointers = function (ptrs, gonePtrs) {\n  ptrs = ptrs.map(ptr => {\n    let [n] = ptr;\n    if (!gonePtrs[n]) {\n      return ptr;\n    }\n    gonePtrs[n].forEach(no => {\n      let len = no[2] - no[1];\n      // does it effect our pointer?\n      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {\n        ptr[2] -= len;\n      }\n    });\n    return ptr;\n  });\n\n  // decrement any pointers after a now-empty pointer\n  ptrs.forEach((ptr, i) => {\n    // is the pointer now empty?\n    if (ptr[1] === 0 && ptr[2] == 0) {\n      // go down subsequent pointers\n      for (let n = i + 1; n < ptrs.length; n += 1) {\n        ptrs[n][0] -= 1;\n        if (ptrs[n][0] < 0) {\n          ptrs[n][0] = 0;\n        }\n      }\n    }\n  });\n  // remove any now-empty pointers\n  ptrs = ptrs.filter(ptr => ptr[2] - ptr[1] > 0);\n\n  // remove old hard-pointers\n  ptrs = ptrs.map(ptr => {\n    ptr[3] = null;\n    ptr[4] = null;\n    return ptr;\n  });\n  return ptrs;\n};\nconst methods = {\n  /** */\n  remove: function (reg) {\n    const {\n      indexN\n    } = this.methods.one.pointer;\n    this.uncache();\n    // two modes:\n    //  - a. remove self, from full parent\n    let self = this.all();\n    let not = this;\n    //  - b. remove a match, from self\n    if (reg) {\n      self = this;\n      not = this.match(reg);\n    }\n    let isFull = !self.ptrs;\n    // is it part of a contraction?\n    if (not.has('@hasContraction') && not.contractions) {\n      let more = not.grow('@hasContraction');\n      more.contractions().expand();\n    }\n    let ptrs = self.fullPointer;\n    let nots = not.fullPointer.reverse();\n    // remove them from the actual document)\n    let document = pluckOutTerm(this.document, nots);\n    // repair our pointers\n    let gonePtrs = indexN(nots);\n    ptrs = fixPointers(ptrs, gonePtrs);\n    // clean up our original inputs\n    self.ptrs = ptrs;\n    self.document = document;\n    self.compute('index');\n    // if we started zoomed-out, try to end zoomed-out\n    if (isFull) {\n      self.ptrs = undefined;\n    }\n    if (!reg) {\n      this.ptrs = [];\n      return self.none();\n    }\n    let res = self.toView(ptrs); //return new document\n    return res;\n  }\n};\n\n// aliases\nmethods.delete = methods.remove;\nexport default methods;","map":{"version":3,"names":["pluckOutTerm","fixPointers","ptrs","gonePtrs","map","ptr","n","forEach","no","len","i","length","filter","methods","remove","reg","indexN","one","pointer","uncache","self","all","not","match","isFull","has","contractions","more","grow","expand","fullPointer","nots","reverse","document","compute","undefined","none","res","toView","delete"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/change/api/remove.js"],"sourcesContent":["import pluckOutTerm from './lib/remove.js'\n\nconst fixPointers = function (ptrs, gonePtrs) {\n  ptrs = ptrs.map(ptr => {\n    let [n] = ptr\n    if (!gonePtrs[n]) {\n      return ptr\n    }\n    gonePtrs[n].forEach(no => {\n      let len = no[2] - no[1]\n      // does it effect our pointer?\n      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {\n        ptr[2] -= len\n      }\n    })\n    return ptr\n  })\n\n  // decrement any pointers after a now-empty pointer\n  ptrs.forEach((ptr, i) => {\n    // is the pointer now empty?\n    if (ptr[1] === 0 && ptr[2] == 0) {\n      // go down subsequent pointers\n      for (let n = i + 1; n < ptrs.length; n += 1) {\n        ptrs[n][0] -= 1\n        if (ptrs[n][0] < 0) {\n          ptrs[n][0] = 0\n        }\n      }\n    }\n  })\n  // remove any now-empty pointers\n  ptrs = ptrs.filter(ptr => ptr[2] - ptr[1] > 0)\n\n  // remove old hard-pointers\n  ptrs = ptrs.map((ptr) => {\n    ptr[3] = null\n    ptr[4] = null\n    return ptr\n  })\n  return ptrs\n}\n\nconst methods = {\n  /** */\n  remove: function (reg) {\n    const { indexN } = this.methods.one.pointer\n    this.uncache()\n    // two modes:\n    //  - a. remove self, from full parent\n    let self = this.all()\n    let not = this\n    //  - b. remove a match, from self\n    if (reg) {\n      self = this\n      not = this.match(reg)\n    }\n    let isFull = !self.ptrs\n    // is it part of a contraction?\n    if (not.has('@hasContraction') && not.contractions) {\n      let more = not.grow('@hasContraction')\n      more.contractions().expand()\n    }\n\n    let ptrs = self.fullPointer\n    let nots = not.fullPointer.reverse()\n    // remove them from the actual document)\n    let document = pluckOutTerm(this.document, nots)\n    // repair our pointers\n    let gonePtrs = indexN(nots)\n    ptrs = fixPointers(ptrs, gonePtrs)\n    // clean up our original inputs\n    self.ptrs = ptrs\n    self.document = document\n    self.compute('index')\n    // if we started zoomed-out, try to end zoomed-out\n    if (isFull) {\n      self.ptrs = undefined\n    }\n    if (!reg) {\n      this.ptrs = []\n      return self.none()\n    }\n    let res = self.toView(ptrs) //return new document\n    return res\n  },\n}\n\n// aliases\nmethods.delete = methods.remove\nexport default methods\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}