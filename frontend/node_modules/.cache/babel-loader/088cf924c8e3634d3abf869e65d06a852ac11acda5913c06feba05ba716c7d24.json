{"ast":null,"code":"import methods from '../../methods/index.js';\nimport expandIrregulars from './irregulars.js';\nimport toPlural from '../../methods/transform/nouns/toPlural/index.js';\nimport conjugate from '../../methods/transform/verbs/conjugate/index.js';\nimport { toSuperlative, toComparative } from '../../methods/transform/adjectives/inflect.js';\nimport toInfinitive from '../../methods/transform/verbs/toInfinitive/index.js';\nimport models from '../models/index.js';\nlet tmpModel = {\n  one: {\n    lexicon: {}\n  },\n  two: {\n    models\n  }\n};\n\n// defaults for switches\nconst switchDefaults = {\n  // 'pilot'\n  'Actor|Verb': 'Actor',\n  //\n  // 'amusing'\n  'Adj|Gerund': 'Adjective',\n  //+conjugations\n  // 'standard'\n  'Adj|Noun': 'Adjective',\n  // 'boiled'\n  'Adj|Past': 'Adjective',\n  //+conjugations\n  // 'smooth'\n  'Adj|Present': 'Adjective',\n  //+conjugations\n  // 'box'\n  'Noun|Verb': 'Singular',\n  //+conjugations (no-present)\n  //'singing'\n  'Noun|Gerund': 'Gerund',\n  //+conjugations\n  // 'hope'\n  'Person|Noun': 'Noun',\n  // 'April'\n  'Person|Date': 'Month',\n  // 'rob'\n  'Person|Verb': 'FirstName',\n  //+conjugations\n  // 'victoria'\n  'Person|Place': 'Person',\n  // 'rusty'\n  'Person|Adj': 'Comparative',\n  // 'boxes'\n  'Plural|Verb': 'Plural',\n  //(these are already derivative)\n  // 'miles'\n  'Unit|Noun': 'Noun'\n};\nconst expandLexicon = function (words, model) {\n  // do clever tricks to grow the words\n  const world = {\n    model,\n    methods\n  };\n  let {\n    lex,\n    _multi\n  } = methods.two.expandLexicon(words, world);\n  // store multiple-word terms in a cache\n  Object.assign(model.one.lexicon, lex);\n  Object.assign(model.one._multiCache, _multi);\n  return model;\n};\n\n// these words have no singular/plural conjugation\nconst addUncountables = function (words, model) {\n  Object.keys(words).forEach(k => {\n    if (words[k] === 'Uncountable') {\n      model.two.uncountable[k] = true;\n      words[k] = 'Uncountable';\n    }\n  });\n  return model;\n};\nconst expandVerb = function (str, words, doPresent) {\n  let obj = conjugate(str, tmpModel);\n  words[obj.PastTense] = words[obj.PastTense] || 'PastTense';\n  words[obj.Gerund] = words[obj.Gerund] || 'Gerund';\n  if (doPresent === true) {\n    // is this plural noun, or present-tense?\n    words[obj.PresentTense] = words[obj.PresentTense] || 'PresentTense';\n  }\n};\nconst expandAdjective = function (str, words, model) {\n  let sup = toSuperlative(str, model);\n  words[sup] = words[sup] || 'Superlative';\n  let comp = toComparative(str, model);\n  words[comp] = words[comp] || 'Comparative';\n};\nconst expandNoun = function (str, words, model) {\n  let plur = toPlural(str, model);\n  words[plur] = words[plur] || 'Plural';\n};\n\n// harvest ambiguous words for any conjugations\nconst expandVariable = function (switchWords, model) {\n  let words = {};\n  const lex = model.one.lexicon;\n  //add first tag as an assumption for each variable word\n  Object.keys(switchWords).forEach(w => {\n    const name = switchWords[w];\n    words[w] = switchDefaults[name];\n    // conjugate some verbs\n    if (name === 'Noun|Verb' || name === 'Person|Verb' || name === 'Actor|Verb') {\n      expandVerb(w, lex, false);\n    }\n    if (name === 'Adj|Present') {\n      expandVerb(w, lex, true);\n      expandAdjective(w, lex, model);\n    }\n    if (name === 'Person|Adj') {\n      expandAdjective(w, lex, model);\n    }\n    // add infinitives for gerunds\n    if (name === 'Adj|Gerund' || name === 'Noun|Gerund') {\n      let inf = toInfinitive(w, tmpModel, 'Gerund');\n      if (!lex[inf]) {\n        words[inf] = 'Infinitive'; //expand it later\n      }\n    }\n    // add plurals for nouns\n    if (name === 'Noun|Gerund' || name === 'Adj|Noun' || name === 'Person|Noun') {\n      expandNoun(w, lex, model);\n    }\n    if (name === 'Adj|Past') {\n      let inf = toInfinitive(w, tmpModel, 'PastTense');\n      if (!lex[inf]) {\n        words[inf] = 'Infinitive'; //expand it later\n      }\n    }\n  });\n  // add conjugations\n  model = expandLexicon(words, model);\n  return model;\n};\nconst expand = function (model) {\n  model = expandLexicon(model.one.lexicon, model);\n  model = addUncountables(model.one.lexicon, model);\n  model = expandVariable(model.two.switches, model);\n  model = expandIrregulars(model);\n  return model;\n};\nexport default expand;","map":{"version":3,"names":["methods","expandIrregulars","toPlural","conjugate","toSuperlative","toComparative","toInfinitive","models","tmpModel","one","lexicon","two","switchDefaults","expandLexicon","words","model","world","lex","_multi","Object","assign","_multiCache","addUncountables","keys","forEach","k","uncountable","expandVerb","str","doPresent","obj","PastTense","Gerund","PresentTense","expandAdjective","sup","comp","expandNoun","plur","expandVariable","switchWords","w","name","inf","expand","switches"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/model/_expand/index.js"],"sourcesContent":["import methods from '../../methods/index.js'\nimport expandIrregulars from './irregulars.js'\nimport toPlural from '../../methods/transform/nouns/toPlural/index.js'\nimport conjugate from '../../methods/transform/verbs/conjugate/index.js'\nimport { toSuperlative, toComparative } from '../../methods/transform/adjectives/inflect.js'\nimport toInfinitive from '../../methods/transform/verbs/toInfinitive/index.js'\nimport models from '../models/index.js'\nlet tmpModel = {\n  one: { lexicon: {} },\n  two: { models }\n}\n\n// defaults for switches\nconst switchDefaults = {\n  // 'pilot'\n  'Actor|Verb': 'Actor', //\n  // 'amusing'\n  'Adj|Gerund': 'Adjective', //+conjugations\n  // 'standard'\n  'Adj|Noun': 'Adjective',\n  // 'boiled'\n  'Adj|Past': 'Adjective', //+conjugations\n  // 'smooth'\n  'Adj|Present': 'Adjective',//+conjugations\n  // 'box'\n  'Noun|Verb': 'Singular', //+conjugations (no-present)\n  //'singing'\n  'Noun|Gerund': 'Gerund', //+conjugations\n  // 'hope'\n  'Person|Noun': 'Noun',\n  // 'April'\n  'Person|Date': 'Month',\n  // 'rob'\n  'Person|Verb': 'FirstName',//+conjugations\n  // 'victoria'\n  'Person|Place': 'Person',\n  // 'rusty'\n  'Person|Adj': 'Comparative',\n  // 'boxes'\n  'Plural|Verb': 'Plural', //(these are already derivative)\n  // 'miles'\n  'Unit|Noun': 'Noun',\n}\n\nconst expandLexicon = function (words, model) {\n  // do clever tricks to grow the words\n  const world = { model, methods }\n  let { lex, _multi } = methods.two.expandLexicon(words, world)\n  // store multiple-word terms in a cache\n  Object.assign(model.one.lexicon, lex)\n  Object.assign(model.one._multiCache, _multi)\n  return model\n}\n\n// these words have no singular/plural conjugation\nconst addUncountables = function (words, model) {\n  Object.keys(words).forEach(k => {\n    if (words[k] === 'Uncountable') {\n      model.two.uncountable[k] = true\n      words[k] = 'Uncountable'\n    }\n  })\n  return model\n}\n\nconst expandVerb = function (str, words, doPresent) {\n  let obj = conjugate(str, tmpModel)\n  words[obj.PastTense] = words[obj.PastTense] || 'PastTense'\n  words[obj.Gerund] = words[obj.Gerund] || 'Gerund'\n  if (doPresent === true) {\n    // is this plural noun, or present-tense?\n    words[obj.PresentTense] = words[obj.PresentTense] || 'PresentTense'\n  }\n}\n\nconst expandAdjective = function (str, words, model) {\n  let sup = toSuperlative(str, model)\n  words[sup] = words[sup] || 'Superlative'\n  let comp = toComparative(str, model)\n  words[comp] = words[comp] || 'Comparative'\n}\n\nconst expandNoun = function (str, words, model) {\n  let plur = toPlural(str, model)\n  words[plur] = words[plur] || 'Plural'\n}\n\n// harvest ambiguous words for any conjugations\nconst expandVariable = function (switchWords, model) {\n  let words = {}\n  const lex = model.one.lexicon\n  //add first tag as an assumption for each variable word\n  Object.keys(switchWords).forEach(w => {\n    const name = switchWords[w]\n    words[w] = switchDefaults[name]\n    // conjugate some verbs\n    if (name === 'Noun|Verb' || name === 'Person|Verb' || name === 'Actor|Verb') {\n      expandVerb(w, lex, false)\n    }\n    if (name === 'Adj|Present') {\n      expandVerb(w, lex, true)\n      expandAdjective(w, lex, model)\n    }\n    if (name === 'Person|Adj') {\n      expandAdjective(w, lex, model)\n    }\n    // add infinitives for gerunds\n    if (name === 'Adj|Gerund' || name === 'Noun|Gerund') {\n      let inf = toInfinitive(w, tmpModel, 'Gerund')\n      if (!lex[inf]) {\n        words[inf] = 'Infinitive' //expand it later\n      }\n    }\n    // add plurals for nouns\n    if (name === 'Noun|Gerund' || name === 'Adj|Noun' || name === 'Person|Noun') {\n      expandNoun(w, lex, model)\n    }\n    if (name === 'Adj|Past') {\n      let inf = toInfinitive(w, tmpModel, 'PastTense')\n      if (!lex[inf]) {\n        words[inf] = 'Infinitive' //expand it later\n      }\n    }\n  })\n  // add conjugations\n  model = expandLexicon(words, model)\n  return model\n}\n\nconst expand = function (model) {\n  model = expandLexicon(model.one.lexicon, model)\n  model = addUncountables(model.one.lexicon, model)\n  model = expandVariable(model.two.switches, model)\n  model = expandIrregulars(model)\n  return model\n}\nexport default expand\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}