{"ast":null,"code":"// add all conjugations of this verb\nconst addVerbs = function (token, world) {\n  let {\n    all\n  } = world.methods.two.transform.verb || {};\n  let str = token.root;\n  if (!all) {\n    return [];\n  }\n  return all(str, world.model);\n};\n\n// add all inflections of this noun\nconst addNoun = function (token, world) {\n  let {\n    all\n  } = world.methods.two.transform.noun || {};\n  if (!all) {\n    return [token.root];\n  }\n  return all(token.root, world.model);\n};\n\n// add all inflections of this adjective\nconst addAdjective = function (token, world) {\n  let {\n    all\n  } = world.methods.two.transform.adjective || {};\n  if (!all) {\n    return [token.root];\n  }\n  return all(token.root, world.model);\n};\n\n// turn '{walk}' into 'walking', 'walked', etc\nconst inflectRoot = function (regs, world) {\n  // do we have compromise/two?\n  regs = regs.map(token => {\n    // a reg to convert '{foo}'\n    if (token.root) {\n      // check if compromise/two is loaded\n      if (world.methods.two && world.methods.two.transform) {\n        let choices = [];\n        // have explicitly set from POS - '{sweet/adjective}'\n        if (token.pos) {\n          if (token.pos === 'Verb') {\n            choices = choices.concat(addVerbs(token, world));\n          } else if (token.pos === 'Noun') {\n            choices = choices.concat(addNoun(token, world));\n          } else if (token.pos === 'Adjective') {\n            choices = choices.concat(addAdjective(token, world));\n          }\n        } else {\n          // do verb/noun/adj by default\n          choices = choices.concat(addVerbs(token, world));\n          choices = choices.concat(addNoun(token, world));\n          choices = choices.concat(addAdjective(token, world));\n        }\n        choices = choices.filter(str => str);\n        if (choices.length > 0) {\n          token.operator = 'or';\n          token.fastOr = new Set(choices);\n        }\n      } else {\n        // if no compromise/two, drop down into 'machine' lookup\n        token.machine = token.root;\n        delete token.id;\n        delete token.root;\n      }\n    }\n    return token;\n  });\n  return regs;\n};\nexport default inflectRoot;","map":{"version":3,"names":["addVerbs","token","world","all","methods","two","transform","verb","str","root","model","addNoun","noun","addAdjective","adjective","inflectRoot","regs","map","choices","pos","concat","filter","length","operator","fastOr","Set","machine","id"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/methods/parseMatch/04-inflect-root.js"],"sourcesContent":["\n// add all conjugations of this verb\nconst addVerbs = function (token, world) {\n  let { all } = world.methods.two.transform.verb || {}\n  let str = token.root\n  if (!all) {\n    return []\n  }\n  return all(str, world.model)\n}\n\n// add all inflections of this noun\nconst addNoun = function (token, world) {\n  let { all } = world.methods.two.transform.noun || {}\n  if (!all) {\n    return [token.root]\n  }\n  return all(token.root, world.model)\n}\n\n// add all inflections of this adjective\nconst addAdjective = function (token, world) {\n  let { all } = world.methods.two.transform.adjective || {}\n  if (!all) {\n    return [token.root]\n  }\n  return all(token.root, world.model)\n}\n\n// turn '{walk}' into 'walking', 'walked', etc\nconst inflectRoot = function (regs, world) {\n  // do we have compromise/two?\n  regs = regs.map(token => {\n    // a reg to convert '{foo}'\n    if (token.root) {\n      // check if compromise/two is loaded\n      if (world.methods.two && world.methods.two.transform) {\n        let choices = []\n        // have explicitly set from POS - '{sweet/adjective}'\n        if (token.pos) {\n          if (token.pos === 'Verb') {\n            choices = choices.concat(addVerbs(token, world))\n          } else if (token.pos === 'Noun') {\n            choices = choices.concat(addNoun(token, world))\n          } else if (token.pos === 'Adjective') {\n            choices = choices.concat(addAdjective(token, world))\n          }\n        } else {\n          // do verb/noun/adj by default\n          choices = choices.concat(addVerbs(token, world))\n          choices = choices.concat(addNoun(token, world))\n          choices = choices.concat(addAdjective(token, world))\n        }\n        choices = choices.filter(str => str)\n        if (choices.length > 0) {\n          token.operator = 'or'\n          token.fastOr = new Set(choices)\n        }\n      } else {\n        // if no compromise/two, drop down into 'machine' lookup\n        token.machine = token.root\n        delete token.id\n        delete token.root\n      }\n    }\n    return token\n  })\n\n  return regs\n}\nexport default inflectRoot"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}