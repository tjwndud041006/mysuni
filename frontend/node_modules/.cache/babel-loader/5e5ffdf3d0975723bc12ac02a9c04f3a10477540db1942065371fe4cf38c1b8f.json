{"ast":null,"code":"'use strict';\n\nconst crypto = require('./utils');\nconst {\n  signatureAlgorithmHashFromCertificate\n} = require('./cert-signatures');\nfunction startSession(mechanisms, stream) {\n  const candidates = ['SCRAM-SHA-256'];\n  if (stream) candidates.unshift('SCRAM-SHA-256-PLUS'); // higher-priority, so placed first\n\n  const mechanism = candidates.find(candidate => mechanisms.includes(candidate));\n  if (!mechanism) {\n    throw new Error('SASL: Only mechanism(s) ' + candidates.join(' and ') + ' are supported');\n  }\n  if (mechanism === 'SCRAM-SHA-256-PLUS' && typeof stream.getPeerCertificate !== 'function') {\n    // this should never happen if we are really talking to a Postgres server\n    throw new Error('SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate');\n  }\n  const clientNonce = crypto.randomBytes(18).toString('base64');\n  const gs2Header = mechanism === 'SCRAM-SHA-256-PLUS' ? 'p=tls-server-end-point' : stream ? 'y' : 'n';\n  return {\n    mechanism,\n    clientNonce,\n    response: gs2Header + ',,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  };\n}\nasync function continueSession(session, password, serverData, stream) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse');\n  }\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string');\n  }\n  if (password === '') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string');\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string');\n  }\n  const sv = parseServerFirstMessage(serverData);\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce');\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short');\n  }\n  const clientFirstMessageBare = 'n=*,r=' + session.clientNonce;\n  const serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;\n\n  // without channel binding:\n  let channelBinding = stream ? 'eSws' : 'biws'; // 'y,,' or 'n,,', base64-encoded\n\n  // override if channel binding is in use:\n  if (session.mechanism === 'SCRAM-SHA-256-PLUS') {\n    const peerCert = stream.getPeerCertificate().raw;\n    let hashName = signatureAlgorithmHashFromCertificate(peerCert);\n    if (hashName === 'MD5' || hashName === 'SHA-1') hashName = 'SHA-256';\n    const certHash = await crypto.hashByName(hashName, peerCert);\n    const bindingData = Buffer.concat([Buffer.from('p=tls-server-end-point,,'), Buffer.from(certHash)]);\n    channelBinding = bindingData.toString('base64');\n  }\n  const clientFinalMessageWithoutProof = 'c=' + channelBinding + ',r=' + sv.nonce;\n  const authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;\n  const saltBytes = Buffer.from(sv.salt, 'base64');\n  const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration);\n  const clientKey = await crypto.hmacSha256(saltedPassword, 'Client Key');\n  const storedKey = await crypto.sha256(clientKey);\n  const clientSignature = await crypto.hmacSha256(storedKey, authMessage);\n  const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString('base64');\n  const serverKey = await crypto.hmacSha256(saltedPassword, 'Server Key');\n  const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage);\n  session.message = 'SASLResponse';\n  session.serverSignature = Buffer.from(serverSignatureBytes).toString('base64');\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;\n}\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse');\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string');\n  }\n  const {\n    serverSignature\n  } = parseServerFinalMessage(serverData);\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match');\n  }\n}\n\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string');\n  }\n  return text.split('').map((_, i) => text.charCodeAt(i)).every(c => c >= 0x21 && c <= 0x2b || c >= 0x2d && c <= 0x7e);\n}\n\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);\n}\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string');\n  }\n  return new Map(text.split(',').map(attrValue => {\n    if (!/^.=/.test(attrValue)) {\n      throw new Error('SASL: Invalid attribute pair entry');\n    }\n    const name = attrValue[0];\n    const value = attrValue.substring(2);\n    return [name, value];\n  }));\n}\nfunction parseServerFirstMessage(data) {\n  const attrPairs = parseAttributePairs(data);\n  const nonce = attrPairs.get('r');\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing');\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters');\n  }\n  const salt = attrPairs.get('s');\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing');\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64');\n  }\n  const iterationText = attrPairs.get('i');\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing');\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count');\n  }\n  const iteration = parseInt(iterationText, 10);\n  return {\n    nonce,\n    salt,\n    iteration\n  };\n}\nfunction parseServerFinalMessage(serverData) {\n  const attrPairs = parseAttributePairs(serverData);\n  const serverSignature = attrPairs.get('v');\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing');\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64');\n  }\n  return {\n    serverSignature\n  };\n}\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer');\n  }\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer');\n  }\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match');\n  }\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty');\n  }\n  return Buffer.from(a.map((_, i) => a[i] ^ b[i]));\n}\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession\n};","map":{"version":3,"names":["crypto","require","signatureAlgorithmHashFromCertificate","startSession","mechanisms","stream","candidates","unshift","mechanism","find","candidate","includes","Error","join","getPeerCertificate","clientNonce","randomBytes","toString","gs2Header","response","message","continueSession","session","password","serverData","sv","parseServerFirstMessage","nonce","startsWith","length","clientFirstMessageBare","serverFirstMessage","salt","iteration","channelBinding","peerCert","raw","hashName","certHash","hashByName","bindingData","Buffer","concat","from","clientFinalMessageWithoutProof","authMessage","saltBytes","saltedPassword","deriveKey","clientKey","hmacSha256","storedKey","sha256","clientSignature","clientProof","xorBuffers","serverKey","serverSignatureBytes","serverSignature","finalizeSession","parseServerFinalMessage","isPrintableChars","text","TypeError","split","map","_","i","charCodeAt","every","c","isBase64","test","parseAttributePairs","Map","attrValue","name","value","substring","data","attrPairs","get","iterationText","parseInt","a","b","isBuffer","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg/lib/crypto/sasl.js"],"sourcesContent":["'use strict'\nconst crypto = require('./utils')\nconst { signatureAlgorithmHashFromCertificate } = require('./cert-signatures')\n\nfunction startSession(mechanisms, stream) {\n  const candidates = ['SCRAM-SHA-256']\n  if (stream) candidates.unshift('SCRAM-SHA-256-PLUS') // higher-priority, so placed first\n\n  const mechanism = candidates.find((candidate) => mechanisms.includes(candidate))\n\n  if (!mechanism) {\n    throw new Error('SASL: Only mechanism(s) ' + candidates.join(' and ') + ' are supported')\n  }\n\n  if (mechanism === 'SCRAM-SHA-256-PLUS' && typeof stream.getPeerCertificate !== 'function') {\n    // this should never happen if we are really talking to a Postgres server\n    throw new Error('SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate')\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64')\n  const gs2Header = mechanism === 'SCRAM-SHA-256-PLUS' ? 'p=tls-server-end-point' : stream ? 'y' : 'n'\n\n  return {\n    mechanism,\n    clientNonce,\n    response: gs2Header + ',,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse',\n  }\n}\n\nasync function continueSession(session, password, serverData, stream) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse')\n  }\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string')\n  }\n  if (password === '') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string')\n  }\n\n  const sv = parseServerFirstMessage(serverData)\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short')\n  }\n\n  const clientFirstMessageBare = 'n=*,r=' + session.clientNonce\n  const serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration\n\n  // without channel binding:\n  let channelBinding = stream ? 'eSws' : 'biws' // 'y,,' or 'n,,', base64-encoded\n\n  // override if channel binding is in use:\n  if (session.mechanism === 'SCRAM-SHA-256-PLUS') {\n    const peerCert = stream.getPeerCertificate().raw\n    let hashName = signatureAlgorithmHashFromCertificate(peerCert)\n    if (hashName === 'MD5' || hashName === 'SHA-1') hashName = 'SHA-256'\n    const certHash = await crypto.hashByName(hashName, peerCert)\n    const bindingData = Buffer.concat([Buffer.from('p=tls-server-end-point,,'), Buffer.from(certHash)])\n    channelBinding = bindingData.toString('base64')\n  }\n\n  const clientFinalMessageWithoutProof = 'c=' + channelBinding + ',r=' + sv.nonce\n  const authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof\n\n  const saltBytes = Buffer.from(sv.salt, 'base64')\n  const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration)\n  const clientKey = await crypto.hmacSha256(saltedPassword, 'Client Key')\n  const storedKey = await crypto.sha256(clientKey)\n  const clientSignature = await crypto.hmacSha256(storedKey, authMessage)\n  const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString('base64')\n  const serverKey = await crypto.hmacSha256(saltedPassword, 'Server Key')\n  const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage)\n\n  session.message = 'SASLResponse'\n  session.serverSignature = Buffer.from(serverSignatureBytes).toString('base64')\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string')\n  }\n\n  const { serverSignature } = parseServerFinalMessage(serverData)\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')\n  }\n}\n\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string')\n  }\n  return text\n    .split('')\n    .map((_, i) => text.charCodeAt(i))\n    .every((c) => (c >= 0x21 && c <= 0x2b) || (c >= 0x2d && c <= 0x7e))\n}\n\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text)\n}\n\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string')\n  }\n\n  return new Map(\n    text.split(',').map((attrValue) => {\n      if (!/^.=/.test(attrValue)) {\n        throw new Error('SASL: Invalid attribute pair entry')\n      }\n      const name = attrValue[0]\n      const value = attrValue.substring(2)\n      return [name, value]\n    })\n  )\n}\n\nfunction parseServerFirstMessage(data) {\n  const attrPairs = parseAttributePairs(data)\n\n  const nonce = attrPairs.get('r')\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters')\n  }\n  const salt = attrPairs.get('s')\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64')\n  }\n  const iterationText = attrPairs.get('i')\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count')\n  }\n  const iteration = parseInt(iterationText, 10)\n\n  return {\n    nonce,\n    salt,\n    iteration,\n  }\n}\n\nfunction parseServerFinalMessage(serverData) {\n  const attrPairs = parseAttributePairs(serverData)\n  const serverSignature = attrPairs.get('v')\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing')\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64')\n  }\n  return {\n    serverSignature,\n  }\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer')\n  }\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer')\n  }\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match')\n  }\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty')\n  }\n  return Buffer.from(a.map((_, i) => a[i] ^ b[i]))\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}