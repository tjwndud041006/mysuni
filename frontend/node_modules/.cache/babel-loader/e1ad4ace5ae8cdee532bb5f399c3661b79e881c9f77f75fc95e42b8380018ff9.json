{"ast":null,"code":"/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict';\n\nconst Predicate = require('./Predicate');\nconst categoryWildCard = '*';\nclass TransformationRule {\n  constructor(c1, c2, predicate, parameter1, parameter2) {\n    this.literal = [c1, c2, predicate, parameter1, parameter2];\n    this.predicate = new Predicate(predicate, parameter1, parameter2);\n    this.oldCategory = c1;\n    this.newCategory = c2;\n    // These members are for the learning algorithm\n    this.neutral = 0;\n    this.negative = 0;\n    this.positive = 0;\n    this.hasBeenSelectedAsHighRuleBefore = false;\n  }\n  key() {\n    return this.literal.toString();\n  }\n  apply(sentence, position) {\n    if (sentence.taggedWords[position].tag === this.oldCategory || this.oldCategory === categoryWildCard) {\n      if (this.predicate.evaluate(sentence, position)) {\n        sentence.taggedWords[position].tag = this.newCategory;\n      }\n    }\n  }\n\n  //\n  // Methods for processing sentences from a corpus that consist of an array of tokens\n  //\n\n  // Returns true if the rule applies at site. As a side effect it assigns the new\n  // category to newTag\n  isApplicableAt(sentence, taggedSentence, i) {\n    const applies = taggedSentence.taggedWords[i].tag === this.oldCategory && this.predicate.evaluate(taggedSentence, i);\n\n    // Set newTag to let the trainer know what the new tag would become\n    if (applies) {\n      sentence.taggedWords[i].newTag = this.newCategory;\n    }\n    return applies;\n  }\n  prettyPrint() {\n    let result = '';\n    // Old category and new category\n    result += this.oldCategory + ' ' + this.newCategory;\n    // Predicate name\n    result += ' ' + this.predicate.name;\n    // Parameter 1 and 2\n    if (this.predicate.parameter1) {\n      result += ' ' + this.predicate.parameter1;\n      if (this.predicate.parameter2) {\n        result += ' ' + this.predicate.parameter2;\n      }\n    }\n    return result;\n  }\n\n  // Applies the rule the given location (if it applies)\n  applyAt(sentence, i) {\n    const taggedSentence = sentence.clone();\n    this.apply(sentence, i);\n    // Assign the new tag to the corpus site\n    sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag;\n  }\n\n  // Calculate the net score of this rule\n  score() {\n    return this.positive - this.negative;\n  }\n}\nmodule.exports = TransformationRule;","map":{"version":3,"names":["Predicate","require","categoryWildCard","TransformationRule","constructor","c1","c2","predicate","parameter1","parameter2","literal","oldCategory","newCategory","neutral","negative","positive","hasBeenSelectedAsHighRuleBefore","key","toString","apply","sentence","position","taggedWords","tag","evaluate","isApplicableAt","taggedSentence","i","applies","newTag","prettyPrint","result","name","applyAt","clone","testTag","score","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/brill_pos_tagger/lib/TransformationRule.js"],"sourcesContent":["/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst Predicate = require('./Predicate')\n\nconst categoryWildCard = '*'\n\nclass TransformationRule {\n  constructor (c1, c2, predicate, parameter1, parameter2) {\n    this.literal = [c1, c2, predicate, parameter1, parameter2]\n    this.predicate = new Predicate(predicate, parameter1, parameter2)\n    this.oldCategory = c1\n    this.newCategory = c2\n    // These members are for the learning algorithm\n    this.neutral = 0\n    this.negative = 0\n    this.positive = 0\n    this.hasBeenSelectedAsHighRuleBefore = false\n  }\n\n  key () {\n    return (this.literal.toString())\n  }\n\n  apply (sentence, position) {\n    if ((sentence.taggedWords[position].tag === this.oldCategory) ||\n        (this.oldCategory === categoryWildCard)) {\n      if (this.predicate.evaluate(sentence, position)) {\n        sentence.taggedWords[position].tag = this.newCategory\n      }\n    }\n  }\n\n  //\n  // Methods for processing sentences from a corpus that consist of an array of tokens\n  //\n\n  // Returns true if the rule applies at site. As a side effect it assigns the new\n  // category to newTag\n  isApplicableAt (sentence, taggedSentence, i) {\n    const applies = (taggedSentence.taggedWords[i].tag === this.oldCategory) &&\n      this.predicate.evaluate(taggedSentence, i)\n\n    // Set newTag to let the trainer know what the new tag would become\n    if (applies) {\n      sentence.taggedWords[i].newTag = this.newCategory\n    }\n    return (applies)\n  }\n\n  prettyPrint () {\n    let result = ''\n    // Old category and new category\n    result += this.oldCategory + ' ' + this.newCategory\n    // Predicate name\n    result += ' ' + this.predicate.name\n    // Parameter 1 and 2\n    if (this.predicate.parameter1) {\n      result += ' ' + this.predicate.parameter1\n      if (this.predicate.parameter2) {\n        result += ' ' + this.predicate.parameter2\n      }\n    }\n    return result\n  }\n\n  // Applies the rule the given location (if it applies)\n  applyAt (sentence, i) {\n    const taggedSentence = sentence.clone()\n\n    this.apply(sentence, i)\n    // Assign the new tag to the corpus site\n    sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag\n  }\n\n  // Calculate the net score of this rule\n  score () {\n    return (this.positive - this.negative)\n  }\n}\n\nmodule.exports = TransformationRule\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}