{"ast":null,"code":"const dollarStub = /\\$[0-9a-z]+/g;\nconst fns = {};\n\n// case logic\nconst isTitleCase = str => /^\\p{Lu}[\\p{Ll}'’]/u.test(str) || /^\\p{Lu}$/u.test(str);\nconst toTitleCase = str => str.replace(/^\\p{Ll}/u, x => x.toUpperCase());\nconst toLowerCase = str => str.replace(/^\\p{Lu}/u, x => x.toLowerCase());\n\n// doc.replace('foo', (m)=>{})\nconst replaceByFn = function (main, fn, keep) {\n  main.forEach(m => {\n    let out = fn(m);\n    m.replaceWith(out, keep);\n  });\n  return main;\n};\n\n// support 'foo $0' replacements\nconst subDollarSign = function (input, main) {\n  if (typeof input !== 'string') {\n    return input;\n  }\n  let groups = main.groups();\n  input = input.replace(dollarStub, a => {\n    let num = a.replace(/\\$/, '');\n    if (groups.hasOwnProperty(num)) {\n      return groups[num].text();\n    }\n    return a;\n  });\n  return input;\n};\nfns.replaceWith = function (input, keep = {}) {\n  let ptrs = this.fullPointer;\n  let main = this;\n  this.uncache();\n  if (typeof input === 'function') {\n    return replaceByFn(main, input, keep);\n  }\n  let terms = main.docs[0];\n  if (!terms) return main;\n  let isOriginalPossessive = keep.possessives && terms[terms.length - 1].tags.has('Possessive');\n  let isOriginalTitleCase = keep.case && isTitleCase(terms[0].text);\n  // support 'foo $0' replacements\n  input = subDollarSign(input, main);\n  let original = this.update(ptrs);\n  // soften-up pointer\n  ptrs = ptrs.map(ptr => ptr.slice(0, 3));\n  // original.freeze()\n  let oldTags = (original.docs[0] || []).map(term => Array.from(term.tags));\n  let originalPre = original.docs[0][0].pre;\n  let originalPost = original.docs[0][original.docs[0].length - 1].post;\n  // slide this in\n  if (typeof input === 'string') {\n    input = this.fromText(input).compute('id');\n  }\n  main.insertAfter(input);\n  // are we replacing part of a contraction?\n  if (original.has('@hasContraction') && main.contractions) {\n    let more = main.grow('@hasContraction+');\n    more.contractions().expand();\n  }\n  // delete the original terms\n  main.delete(original); //science.\n\n  // keep \"John's\"\n  if (isOriginalPossessive) {\n    let tmp = main.docs[0];\n    let term = tmp[tmp.length - 1];\n    if (!term.tags.has('Possessive')) {\n      term.text += \"'s\";\n      term.normal += \"'s\";\n      term.tags.add('Possessive');\n    }\n  }\n\n  // try to keep some pre-punctuation\n  if (originalPre && main.docs[0]) {\n    main.docs[0][0].pre = originalPre;\n  }\n  // try to keep any post-punctuation\n  if (originalPost && main.docs[0]) {\n    let lastOne = main.docs[0][main.docs[0].length - 1];\n    if (!lastOne.post.trim()) {\n      lastOne.post = originalPost;\n    }\n  }\n\n  // what should we return?\n  let m = main.toView(ptrs).compute(['index', 'freeze', 'lexicon']);\n  if (m.world.compute.preTagger) {\n    m.compute('preTagger');\n  }\n  m.compute('unfreeze');\n  // replace any old tags\n  if (keep.tags) {\n    m.terms().forEach((term, i) => {\n      term.tagSafe(oldTags[i]);\n    });\n  }\n  if (!m.docs[0] || !m.docs[0][0]) return m;\n\n  // try to co-erce case, too\n  if (keep.case) {\n    let transformCase = isOriginalTitleCase ? toTitleCase : toLowerCase;\n    m.docs[0][0].text = transformCase(m.docs[0][0].text);\n  }\n\n  // console.log(input.docs[0])\n  // let regs = input.docs[0].map(t => {\n  //   return { id: t.id, optional: true }\n  // })\n  // m.after('(a|hoy)').debug()\n  // m.growRight('(a|hoy)').debug()\n  // console.log(m)\n  return m;\n};\nfns.replace = function (match, input, keep) {\n  if (match && !input) {\n    return this.replaceWith(match, keep);\n  }\n  let m = this.match(match);\n  if (!m.found) {\n    return this;\n  }\n  this.soften();\n  return m.replaceWith(input, keep);\n};\nexport default fns;","map":{"version":3,"names":["dollarStub","fns","isTitleCase","str","test","toTitleCase","replace","x","toUpperCase","toLowerCase","replaceByFn","main","fn","keep","forEach","m","out","replaceWith","subDollarSign","input","groups","a","num","hasOwnProperty","text","ptrs","fullPointer","uncache","terms","docs","isOriginalPossessive","possessives","length","tags","has","isOriginalTitleCase","case","original","update","map","ptr","slice","oldTags","term","Array","from","originalPre","pre","originalPost","post","fromText","compute","insertAfter","contractions","more","grow","expand","delete","tmp","normal","add","lastOne","trim","toView","world","preTagger","i","tagSafe","transformCase","match","found","soften"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/change/api/replace.js"],"sourcesContent":["const dollarStub = /\\$[0-9a-z]+/g\nconst fns = {}\n\n// case logic\nconst isTitleCase = (str) => /^\\p{Lu}[\\p{Ll}'’]/u.test(str) || /^\\p{Lu}$/u.test(str)\nconst toTitleCase = (str) => str.replace(/^\\p{Ll}/u, x => x.toUpperCase())\nconst toLowerCase = (str) => str.replace(/^\\p{Lu}/u, x => x.toLowerCase())\n\n// doc.replace('foo', (m)=>{})\nconst replaceByFn = function (main, fn, keep) {\n  main.forEach(m => {\n    let out = fn(m)\n    m.replaceWith(out, keep)\n  })\n  return main\n}\n\n// support 'foo $0' replacements\nconst subDollarSign = function (input, main) {\n  if (typeof input !== 'string') {\n    return input\n  }\n  let groups = main.groups()\n  input = input.replace(dollarStub, a => {\n    let num = a.replace(/\\$/, '')\n    if (groups.hasOwnProperty(num)) {\n      return groups[num].text()\n    }\n    return a\n  })\n  return input\n}\n\nfns.replaceWith = function (input, keep = {}) {\n  let ptrs = this.fullPointer\n  let main = this\n  this.uncache()\n  if (typeof input === 'function') {\n    return replaceByFn(main, input, keep)\n  }\n  let terms = main.docs[0]\n  if (!terms) return main\n  let isOriginalPossessive = keep.possessives && terms[terms.length - 1].tags.has('Possessive')\n  let isOriginalTitleCase = keep.case && isTitleCase(terms[0].text)\n  // support 'foo $0' replacements\n  input = subDollarSign(input, main)\n\n  let original = this.update(ptrs)\n  // soften-up pointer\n  ptrs = ptrs.map(ptr => ptr.slice(0, 3))\n  // original.freeze()\n  let oldTags = (original.docs[0] || []).map(term => Array.from(term.tags))\n  let originalPre = original.docs[0][0].pre\n  let originalPost = original.docs[0][original.docs[0].length - 1].post\n  // slide this in\n  if (typeof input === 'string') {\n    input = this.fromText(input).compute('id')\n  }\n  main.insertAfter(input)\n  // are we replacing part of a contraction?\n  if (original.has('@hasContraction') && main.contractions) {\n    let more = main.grow('@hasContraction+')\n    more.contractions().expand()\n  }\n  // delete the original terms\n  main.delete(original) //science.\n\n  // keep \"John's\"\n  if (isOriginalPossessive) {\n    let tmp = main.docs[0]\n    let term = tmp[tmp.length - 1]\n    if (!term.tags.has('Possessive')) {\n      term.text += \"'s\"\n      term.normal += \"'s\"\n      term.tags.add('Possessive')\n    }\n  }\n\n  // try to keep some pre-punctuation\n  if (originalPre && main.docs[0]) {\n    main.docs[0][0].pre = originalPre\n  }\n  // try to keep any post-punctuation\n  if (originalPost && main.docs[0]) {\n    let lastOne = main.docs[0][main.docs[0].length - 1]\n    if (!lastOne.post.trim()) {\n      lastOne.post = originalPost\n    }\n  }\n\n  // what should we return?\n  let m = main.toView(ptrs).compute(['index', 'freeze', 'lexicon'])\n  if (m.world.compute.preTagger) {\n    m.compute('preTagger')\n  }\n  m.compute('unfreeze')\n  // replace any old tags\n  if (keep.tags) {\n    m.terms().forEach((term, i) => {\n      term.tagSafe(oldTags[i])\n    })\n  }\n\n  if (!m.docs[0] || !m.docs[0][0]) return m\n\n  // try to co-erce case, too\n  if (keep.case) {\n    let transformCase = isOriginalTitleCase ? toTitleCase : toLowerCase\n    m.docs[0][0].text = transformCase(m.docs[0][0].text)\n  }\n\n  // console.log(input.docs[0])\n  // let regs = input.docs[0].map(t => {\n  //   return { id: t.id, optional: true }\n  // })\n  // m.after('(a|hoy)').debug()\n  // m.growRight('(a|hoy)').debug()\n  // console.log(m)\n  return m\n}\n\nfns.replace = function (match, input, keep) {\n  if (match && !input) {\n    return this.replaceWith(match, keep)\n  }\n  let m = this.match(match)\n  if (!m.found) {\n    return this\n  }\n  this.soften()\n  return m.replaceWith(input, keep)\n}\nexport default fns\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}