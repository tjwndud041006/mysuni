{"ast":null,"code":"// check if two pointers are perfectly consecutive\nconst isNeighbour = function (ptrL, ptrR) {\n  // validate\n  if (!ptrL || !ptrR) {\n    return false;\n  }\n  // same sentence\n  if (ptrL[0] !== ptrR[0]) {\n    return false;\n  }\n  // ensure R starts where L ends\n  return ptrL[2] === ptrR[1];\n};\n\n// join two neighbouring words, if they both match\nconst mergeIf = function (doc, lMatch, rMatch) {\n  const world = doc.world;\n  const parseMatch = world.methods.one.parseMatch;\n  lMatch = lMatch || '.$'; //defaults\n  rMatch = rMatch || '^.';\n  let leftMatch = parseMatch(lMatch, {}, world);\n  let rightMatch = parseMatch(rMatch, {}, world);\n  // ensure end-requirement to left-match, start-requiremnts to right match\n  leftMatch[leftMatch.length - 1].end = true;\n  rightMatch[0].start = true;\n  // let's get going.\n  let ptrs = doc.fullPointer;\n  let res = [ptrs[0]];\n  for (let i = 1; i < ptrs.length; i += 1) {\n    let ptrL = res[res.length - 1];\n    let ptrR = ptrs[i];\n    let left = doc.update([ptrL]);\n    let right = doc.update([ptrR]);\n    // should we marge left+right?\n    if (isNeighbour(ptrL, ptrR) && left.has(leftMatch) && right.has(rightMatch)) {\n      // merge right ptr into existing result\n      res[res.length - 1] = [ptrL[0], ptrL[1], ptrR[2], ptrL[3], ptrR[4]];\n    } else {\n      res.push(ptrR);\n    }\n  }\n  // return new pointers\n  return doc.update(res);\n};\nconst methods = {\n  //  merge only if conditions are met\n  joinIf: function (lMatch, rMatch) {\n    return mergeIf(this, lMatch, rMatch);\n  },\n  // merge all neighbouring matches\n  join: function () {\n    return mergeIf(this);\n  }\n};\nexport default methods;","map":{"version":3,"names":["isNeighbour","ptrL","ptrR","mergeIf","doc","lMatch","rMatch","world","parseMatch","methods","one","leftMatch","rightMatch","length","end","start","ptrs","fullPointer","res","i","left","update","right","has","push","joinIf","join"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/match/api/join.js"],"sourcesContent":["// check if two pointers are perfectly consecutive\nconst isNeighbour = function (ptrL, ptrR) {\n  // validate\n  if (!ptrL || !ptrR) {\n    return false\n  }\n  // same sentence\n  if (ptrL[0] !== ptrR[0]) {\n    return false\n  }\n  // ensure R starts where L ends\n  return ptrL[2] === ptrR[1]\n}\n\n// join two neighbouring words, if they both match\nconst mergeIf = function (doc, lMatch, rMatch) {\n  const world = doc.world\n  const parseMatch = world.methods.one.parseMatch\n  lMatch = lMatch || '.$' //defaults\n  rMatch = rMatch || '^.'\n  let leftMatch = parseMatch(lMatch, {}, world)\n  let rightMatch = parseMatch(rMatch, {}, world)\n  // ensure end-requirement to left-match, start-requiremnts to right match\n  leftMatch[leftMatch.length - 1].end = true\n  rightMatch[0].start = true\n  // let's get going.\n  let ptrs = doc.fullPointer\n  let res = [ptrs[0]]\n  for (let i = 1; i < ptrs.length; i += 1) {\n    let ptrL = res[res.length - 1]\n    let ptrR = ptrs[i]\n    let left = doc.update([ptrL])\n    let right = doc.update([ptrR])\n    // should we marge left+right?\n    if (isNeighbour(ptrL, ptrR) && left.has(leftMatch) && right.has(rightMatch)) {\n      // merge right ptr into existing result\n      res[res.length - 1] = [ptrL[0], ptrL[1], ptrR[2], ptrL[3], ptrR[4]]\n    } else {\n      res.push(ptrR)\n    }\n  }\n  // return new pointers\n  return doc.update(res)\n}\n\nconst methods = {\n  //  merge only if conditions are met\n  joinIf: function (lMatch, rMatch) {\n    return mergeIf(this, lMatch, rMatch)\n  },\n  // merge all neighbouring matches\n  join: function () {\n    return mergeIf(this)\n  },\n}\nexport default methods\n"],"mappings":"AAAA;AACA,MAAMA,WAAW,GAAG,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAE;EACxC;EACA,IAAI,CAACD,IAAI,IAAI,CAACC,IAAI,EAAE;IAClB,OAAO,KAAK;EACd;EACA;EACA,IAAID,IAAI,CAAC,CAAC,CAAC,KAAKC,IAAI,CAAC,CAAC,CAAC,EAAE;IACvB,OAAO,KAAK;EACd;EACA;EACA,OAAOD,IAAI,CAAC,CAAC,CAAC,KAAKC,IAAI,CAAC,CAAC,CAAC;AAC5B,CAAC;;AAED;AACA,MAAMC,OAAO,GAAG,SAAAA,CAAUC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC7C,MAAMC,KAAK,GAAGH,GAAG,CAACG,KAAK;EACvB,MAAMC,UAAU,GAAGD,KAAK,CAACE,OAAO,CAACC,GAAG,CAACF,UAAU;EAC/CH,MAAM,GAAGA,MAAM,IAAI,IAAI,EAAC;EACxBC,MAAM,GAAGA,MAAM,IAAI,IAAI;EACvB,IAAIK,SAAS,GAAGH,UAAU,CAACH,MAAM,EAAE,CAAC,CAAC,EAAEE,KAAK,CAAC;EAC7C,IAAIK,UAAU,GAAGJ,UAAU,CAACF,MAAM,EAAE,CAAC,CAAC,EAAEC,KAAK,CAAC;EAC9C;EACAI,SAAS,CAACA,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC,CAACC,GAAG,GAAG,IAAI;EAC1CF,UAAU,CAAC,CAAC,CAAC,CAACG,KAAK,GAAG,IAAI;EAC1B;EACA,IAAIC,IAAI,GAAGZ,GAAG,CAACa,WAAW;EAC1B,IAAIC,GAAG,GAAG,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;EACnB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACH,MAAM,EAAEM,CAAC,IAAI,CAAC,EAAE;IACvC,IAAIlB,IAAI,GAAGiB,GAAG,CAACA,GAAG,CAACL,MAAM,GAAG,CAAC,CAAC;IAC9B,IAAIX,IAAI,GAAGc,IAAI,CAACG,CAAC,CAAC;IAClB,IAAIC,IAAI,GAAGhB,GAAG,CAACiB,MAAM,CAAC,CAACpB,IAAI,CAAC,CAAC;IAC7B,IAAIqB,KAAK,GAAGlB,GAAG,CAACiB,MAAM,CAAC,CAACnB,IAAI,CAAC,CAAC;IAC9B;IACA,IAAIF,WAAW,CAACC,IAAI,EAAEC,IAAI,CAAC,IAAIkB,IAAI,CAACG,GAAG,CAACZ,SAAS,CAAC,IAAIW,KAAK,CAACC,GAAG,CAACX,UAAU,CAAC,EAAE;MAC3E;MACAM,GAAG,CAACA,GAAG,CAACL,MAAM,GAAG,CAAC,CAAC,GAAG,CAACZ,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEC,IAAI,CAAC,CAAC,CAAC,EAAED,IAAI,CAAC,CAAC,CAAC,EAAEC,IAAI,CAAC,CAAC,CAAC,CAAC;IACrE,CAAC,MAAM;MACLgB,GAAG,CAACM,IAAI,CAACtB,IAAI,CAAC;IAChB;EACF;EACA;EACA,OAAOE,GAAG,CAACiB,MAAM,CAACH,GAAG,CAAC;AACxB,CAAC;AAED,MAAMT,OAAO,GAAG;EACd;EACAgB,MAAM,EAAE,SAAAA,CAAUpB,MAAM,EAAEC,MAAM,EAAE;IAChC,OAAOH,OAAO,CAAC,IAAI,EAAEE,MAAM,EAAEC,MAAM,CAAC;EACtC,CAAC;EACD;EACAoB,IAAI,EAAE,SAAAA,CAAA,EAAY;IAChB,OAAOvB,OAAO,CAAC,IAAI,CAAC;EACtB;AACF,CAAC;AACD,eAAeM,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}