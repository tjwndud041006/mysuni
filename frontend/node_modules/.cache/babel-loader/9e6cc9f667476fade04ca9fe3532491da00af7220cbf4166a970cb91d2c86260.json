{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst utils = require('./utils');\nconst sasl = require('./crypto/sasl');\nconst TypeOverrides = require('./type-overrides');\nconst ConnectionParameters = require('./connection-parameters');\nconst Query = require('./query');\nconst defaults = require('./defaults');\nconst Connection = require('./connection');\nconst crypto = require('./crypto/utils');\nclass Client extends EventEmitter {\n  constructor(config) {\n    super();\n    this.connectionParameters = new ConnectionParameters(config);\n    this.user = this.connectionParameters.user;\n    this.database = this.connectionParameters.database;\n    this.port = this.connectionParameters.port;\n    this.host = this.connectionParameters.host;\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password\n    });\n    this.replication = this.connectionParameters.replication;\n    const c = config || {};\n    this._Promise = c.Promise || global.Promise;\n    this._types = new TypeOverrides(c.types);\n    this._ending = false;\n    this._ended = false;\n    this._connecting = false;\n    this._connected = false;\n    this._connectionError = false;\n    this._queryable = true;\n    this.enableChannelBinding = Boolean(c.enableChannelBinding); // set true to use SCRAM-SHA-256-PLUS when offered\n    this.connection = c.connection || new Connection({\n      stream: c.stream,\n      ssl: this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: this.connectionParameters.client_encoding || 'utf8'\n    });\n    this.queryQueue = [];\n    this.binary = c.binary || defaults.binary;\n    this.processID = null;\n    this.secretKey = null;\n    this.ssl = this.connectionParameters.ssl || false;\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false\n      });\n    }\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n  }\n  _errorAllQueries(err) {\n    const enqueueError = query => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection);\n      });\n    };\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery);\n      this.activeQuery = null;\n    }\n    this.queryQueue.forEach(enqueueError);\n    this.queryQueue.length = 0;\n  }\n  _connect(callback) {\n    const self = this;\n    const con = this.connection;\n    this._connectionCallback = callback;\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.');\n      process.nextTick(() => {\n        callback(err);\n      });\n      return;\n    }\n    this._connecting = true;\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true;\n        con.stream.destroy(new Error('timeout expired'));\n      }, this._connectionTimeoutMillis);\n      if (this.connectionTimeoutHandle.unref) {\n        this.connectionTimeoutHandle.unref();\n      }\n    }\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl();\n      } else {\n        con.startup(self.getStartupConf());\n      }\n    });\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf());\n    });\n    this._attachListeners(con);\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n      clearTimeout(this.connectionTimeoutHandle);\n      this._errorAllQueries(error);\n      this._ended = true;\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error);\n          } else {\n            this._handleErrorEvent(error);\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error);\n        }\n      }\n      process.nextTick(() => {\n        this.emit('end');\n      });\n    });\n  }\n  connect(callback) {\n    if (callback) {\n      this._connect(callback);\n      return;\n    }\n    return new this._Promise((resolve, reject) => {\n      this._connect(error => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this));\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this));\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this));\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this));\n    con.on('error', this._handleErrorEvent.bind(this));\n    con.on('errorMessage', this._handleErrorMessage.bind(this));\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this));\n    con.on('notice', this._handleNotice.bind(this));\n    con.on('rowDescription', this._handleRowDescription.bind(this));\n    con.on('dataRow', this._handleDataRow.bind(this));\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this));\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this));\n    con.on('commandComplete', this._handleCommandComplete.bind(this));\n    con.on('parseComplete', this._handleParseComplete.bind(this));\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this));\n    con.on('copyData', this._handleCopyData.bind(this));\n    con.on('notification', this._handleNotification.bind(this));\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection;\n    if (typeof this.password === 'function') {\n      this._Promise.resolve().then(() => this.password()).then(pass => {\n        if (pass !== undefined) {\n          if (typeof pass !== 'string') {\n            con.emit('error', new TypeError('Password must be a string'));\n            return;\n          }\n          this.connectionParameters.password = this.password = pass;\n        } else {\n          this.connectionParameters.password = this.password = null;\n        }\n        cb();\n      }).catch(err => {\n        con.emit('error', err);\n      });\n    } else if (this.password !== null) {\n      cb();\n    } else {\n      try {\n        const pgPass = require('pgpass');\n        pgPass(this.connectionParameters, pass => {\n          if (undefined !== pass) {\n            this.connectionParameters.password = this.password = pass;\n          }\n          cb();\n        });\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password);\n    });\n  }\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(async () => {\n      try {\n        const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt);\n        this.connection.password(hashedPassword);\n      } catch (e) {\n        this.emit('error', e);\n      }\n    });\n  }\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      try {\n        this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);\n        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);\n      } catch (err) {\n        this.connection.emit('error', err);\n      }\n    });\n  }\n  async _handleAuthSASLContinue(msg) {\n    try {\n      await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);\n    } catch (err) {\n      this.connection.emit('error', err);\n    }\n  }\n  _handleAuthSASLFinal(msg) {\n    try {\n      sasl.finalizeSession(this.saslSession, msg.data);\n      this.saslSession = null;\n    } catch (err) {\n      this.connection.emit('error', err);\n    }\n  }\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID;\n    this.secretKey = msg.secretKey;\n  }\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false;\n      this._connected = true;\n      clearTimeout(this.connectionTimeoutHandle);\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this);\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null;\n      }\n      this.emit('connect');\n    }\n    const {\n      activeQuery\n    } = this;\n    this.activeQuery = null;\n    this.readyForQuery = true;\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection);\n    }\n    this._pulseQueryQueue();\n  }\n\n  // if we receive an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return;\n    }\n    this._connectionError = true;\n    clearTimeout(this.connectionTimeoutHandle);\n    if (this._connectionCallback) {\n      return this._connectionCallback(err);\n    }\n    this.emit('error', err);\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err);\n    }\n    this._queryable = false;\n    this._errorAllQueries(err);\n    this.emit('error', err);\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg);\n    }\n    const activeQuery = this.activeQuery;\n    if (!activeQuery) {\n      this._handleErrorEvent(msg);\n      return;\n    }\n    this.activeQuery = null;\n    activeQuery.handleError(msg, this.connection);\n  }\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg);\n  }\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg);\n  }\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection);\n  }\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection);\n  }\n  _handleCommandComplete(msg) {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected commandComplete message from backend.');\n      this._handleErrorEvent(error);\n      return;\n    }\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection);\n  }\n  _handleParseComplete() {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected parseComplete message from backend.');\n      this._handleErrorEvent(error);\n      return;\n    }\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;\n    }\n  }\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection);\n  }\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection);\n  }\n  _handleNotification(msg) {\n    this.emit('notification', msg);\n  }\n  _handleNotice(msg) {\n    this.emit('notice', msg);\n  }\n  getStartupConf() {\n    const params = this.connectionParameters;\n    const data = {\n      user: params.user,\n      database: params.database\n    };\n    const appName = params.application_name || params.fallback_application_name;\n    if (appName) {\n      data.application_name = appName;\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication;\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n    }\n    if (params.lock_timeout) {\n      data.lock_timeout = String(parseInt(params.lock_timeout, 10));\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n    }\n    if (params.options) {\n      data.options = params.options;\n    }\n    return data;\n  }\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      const con = this.connection;\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port);\n      } else {\n        con.connect(this.port, this.host);\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey);\n      });\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n    }\n  }\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn);\n  }\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format);\n  }\n\n  // escapeIdentifier and escapeLiteral moved to utility functions & exported\n  // on PG\n  // re-exported here for backwards compatibility\n  escapeIdentifier(str) {\n    return utils.escapeIdentifier(str);\n  }\n  escapeLiteral(str) {\n    return utils.escapeLiteral(str);\n  }\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift();\n      if (this.activeQuery) {\n        this.readyForQuery = false;\n        this.hasExecuted = true;\n        const queryError = this.activeQuery.submit(this.connection);\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection);\n            this.readyForQuery = true;\n            this._pulseQueryQueue();\n          });\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null;\n        this.emit('drain');\n      }\n    }\n  }\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    let query;\n    let result;\n    let readTimeout;\n    let readTimeoutTimer;\n    let queryCallback;\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query');\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n      result = query = config;\n      if (typeof values === 'function') {\n        query.callback = query.callback || values;\n      }\n    } else {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n      query = new Query(config, values, callback);\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => err ? reject(err) : resolve(res);\n        }).catch(err => {\n          // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n          // application that created the query\n          Error.captureStackTrace(err);\n          throw err;\n        });\n      }\n    }\n    if (readTimeout) {\n      queryCallback = query.callback;\n      readTimeoutTimer = setTimeout(() => {\n        const error = new Error('Query read timeout');\n        process.nextTick(() => {\n          query.handleError(error, this.connection);\n        });\n        queryCallback(error);\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {};\n\n        // Remove from queue\n        const index = this.queryQueue.indexOf(query);\n        if (index > -1) {\n          this.queryQueue.splice(index, 1);\n        }\n        this._pulseQueryQueue();\n      }, readTimeout);\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer);\n        queryCallback(err, res);\n      };\n    }\n    if (this.binary && !query.binary) {\n      query.binary = true;\n    }\n    if (query._result && !query._result._types) {\n      query._result._types = this._types;\n    }\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n      });\n      return result;\n    }\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n      });\n      return result;\n    }\n    this.queryQueue.push(query);\n    this._pulseQueryQueue();\n    return result;\n  }\n  ref() {\n    this.connection.ref();\n  }\n  unref() {\n    this.connection.unref();\n  }\n  end(cb) {\n    this._ending = true;\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting || this._ended) {\n      if (cb) {\n        cb();\n      } else {\n        return this._Promise.resolve();\n      }\n    }\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy();\n    } else {\n      this.connection.end();\n    }\n    if (cb) {\n      this.connection.once('end', cb);\n    } else {\n      return new this._Promise(resolve => {\n        this.connection.once('end', resolve);\n      });\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query;\nmodule.exports = Client;","map":{"version":3,"names":["EventEmitter","require","utils","sasl","TypeOverrides","ConnectionParameters","Query","defaults","Connection","crypto","Client","constructor","config","connectionParameters","user","database","port","host","Object","defineProperty","configurable","enumerable","writable","value","password","replication","c","_Promise","Promise","global","_types","types","_ending","_ended","_connecting","_connected","_connectionError","_queryable","enableChannelBinding","Boolean","connection","stream","ssl","keepAlive","keepAliveInitialDelayMillis","encoding","client_encoding","queryQueue","binary","processID","secretKey","key","_connectionTimeoutMillis","connectionTimeoutMillis","_errorAllQueries","err","enqueueError","query","process","nextTick","handleError","activeQuery","forEach","length","_connect","callback","self","con","_connectionCallback","Error","connectionTimeoutHandle","setTimeout","destroy","unref","indexOf","connect","on","requestSsl","startup","getStartupConf","_attachListeners","once","error","clearTimeout","_handleErrorEvent","emit","resolve","reject","_handleAuthCleartextPassword","bind","_handleAuthMD5Password","_handleAuthSASL","_handleAuthSASLContinue","_handleAuthSASLFinal","_handleBackendKeyData","_handleErrorMessage","_handleReadyForQuery","_handleNotice","_handleRowDescription","_handleDataRow","_handlePortalSuspended","_handleEmptyQuery","_handleCommandComplete","_handleParseComplete","_handleCopyInResponse","_handleCopyData","_handleNotification","_checkPgPass","cb","then","pass","undefined","TypeError","catch","pgPass","e","msg","hashedPassword","postgresMd5PasswordHash","salt","saslSession","startSession","mechanisms","sendSASLInitialResponseMessage","mechanism","response","continueSession","data","sendSCRAMClientFinalMessage","finalizeSession","readyForQuery","handleReadyForQuery","_pulseQueryQueue","_handleErrorWhileConnecting","handleRowDescription","handleDataRow","handlePortalSuspended","handleEmptyQuery","handleCommandComplete","name","parsedStatements","text","handleCopyInResponse","handleCopyData","params","appName","application_name","fallback_application_name","statement_timeout","String","parseInt","lock_timeout","idle_in_transaction_session_timeout","options","cancel","client","splice","setTypeParser","oid","format","parseFn","getTypeParser","escapeIdentifier","str","escapeLiteral","shift","hasExecuted","queryError","submit","values","result","readTimeout","readTimeoutTimer","queryCallback","query_timeout","res","captureStackTrace","index","_result","push","ref","end","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg/lib/client.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst utils = require('./utils')\nconst sasl = require('./crypto/sasl')\nconst TypeOverrides = require('./type-overrides')\n\nconst ConnectionParameters = require('./connection-parameters')\nconst Query = require('./query')\nconst defaults = require('./defaults')\nconst Connection = require('./connection')\nconst crypto = require('./crypto/utils')\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super()\n\n    this.connectionParameters = new ConnectionParameters(config)\n    this.user = this.connectionParameters.user\n    this.database = this.connectionParameters.database\n    this.port = this.connectionParameters.port\n    this.host = this.connectionParameters.host\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password,\n    })\n\n    this.replication = this.connectionParameters.replication\n\n    const c = config || {}\n\n    this._Promise = c.Promise || global.Promise\n    this._types = new TypeOverrides(c.types)\n    this._ending = false\n    this._ended = false\n    this._connecting = false\n    this._connected = false\n    this._connectionError = false\n    this._queryable = true\n\n    this.enableChannelBinding = Boolean(c.enableChannelBinding) // set true to use SCRAM-SHA-256-PLUS when offered\n    this.connection =\n      c.connection ||\n      new Connection({\n        stream: c.stream,\n        ssl: this.connectionParameters.ssl,\n        keepAlive: c.keepAlive || false,\n        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n        encoding: this.connectionParameters.client_encoding || 'utf8',\n      })\n    this.queryQueue = []\n    this.binary = c.binary || defaults.binary\n    this.processID = null\n    this.secretKey = null\n    this.ssl = this.connectionParameters.ssl || false\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = (query) => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection)\n      })\n    }\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery)\n      this.activeQuery = null\n    }\n\n    this.queryQueue.forEach(enqueueError)\n    this.queryQueue.length = 0\n  }\n\n  _connect(callback) {\n    const self = this\n    const con = this.connection\n    this._connectionCallback = callback\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.')\n      process.nextTick(() => {\n        callback(err)\n      })\n      return\n    }\n    this._connecting = true\n\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true\n        con.stream.destroy(new Error('timeout expired'))\n      }, this._connectionTimeoutMillis)\n\n      if (this.connectionTimeoutHandle.unref) {\n        this.connectionTimeoutHandle.unref()\n      }\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl()\n      } else {\n        con.startup(self.getStartupConf())\n      }\n    })\n\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf())\n    })\n\n    this._attachListeners(con)\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n      clearTimeout(this.connectionTimeoutHandle)\n      this._errorAllQueries(error)\n      this._ended = true\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error)\n          } else {\n            this._handleErrorEvent(error)\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error)\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end')\n      })\n    })\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback)\n      return\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect((error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this))\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this))\n    con.on('error', this._handleErrorEvent.bind(this))\n    con.on('errorMessage', this._handleErrorMessage.bind(this))\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this))\n    con.on('notice', this._handleNotice.bind(this))\n    con.on('rowDescription', this._handleRowDescription.bind(this))\n    con.on('dataRow', this._handleDataRow.bind(this))\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this))\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this))\n    con.on('commandComplete', this._handleCommandComplete.bind(this))\n    con.on('parseComplete', this._handleParseComplete.bind(this))\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this))\n    con.on('copyData', this._handleCopyData.bind(this))\n    con.on('notification', this._handleNotification.bind(this))\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection\n    if (typeof this.password === 'function') {\n      this._Promise\n        .resolve()\n        .then(() => this.password())\n        .then((pass) => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'))\n              return\n            }\n            this.connectionParameters.password = this.password = pass\n          } else {\n            this.connectionParameters.password = this.password = null\n          }\n          cb()\n        })\n        .catch((err) => {\n          con.emit('error', err)\n        })\n    } else if (this.password !== null) {\n      cb()\n    } else {\n      try {\n        const pgPass = require('pgpass')\n        pgPass(this.connectionParameters, (pass) => {\n          if (undefined !== pass) {\n            this.connectionParameters.password = this.password = pass\n          }\n          cb()\n        })\n      } catch (e) {\n        this.emit('error', e)\n      }\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password)\n    })\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(async () => {\n      try {\n        const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt)\n        this.connection.password(hashedPassword)\n      } catch (e) {\n        this.emit('error', e)\n      }\n    })\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      try {\n        this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream)\n        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)\n      } catch (err) {\n        this.connection.emit('error', err)\n      }\n    })\n  }\n\n  async _handleAuthSASLContinue(msg) {\n    try {\n      await sasl.continueSession(\n        this.saslSession,\n        this.password,\n        msg.data,\n        this.enableChannelBinding && this.connection.stream\n      )\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleAuthSASLFinal(msg) {\n    try {\n      sasl.finalizeSession(this.saslSession, msg.data)\n      this.saslSession = null\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID\n    this.secretKey = msg.secretKey\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false\n      this._connected = true\n      clearTimeout(this.connectionTimeoutHandle)\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this)\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null\n      }\n      this.emit('connect')\n    }\n    const { activeQuery } = this\n    this.activeQuery = null\n    this.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection)\n    }\n    this._pulseQueryQueue()\n  }\n\n  // if we receive an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return\n    }\n    this._connectionError = true\n    clearTimeout(this.connectionTimeoutHandle)\n    if (this._connectionCallback) {\n      return this._connectionCallback(err)\n    }\n    this.emit('error', err)\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err)\n    }\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg)\n    }\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, this.connection)\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg)\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg)\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection)\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection)\n  }\n\n  _handleCommandComplete(msg) {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected commandComplete message from backend.')\n      this._handleErrorEvent(error)\n      return\n    }\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection)\n  }\n\n  _handleParseComplete() {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected parseComplete message from backend.')\n      this._handleErrorEvent(error)\n      return\n    }\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection)\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection)\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg)\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg)\n  }\n\n  getStartupConf() {\n    const params = this.connectionParameters\n\n    const data = {\n      user: params.user,\n      database: params.database,\n    }\n\n    const appName = params.application_name || params.fallback_application_name\n    if (appName) {\n      data.application_name = appName\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n    }\n    if (params.lock_timeout) {\n      data.lock_timeout = String(parseInt(params.lock_timeout, 10))\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n    }\n    if (params.options) {\n      data.options = params.options\n    }\n\n    return data\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      const con = this.connection\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port)\n      } else {\n        con.connect(this.port, this.host)\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey)\n      })\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn)\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format)\n  }\n\n  // escapeIdentifier and escapeLiteral moved to utility functions & exported\n  // on PG\n  // re-exported here for backwards compatibility\n  escapeIdentifier(str) {\n    return utils.escapeIdentifier(str)\n  }\n\n  escapeLiteral(str) {\n    return utils.escapeLiteral(str)\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift()\n      if (this.activeQuery) {\n        this.readyForQuery = false\n        this.hasExecuted = true\n\n        const queryError = this.activeQuery.submit(this.connection)\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection)\n            this.readyForQuery = true\n            this._pulseQueryQueue()\n          })\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null\n        this.emit('drain')\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    let query\n    let result\n    let readTimeout\n    let readTimeoutTimer\n    let queryCallback\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query')\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      result = query = config\n      if (typeof values === 'function') {\n        query.callback = query.callback || values\n      }\n    } else {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      query = new Query(config, values, callback)\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => (err ? reject(err) : resolve(res))\n        }).catch((err) => {\n          // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n          // application that created the query\n          Error.captureStackTrace(err)\n          throw err\n        })\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback\n\n      readTimeoutTimer = setTimeout(() => {\n        const error = new Error('Query read timeout')\n\n        process.nextTick(() => {\n          query.handleError(error, this.connection)\n        })\n\n        queryCallback(error)\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {}\n\n        // Remove from queue\n        const index = this.queryQueue.indexOf(query)\n        if (index > -1) {\n          this.queryQueue.splice(index, 1)\n        }\n\n        this._pulseQueryQueue()\n      }, readTimeout)\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer)\n        queryCallback(err, res)\n      }\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    this.queryQueue.push(query)\n    this._pulseQueryQueue()\n    return result\n  }\n\n  ref() {\n    this.connection.ref()\n  }\n\n  unref() {\n    this.connection.unref()\n  }\n\n  end(cb) {\n    this._ending = true\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting || this._ended) {\n      if (cb) {\n        cb()\n      } else {\n        return this._Promise.resolve()\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy()\n    } else {\n      this.connection.end()\n    }\n\n    if (cb) {\n      this.connection.once('end', cb)\n    } else {\n      return new this._Promise((resolve) => {\n        this.connection.once('end', resolve)\n      })\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}