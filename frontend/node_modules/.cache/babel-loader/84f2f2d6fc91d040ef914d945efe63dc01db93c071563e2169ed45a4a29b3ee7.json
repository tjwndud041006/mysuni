{"ast":null,"code":"const max = 20;\n\n// sweep-around looking for our start term uuid\nconst blindSweep = function (id, doc, n) {\n  for (let i = 0; i < max; i += 1) {\n    // look up a sentence\n    if (doc[n - i]) {\n      let index = doc[n - i].findIndex(term => term.id === id);\n      if (index !== -1) {\n        return [n - i, index];\n      }\n    }\n    // look down a sentence\n    if (doc[n + i]) {\n      let index = doc[n + i].findIndex(term => term.id === id);\n      if (index !== -1) {\n        return [n + i, index];\n      }\n    }\n  }\n  return null;\n};\nconst repairEnding = function (ptr, document) {\n  let [n, start,,, endId] = ptr;\n  let terms = document[n];\n  // look for end-id\n  let newEnd = terms.findIndex(t => t.id === endId);\n  if (newEnd === -1) {\n    // if end-term wasn't found, so go all the way to the end\n    ptr[2] = document[n].length;\n    ptr[4] = terms.length ? terms[terms.length - 1].id : null;\n  } else {\n    ptr[2] = newEnd; // repair ending pointer\n  }\n  return document[n].slice(start, ptr[2] + 1);\n};\n\n/** return a subset of the document, from a pointer */\nconst getDoc = function (ptrs, document) {\n  let doc = [];\n  ptrs.forEach((ptr, i) => {\n    if (!ptr) {\n      return;\n    }\n    let [n, start, end, id, endId] = ptr; //parsePointer(ptr)\n    let terms = document[n] || [];\n    if (start === undefined) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = terms.length;\n    }\n    if (id && (!terms[start] || terms[start].id !== id)) {\n      // console.log('  repairing pointer...')\n      let wild = blindSweep(id, document, n);\n      if (wild !== null) {\n        let len = end - start;\n        terms = document[wild[0]].slice(wild[1], wild[1] + len);\n        // actually change the pointer\n        let startId = terms[0] ? terms[0].id : null;\n        ptrs[i] = [wild[0], wild[1], wild[1] + len, startId];\n      }\n    } else {\n      terms = terms.slice(start, end);\n    }\n    if (terms.length === 0) {\n      return;\n    }\n    if (start === end) {\n      return;\n    }\n    // test end-id, if it exists\n    if (endId && terms[terms.length - 1].id !== endId) {\n      terms = repairEnding(ptr, document);\n    }\n    // otherwise, looks good!\n    doc.push(terms);\n  });\n  doc = doc.filter(a => a.length > 0);\n  return doc;\n};\nexport default getDoc;","map":{"version":3,"names":["max","blindSweep","id","doc","n","i","index","findIndex","term","repairEnding","ptr","document","start","endId","terms","newEnd","t","length","slice","getDoc","ptrs","forEach","end","undefined","wild","len","startId","push","filter","a"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/pointers/methods/getDoc.js"],"sourcesContent":["const max = 20\n\n// sweep-around looking for our start term uuid\nconst blindSweep = function (id, doc, n) {\n  for (let i = 0; i < max; i += 1) {\n    // look up a sentence\n    if (doc[n - i]) {\n      let index = doc[n - i].findIndex(term => term.id === id)\n      if (index !== -1) {\n        return [n - i, index]\n      }\n    }\n    // look down a sentence\n    if (doc[n + i]) {\n      let index = doc[n + i].findIndex(term => term.id === id)\n      if (index !== -1) {\n        return [n + i, index]\n      }\n    }\n  }\n  return null\n}\n\nconst repairEnding = function (ptr, document) {\n  let [n, start, , , endId] = ptr\n  let terms = document[n]\n  // look for end-id\n  let newEnd = terms.findIndex(t => t.id === endId)\n  if (newEnd === -1) {\n    // if end-term wasn't found, so go all the way to the end\n    ptr[2] = document[n].length\n    ptr[4] = terms.length ? terms[terms.length - 1].id : null\n  } else {\n    ptr[2] = newEnd // repair ending pointer\n  }\n  return document[n].slice(start, ptr[2] + 1)\n}\n\n/** return a subset of the document, from a pointer */\nconst getDoc = function (ptrs, document) {\n  let doc = []\n  ptrs.forEach((ptr, i) => {\n    if (!ptr) {\n      return\n    }\n    let [n, start, end, id, endId] = ptr //parsePointer(ptr)\n    let terms = document[n] || []\n    if (start === undefined) {\n      start = 0\n    }\n    if (end === undefined) {\n      end = terms.length\n    }\n    if (id && (!terms[start] || terms[start].id !== id)) {\n      // console.log('  repairing pointer...')\n      let wild = blindSweep(id, document, n)\n      if (wild !== null) {\n        let len = end - start\n        terms = document[wild[0]].slice(wild[1], wild[1] + len)\n        // actually change the pointer\n        let startId = terms[0] ? terms[0].id : null\n        ptrs[i] = [wild[0], wild[1], wild[1] + len, startId]\n      }\n    } else {\n      terms = terms.slice(start, end)\n    }\n    if (terms.length === 0) {\n      return\n    }\n    if (start === end) {\n      return\n    }\n    // test end-id, if it exists\n    if (endId && terms[terms.length - 1].id !== endId) {\n      terms = repairEnding(ptr, document)\n    }\n    // otherwise, looks good!\n    doc.push(terms)\n  })\n  doc = doc.filter(a => a.length > 0)\n  return doc\n}\nexport default getDoc"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}