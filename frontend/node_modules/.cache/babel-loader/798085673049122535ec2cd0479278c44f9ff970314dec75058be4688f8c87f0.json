{"ast":null,"code":"import fastTag from '../_fastTag.js';\n\n//sweep-through all suffixes\nconst suffixLoop = function (str = '', suffixes = []) {\n  const len = str.length;\n  let max = 7;\n  if (len <= max) {\n    max = len - 1;\n  }\n  for (let i = max; i > 1; i -= 1) {\n    let suffix = str.substring(len - i, len);\n    if (suffixes[suffix.length].hasOwnProperty(suffix) === true) {\n      // console.log(suffix)\n      let tag = suffixes[suffix.length][suffix];\n      return tag;\n    }\n  }\n  return null;\n};\n\n// decide tag from the ending of the word\nconst tagBySuffix = function (terms, i, model) {\n  let term = terms[i];\n  if (term.tags.size === 0) {\n    let tag = suffixLoop(term.normal, model.two.suffixPatterns);\n    if (tag !== null) {\n      fastTag(term, tag, '2-suffix');\n      term.confidence = 0.7;\n      return true;\n    }\n    // try implicit form of word, too\n    if (term.implicit) {\n      tag = suffixLoop(term.implicit, model.two.suffixPatterns);\n      if (tag !== null) {\n        fastTag(term, tag, '2-implicit-suffix');\n        term.confidence = 0.7;\n        return true;\n      }\n    }\n    // Infinitive suffix + 's' can be PresentTense\n    // if (term.normal[term.normal.length - 1] === 's') {\n    //   let str = term.normal.replace(/s$/, '')\n    //   if (suffixLoop(str, model.two.suffixPatterns) === 'Infinitive') {\n    //     console.log(str)\n    //     fastTag(term, 'PresentTense', '2-implied-present')\n    //     term.confidence = 0.5\n    //     return true\n    //   }\n    // }\n  }\n  return null;\n};\nexport default tagBySuffix;","map":{"version":3,"names":["fastTag","suffixLoop","str","suffixes","len","length","max","i","suffix","substring","hasOwnProperty","tag","tagBySuffix","terms","model","term","tags","size","normal","two","suffixPatterns","confidence","implicit"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/02-suffix.js"],"sourcesContent":["import fastTag from '../_fastTag.js'\n\n//sweep-through all suffixes\nconst suffixLoop = function (str = '', suffixes = []) {\n  const len = str.length\n  let max = 7\n  if (len <= max) {\n    max = len - 1\n  }\n  for (let i = max; i > 1; i -= 1) {\n    let suffix = str.substring(len - i, len)\n    if (suffixes[suffix.length].hasOwnProperty(suffix) === true) {\n      // console.log(suffix)\n      let tag = suffixes[suffix.length][suffix]\n      return tag\n    }\n  }\n  return null\n}\n\n// decide tag from the ending of the word\nconst tagBySuffix = function (terms, i, model) {\n  let term = terms[i]\n  if (term.tags.size === 0) {\n    let tag = suffixLoop(term.normal, model.two.suffixPatterns)\n    if (tag !== null) {\n      fastTag(term, tag, '2-suffix')\n      term.confidence = 0.7\n      return true\n    }\n    // try implicit form of word, too\n    if (term.implicit) {\n      tag = suffixLoop(term.implicit, model.two.suffixPatterns)\n      if (tag !== null) {\n        fastTag(term, tag, '2-implicit-suffix')\n        term.confidence = 0.7\n        return true\n      }\n    }\n    // Infinitive suffix + 's' can be PresentTense\n    // if (term.normal[term.normal.length - 1] === 's') {\n    //   let str = term.normal.replace(/s$/, '')\n    //   if (suffixLoop(str, model.two.suffixPatterns) === 'Infinitive') {\n    //     console.log(str)\n    //     fastTag(term, 'PresentTense', '2-implied-present')\n    //     term.confidence = 0.5\n    //     return true\n    //   }\n    // }\n  }\n  return null\n}\nexport default tagBySuffix\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,gBAAgB;;AAEpC;AACA,MAAMC,UAAU,GAAG,SAAAA,CAAUC,GAAG,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,EAAE;EACpD,MAAMC,GAAG,GAAGF,GAAG,CAACG,MAAM;EACtB,IAAIC,GAAG,GAAG,CAAC;EACX,IAAIF,GAAG,IAAIE,GAAG,EAAE;IACdA,GAAG,GAAGF,GAAG,GAAG,CAAC;EACf;EACA,KAAK,IAAIG,CAAC,GAAGD,GAAG,EAAEC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC/B,IAAIC,MAAM,GAAGN,GAAG,CAACO,SAAS,CAACL,GAAG,GAAGG,CAAC,EAAEH,GAAG,CAAC;IACxC,IAAID,QAAQ,CAACK,MAAM,CAACH,MAAM,CAAC,CAACK,cAAc,CAACF,MAAM,CAAC,KAAK,IAAI,EAAE;MAC3D;MACA,IAAIG,GAAG,GAAGR,QAAQ,CAACK,MAAM,CAACH,MAAM,CAAC,CAACG,MAAM,CAAC;MACzC,OAAOG,GAAG;IACZ;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA,MAAMC,WAAW,GAAG,SAAAA,CAAUC,KAAK,EAAEN,CAAC,EAAEO,KAAK,EAAE;EAC7C,IAAIC,IAAI,GAAGF,KAAK,CAACN,CAAC,CAAC;EACnB,IAAIQ,IAAI,CAACC,IAAI,CAACC,IAAI,KAAK,CAAC,EAAE;IACxB,IAAIN,GAAG,GAAGV,UAAU,CAACc,IAAI,CAACG,MAAM,EAAEJ,KAAK,CAACK,GAAG,CAACC,cAAc,CAAC;IAC3D,IAAIT,GAAG,KAAK,IAAI,EAAE;MAChBX,OAAO,CAACe,IAAI,EAAEJ,GAAG,EAAE,UAAU,CAAC;MAC9BI,IAAI,CAACM,UAAU,GAAG,GAAG;MACrB,OAAO,IAAI;IACb;IACA;IACA,IAAIN,IAAI,CAACO,QAAQ,EAAE;MACjBX,GAAG,GAAGV,UAAU,CAACc,IAAI,CAACO,QAAQ,EAAER,KAAK,CAACK,GAAG,CAACC,cAAc,CAAC;MACzD,IAAIT,GAAG,KAAK,IAAI,EAAE;QAChBX,OAAO,CAACe,IAAI,EAAEJ,GAAG,EAAE,mBAAmB,CAAC;QACvCI,IAAI,CAACM,UAAU,GAAG,GAAG;QACrB,OAAO,IAAI;MACb;IACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACF;EACA,OAAO,IAAI;AACb,CAAC;AACD,eAAeT,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}