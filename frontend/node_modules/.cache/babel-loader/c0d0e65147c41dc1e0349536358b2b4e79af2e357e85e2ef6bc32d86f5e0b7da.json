{"ast":null,"code":"import { convert } from 'suffix-thumb';\nimport getTense from '../getTense/index.js';\nconst toParts = function (str, model) {\n  let prefix = '';\n  let prefixes = {};\n  if (model.one && model.one.prefixes) {\n    prefixes = model.one.prefixes;\n  }\n  // pull-apart phrasal verb 'fall over'\n  let [verb, particle] = str.split(/ /);\n  // support 'over cleaned'\n  if (particle && prefixes[verb] === true) {\n    prefix = verb;\n    verb = particle;\n    particle = '';\n  }\n  return {\n    prefix,\n    verb,\n    particle\n  };\n};\n\n// dunno about these..\nconst copulaMap = {\n  are: 'be',\n  were: 'be',\n  been: 'be',\n  is: 'be',\n  am: 'be',\n  was: 'be',\n  be: 'be',\n  being: 'be'\n};\nconst toInfinitive = function (str, model, tense) {\n  const {\n    fromPast,\n    fromPresent,\n    fromGerund,\n    fromParticiple\n  } = model.two.models;\n  let {\n    prefix,\n    verb,\n    particle\n  } = toParts(str, model);\n  let inf = '';\n  if (!tense) {\n    tense = getTense(str);\n  }\n  if (copulaMap.hasOwnProperty(str)) {\n    inf = copulaMap[str];\n  } else if (tense === 'Participle') {\n    inf = convert(verb, fromParticiple);\n  } else if (tense === 'PastTense') {\n    inf = convert(verb, fromPast);\n  } else if (tense === 'PresentTense') {\n    inf = convert(verb, fromPresent);\n  } else if (tense === 'Gerund') {\n    inf = convert(verb, fromGerund);\n  } else {\n    return str;\n  }\n\n  // stitch phrasal back on\n  if (particle) {\n    inf += ' ' + particle;\n  }\n  // stitch prefix back on\n  if (prefix) {\n    inf = prefix + ' ' + inf;\n  }\n  return inf;\n};\nexport default toInfinitive;\n\n// console.log(toInfinitive('snarled', { one: {} }))\n// console.log(convert('snarled', fromPast))","map":{"version":3,"names":["convert","getTense","toParts","str","model","prefix","prefixes","one","verb","particle","split","copulaMap","are","were","been","is","am","was","be","being","toInfinitive","tense","fromPast","fromPresent","fromGerund","fromParticiple","two","models","inf","hasOwnProperty"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/toInfinitive/index.js"],"sourcesContent":["import { convert } from 'suffix-thumb'\nimport getTense from '../getTense/index.js'\n\nconst toParts = function (str, model) {\n  let prefix = ''\n  let prefixes = {}\n  if (model.one && model.one.prefixes) {\n    prefixes = model.one.prefixes\n  }\n  // pull-apart phrasal verb 'fall over'\n  let [verb, particle] = str.split(/ /)\n  // support 'over cleaned'\n  if (particle && prefixes[verb] === true) {\n    prefix = verb\n    verb = particle\n    particle = ''\n  }\n  return {\n    prefix, verb, particle\n  }\n}\n\n\n// dunno about these..\nconst copulaMap = {\n  are: 'be',\n  were: 'be',\n  been: 'be',\n  is: 'be',\n  am: 'be',\n  was: 'be',\n  be: 'be',\n  being: 'be',\n}\n\nconst toInfinitive = function (str, model, tense) {\n  const { fromPast, fromPresent, fromGerund, fromParticiple } = model.two.models\n  let { prefix, verb, particle } = toParts(str, model)\n  let inf = ''\n  if (!tense) {\n    tense = getTense(str)\n  }\n  if (copulaMap.hasOwnProperty(str)) {\n    inf = copulaMap[str]\n  } else if (tense === 'Participle') {\n    inf = convert(verb, fromParticiple)\n  } else if (tense === 'PastTense') {\n    inf = convert(verb, fromPast)\n  } else if (tense === 'PresentTense') {\n    inf = convert(verb, fromPresent)\n  } else if (tense === 'Gerund') {\n    inf = convert(verb, fromGerund)\n  } else {\n    return str\n  }\n\n  // stitch phrasal back on\n  if (particle) {\n    inf += ' ' + particle\n  }\n  // stitch prefix back on\n  if (prefix) {\n    inf = prefix + ' ' + inf\n  }\n  return inf\n}\nexport default toInfinitive\n\n// console.log(toInfinitive('snarled', { one: {} }))\n// console.log(convert('snarled', fromPast))"],"mappings":"AAAA,SAASA,OAAO,QAAQ,cAAc;AACtC,OAAOC,QAAQ,MAAM,sBAAsB;AAE3C,MAAMC,OAAO,GAAG,SAAAA,CAAUC,GAAG,EAAEC,KAAK,EAAE;EACpC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,QAAQ,GAAG,CAAC,CAAC;EACjB,IAAIF,KAAK,CAACG,GAAG,IAAIH,KAAK,CAACG,GAAG,CAACD,QAAQ,EAAE;IACnCA,QAAQ,GAAGF,KAAK,CAACG,GAAG,CAACD,QAAQ;EAC/B;EACA;EACA,IAAI,CAACE,IAAI,EAAEC,QAAQ,CAAC,GAAGN,GAAG,CAACO,KAAK,CAAC,GAAG,CAAC;EACrC;EACA,IAAID,QAAQ,IAAIH,QAAQ,CAACE,IAAI,CAAC,KAAK,IAAI,EAAE;IACvCH,MAAM,GAAGG,IAAI;IACbA,IAAI,GAAGC,QAAQ;IACfA,QAAQ,GAAG,EAAE;EACf;EACA,OAAO;IACLJ,MAAM;IAAEG,IAAI;IAAEC;EAChB,CAAC;AACH,CAAC;;AAGD;AACA,MAAME,SAAS,GAAG;EAChBC,GAAG,EAAE,IAAI;EACTC,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE,IAAI;EACVC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,GAAG,EAAE,IAAI;EACTC,EAAE,EAAE,IAAI;EACRC,KAAK,EAAE;AACT,CAAC;AAED,MAAMC,YAAY,GAAG,SAAAA,CAAUjB,GAAG,EAAEC,KAAK,EAAEiB,KAAK,EAAE;EAChD,MAAM;IAAEC,QAAQ;IAAEC,WAAW;IAAEC,UAAU;IAAEC;EAAe,CAAC,GAAGrB,KAAK,CAACsB,GAAG,CAACC,MAAM;EAC9E,IAAI;IAAEtB,MAAM;IAAEG,IAAI;IAAEC;EAAS,CAAC,GAAGP,OAAO,CAACC,GAAG,EAAEC,KAAK,CAAC;EACpD,IAAIwB,GAAG,GAAG,EAAE;EACZ,IAAI,CAACP,KAAK,EAAE;IACVA,KAAK,GAAGpB,QAAQ,CAACE,GAAG,CAAC;EACvB;EACA,IAAIQ,SAAS,CAACkB,cAAc,CAAC1B,GAAG,CAAC,EAAE;IACjCyB,GAAG,GAAGjB,SAAS,CAACR,GAAG,CAAC;EACtB,CAAC,MAAM,IAAIkB,KAAK,KAAK,YAAY,EAAE;IACjCO,GAAG,GAAG5B,OAAO,CAACQ,IAAI,EAAEiB,cAAc,CAAC;EACrC,CAAC,MAAM,IAAIJ,KAAK,KAAK,WAAW,EAAE;IAChCO,GAAG,GAAG5B,OAAO,CAACQ,IAAI,EAAEc,QAAQ,CAAC;EAC/B,CAAC,MAAM,IAAID,KAAK,KAAK,cAAc,EAAE;IACnCO,GAAG,GAAG5B,OAAO,CAACQ,IAAI,EAAEe,WAAW,CAAC;EAClC,CAAC,MAAM,IAAIF,KAAK,KAAK,QAAQ,EAAE;IAC7BO,GAAG,GAAG5B,OAAO,CAACQ,IAAI,EAAEgB,UAAU,CAAC;EACjC,CAAC,MAAM;IACL,OAAOrB,GAAG;EACZ;;EAEA;EACA,IAAIM,QAAQ,EAAE;IACZmB,GAAG,IAAI,GAAG,GAAGnB,QAAQ;EACvB;EACA;EACA,IAAIJ,MAAM,EAAE;IACVuB,GAAG,GAAGvB,MAAM,GAAG,GAAG,GAAGuB,GAAG;EAC1B;EACA,OAAOA,GAAG;AACZ,CAAC;AACD,eAAeR,YAAY;;AAE3B;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}