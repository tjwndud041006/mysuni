{"ast":null,"code":"import find from '../find.js';\nimport toJSON from './toJSON.js';\nimport parseVerb from './parse/index.js';\nimport toInf from './conjugate/toInfinitive.js';\nimport toPast from './conjugate/toPast.js';\nimport toParticiple from './conjugate/toParticiple.js';\nimport toPresent from './conjugate/toPresent.js';\nimport toFuture from './conjugate/toFuture.js';\nimport toGerund from './conjugate/toGerund.js';\nimport getSubject from './parse/getSubject.js';\nimport getGrammar from './parse/grammar/index.js';\nimport toNegative from './conjugate/toNegative.js';\nimport { getTense } from './lib.js';\nconst api = function (View) {\n  class Verbs extends View {\n    constructor(document, pointer, groups) {\n      super(document, pointer, groups);\n      this.viewType = 'Verbs';\n    }\n    parse(n) {\n      return this.getNth(n).map(parseVerb);\n    }\n    json(opts, n) {\n      let m = this.getNth(n);\n      let arr = m.map(vb => {\n        let json = vb.toView().json(opts)[0] || {};\n        json.verb = toJSON(vb);\n        return json;\n      }, []);\n      return arr;\n    }\n    subjects(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        return getSubject(vb, parsed).subject;\n      });\n    }\n    adverbs(n) {\n      return this.getNth(n).map(vb => vb.match('#Adverb'));\n    }\n    isSingular(n) {\n      return this.getNth(n).filter(vb => {\n        return getSubject(vb).plural !== true;\n      });\n    }\n    isPlural(n) {\n      return this.getNth(n).filter(vb => {\n        return getSubject(vb).plural === true;\n      });\n    }\n    isImperative(n) {\n      return this.getNth(n).filter(vb => vb.has('#Imperative'));\n    }\n    toInfinitive(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        return toInf(vb, parsed, info.form);\n      });\n    }\n    toPresentTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        if (info.isInfinitive) {\n          return vb;\n        }\n        return toPresent(vb, parsed, info.form);\n      });\n    }\n    toPastTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        if (info.isInfinitive) {\n          return vb;\n        }\n        return toPast(vb, parsed, info.form);\n      });\n    }\n    toFutureTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        if (info.isInfinitive) {\n          return vb;\n        }\n        return toFuture(vb, parsed, info.form);\n      });\n    }\n    toGerund(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        if (info.isInfinitive) {\n          return vb;\n        }\n        return toGerund(vb, parsed, info.form);\n      });\n    }\n    toPastParticiple(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        if (info.isInfinitive) {\n          return vb;\n        }\n        return toParticiple(vb, parsed, info.form);\n      });\n    }\n    conjugate(n) {\n      const {\n        conjugate,\n        toInfinitive\n      } = this.world.methods.two.transform.verb;\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        // allow imperatives like 'go!' to be conjugated here (only)\n        if (info.form === 'imperative') {\n          info.form = 'simple-present';\n        }\n        let inf = parsed.root.text('normal');\n        if (!parsed.root.has('#Infinitive')) {\n          let tense = getTense(parsed.root);\n          inf = toInfinitive(inf, vb.model, tense) || inf;\n        }\n        return conjugate(inf, vb.model);\n      }, []);\n    }\n\n    /** return only verbs with 'not'*/\n    isNegative() {\n      return this.if('#Negative');\n    }\n    /**  return only verbs without 'not'*/\n    isPositive() {\n      return this.ifNo('#Negative');\n    }\n    /** remove 'not' from these verbs */\n    toPositive() {\n      let m = this.match('do not #Verb');\n      if (m.found) {\n        m.remove('do not');\n      }\n      return this.remove('#Negative');\n    }\n    toNegative(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb);\n        let info = getGrammar(vb, parsed);\n        return toNegative(vb, parsed, info.form);\n      });\n    }\n    // overloaded - keep Verb class\n    update(pointer) {\n      let m = new Verbs(this.document, pointer);\n      m._cache = this._cache; // share this full thing\n      return m;\n    }\n  }\n  Verbs.prototype.toPast = Verbs.prototype.toPastTense;\n  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;\n  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;\n  View.prototype.verbs = function (n) {\n    let vb = find(this);\n    vb = vb.getNth(n);\n    return new Verbs(this.document, vb.pointer);\n  };\n};\nexport default api;","map":{"version":3,"names":["find","toJSON","parseVerb","toInf","toPast","toParticiple","toPresent","toFuture","toGerund","getSubject","getGrammar","toNegative","getTense","api","View","Verbs","constructor","document","pointer","groups","viewType","parse","n","getNth","map","json","opts","m","arr","vb","toView","verb","subjects","parsed","subject","adverbs","match","isSingular","filter","plural","isPlural","isImperative","has","toInfinitive","info","form","toPresentTense","isInfinitive","toPastTense","toFutureTense","toPastParticiple","conjugate","world","methods","two","transform","inf","root","text","tense","model","isNegative","if","isPositive","ifNo","toPositive","found","remove","update","_cache","prototype","verbs"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/api.js"],"sourcesContent":["import find from '../find.js'\nimport toJSON from './toJSON.js'\nimport parseVerb from './parse/index.js'\nimport toInf from './conjugate/toInfinitive.js'\nimport toPast from './conjugate/toPast.js'\nimport toParticiple from './conjugate/toParticiple.js'\nimport toPresent from './conjugate/toPresent.js'\nimport toFuture from './conjugate/toFuture.js'\nimport toGerund from './conjugate/toGerund.js'\nimport getSubject from './parse/getSubject.js'\nimport getGrammar from './parse/grammar/index.js'\nimport toNegative from './conjugate/toNegative.js'\nimport { getTense } from './lib.js'\n\n\nconst api = function (View) {\n  class Verbs extends View {\n    constructor(document, pointer, groups) {\n      super(document, pointer, groups)\n      this.viewType = 'Verbs'\n    }\n    parse(n) {\n      return this.getNth(n).map(parseVerb)\n    }\n    json(opts, n) {\n      let m = this.getNth(n)\n      let arr = m.map(vb => {\n        let json = vb.toView().json(opts)[0] || {}\n        json.verb = toJSON(vb)\n        return json\n      }, [])\n      return arr\n    }\n    subjects(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        return getSubject(vb, parsed).subject\n      })\n    }\n    adverbs(n) {\n      return this.getNth(n).map(vb => vb.match('#Adverb'))\n    }\n    isSingular(n) {\n      return this.getNth(n).filter(vb => {\n        return getSubject(vb).plural !== true\n      })\n    }\n    isPlural(n) {\n      return this.getNth(n).filter(vb => {\n        return getSubject(vb).plural === true\n      })\n    }\n    isImperative(n) {\n      return this.getNth(n).filter(vb => vb.has('#Imperative'))\n    }\n    toInfinitive(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        return toInf(vb, parsed, info.form)\n      })\n    }\n    toPresentTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        if (info.isInfinitive) {\n          return vb\n        }\n        return toPresent(vb, parsed, info.form)\n      })\n    }\n    toPastTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        if (info.isInfinitive) {\n          return vb\n        }\n        return toPast(vb, parsed, info.form)\n      })\n    }\n    toFutureTense(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        if (info.isInfinitive) {\n          return vb\n        }\n        return toFuture(vb, parsed, info.form)\n      })\n    }\n    toGerund(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        if (info.isInfinitive) {\n          return vb\n        }\n        return toGerund(vb, parsed, info.form)\n      })\n    }\n    toPastParticiple(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        if (info.isInfinitive) {\n          return vb\n        }\n        return toParticiple(vb, parsed, info.form)\n      })\n    }\n    conjugate(n) {\n      const { conjugate, toInfinitive } = this.world.methods.two.transform.verb\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        // allow imperatives like 'go!' to be conjugated here (only)\n        if (info.form === 'imperative') {\n          info.form = 'simple-present'\n        }\n        let inf = parsed.root.text('normal')\n        if (!parsed.root.has('#Infinitive')) {\n          let tense = getTense(parsed.root)\n          inf = toInfinitive(inf, vb.model, tense) || inf\n        }\n        return conjugate(inf, vb.model)\n      }, [])\n    }\n\n    /** return only verbs with 'not'*/\n    isNegative() {\n      return this.if('#Negative')\n    }\n    /**  return only verbs without 'not'*/\n    isPositive() {\n      return this.ifNo('#Negative')\n    }\n    /** remove 'not' from these verbs */\n    toPositive() {\n      let m = this.match('do not #Verb')\n      if (m.found) {\n        m.remove('do not')\n      }\n      return this.remove('#Negative')\n    }\n    toNegative(n) {\n      return this.getNth(n).map(vb => {\n        let parsed = parseVerb(vb)\n        let info = getGrammar(vb, parsed)\n        return toNegative(vb, parsed, info.form)\n      })\n    }\n    // overloaded - keep Verb class\n    update(pointer) {\n      let m = new Verbs(this.document, pointer)\n      m._cache = this._cache // share this full thing\n      return m\n    }\n  }\n  Verbs.prototype.toPast = Verbs.prototype.toPastTense\n  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense\n  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense\n\n  View.prototype.verbs = function (n) {\n    let vb = find(this)\n    vb = vb.getNth(n)\n    return new Verbs(this.document, vb.pointer)\n  }\n}\nexport default api\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}