{"ast":null,"code":"// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Plane = require('./plane');\nvar Sylvester = require('./sylvester');\n\n// Line class - depends on Vector, and some methods require Matrix and Plane.\n\nfunction Line() {}\nLine.prototype = {\n  // Returns true if the argument occupies the same space as the line\n  eql: function (line) {\n    return this.isParallelTo(line) && this.contains(line.anchor);\n  },\n  // Returns a copy of the line\n  dup: function () {\n    return Line.create(this.anchor, this.direction);\n  },\n  // Returns the result of translating the line by the given vector/array\n  translate: function (vector) {\n    var V = vector.elements || vector;\n    return Line.create([this.anchor.elements[0] + V[0], this.anchor.elements[1] + V[1], this.anchor.elements[2] + (V[2] || 0)], this.direction);\n  },\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.isParallelTo(this);\n    }\n    var theta = this.direction.angleFrom(obj.direction);\n    return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;\n  },\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.distanceFrom(this);\n    }\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) {\n        return this.distanceFrom(obj.anchor);\n      }\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements,\n        B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements,\n        D = this.direction.elements;\n      var PA1 = P[0] - A[0],\n        PA2 = P[1] - A[1],\n        PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1 * PA1 + PA2 * PA2 + PA3 * PA3);\n      if (modPA === 0) return 0;\n      // Assumes direction vector is normalized\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta * cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function (obj) {\n    if (obj.start && obj.end) {\n      return this.contains(obj.start) && this.contains(obj.end);\n    }\n    var dist = this.distanceFrom(obj);\n    return dist !== null && dist <= Sylvester.precision;\n  },\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function (point) {\n    if (!this.contains(point)) {\n      return null;\n    }\n    var P = point.elements || point;\n    var A = this.anchor.elements,\n      D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n  // Returns true iff the line lies in the given plane\n  liesIn: function (plane) {\n    return plane.contains(this);\n  },\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function (obj) {\n    if (obj.normal) {\n      return obj.intersects(this);\n    }\n    return !this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision;\n  },\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.intersectionWith(this);\n    }\n    if (!this.intersects(obj)) {\n      return null;\n    }\n    var P = this.anchor.elements,\n      X = this.direction.elements,\n      Q = obj.anchor.elements,\n      Y = obj.direction.elements;\n    var X1 = X[0],\n      X2 = X[1],\n      X3 = X[2],\n      Y1 = Y[0],\n      Y2 = Y[1],\n      Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0],\n      PsubQ2 = P[1] - Q[1],\n      PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = -X1 * PsubQ1 - X2 * PsubQ2 - X3 * PsubQ3;\n    var YdotPsubQ = Y1 * PsubQ1 + Y2 * PsubQ2 + Y3 * PsubQ3;\n    var XdotX = X1 * X1 + X2 * X2 + X3 * X3;\n    var YdotY = Y1 * Y1 + Y2 * Y2 + Y3 * Y3;\n    var XdotY = X1 * Y1 + X2 * Y2 + X3 * Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k * X1, P[1] + k * X2, P[2] + k * X3]);\n  },\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function (obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return P === null ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) {\n        return this.intersectionWith(obj);\n      }\n      if (this.isParallelTo(obj)) {\n        return null;\n      }\n      var D = this.direction.elements,\n        E = obj.direction.elements;\n      var D1 = D[0],\n        D2 = D[1],\n        D3 = D[2],\n        E1 = E[0],\n        E2 = E[1],\n        E3 = E[2];\n      // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n      var x = D3 * E1 - D1 * E3,\n        y = D1 * E2 - D2 * E1,\n        z = D2 * E3 - D3 * E2;\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      if (this.contains(P)) {\n        return Vector.create(P);\n      }\n      var A = this.anchor.elements,\n        D = this.direction.elements;\n      var D1 = D[0],\n        D2 = D[1],\n        D3 = D[2],\n        A1 = A[0],\n        A2 = A[1],\n        A3 = A[2];\n      var x = D1 * (P[1] - A2) - D2 * (P[0] - A1),\n        y = D2 * ((P[2] || 0) - A3) - D3 * (P[1] - A2),\n        z = D3 * (P[0] - A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([P[0] + V.elements[0] * k, P[1] + V.elements[1] * k, (P[2] || 0) + V.elements[2] * k]);\n    }\n  },\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function (t, line) {\n    // If we're working in 2D\n    if (typeof line.direction == 'undefined') {\n      line = Line.create(line.to3D(), Vector.k);\n    }\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements,\n      D = this.direction.elements;\n    var C1 = C[0],\n      C2 = C[1],\n      C3 = C[2],\n      A1 = A[0],\n      A2 = A[1],\n      A3 = A[2];\n    var x = A1 - C1,\n      y = A2 - C2,\n      z = A3 - C3;\n    return Line.create([C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z, C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z, C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z], [R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2], R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2], R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]]);\n  },\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function () {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function (obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements,\n        D = this.direction.elements;\n      var A1 = A[0],\n        A2 = A[1],\n        A3 = A[2],\n        D1 = D[0],\n        D2 = D[1],\n        D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the line's direction vector to its anchor, then mirror that in the plane\n      var AD1 = A1 + D1,\n        AD2 = A2 + D2,\n        AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], P[2] || 0]), this.direction);\n    }\n  },\n  // Set the line's anchor point and direction.\n  setVectors: function (anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n    if (anchor.elements.length == 2) {\n      anchor.elements.push(0);\n    }\n    if (direction.elements.length == 2) {\n      direction.elements.push(0);\n    }\n    if (anchor.elements.length > 3 || direction.elements.length > 3) {\n      return null;\n    }\n    var mod = direction.modulus();\n    if (mod === 0) {\n      return null;\n    }\n    this.anchor = anchor;\n    this.direction = Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);\n    return this;\n  }\n};\n\n// Constructor function\nLine.create = function (anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n};\n\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\nmodule.exports = Line;","map":{"version":3,"names":["Vector","require","Matrix","Plane","Sylvester","Line","prototype","eql","line","isParallelTo","contains","anchor","dup","create","direction","translate","vector","V","elements","obj","normal","start","end","theta","angleFrom","Math","abs","precision","PI","distanceFrom","N","cross","toUnitVector","A","B","P","D","PA1","PA2","PA3","modPA","sqrt","cosTheta","sin2","dist","positionOf","point","liesIn","plane","intersects","intersectionWith","X","Q","Y","X1","X2","X3","Y1","Y2","Y3","PsubQ1","PsubQ2","PsubQ3","XdotQsubP","YdotPsubQ","XdotX","YdotY","XdotY","k","pointClosestTo","E","D1","D2","D3","E1","E2","E3","x","y","z","A1","A2","A3","modulus","rotate","t","to3D","R","Rotation","C","C1","C2","C3","reverse","reflectionIn","newA","AD1","AD2","AD3","newD","setVectors","length","push","mod","L","Zero","i","j","Z","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/sylvester/lib/node-sylvester/line.js"],"sourcesContent":["// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Plane = require('./plane');\nvar Sylvester = require('./sylvester');\n\n// Line class - depends on Vector, and some methods require Matrix and Plane.\n\nfunction Line() {}\nLine.prototype = {\n\n  // Returns true if the argument occupies the same space as the line\n  eql: function(line) {\n    return (this.isParallelTo(line) && this.contains(line.anchor));\n  },\n\n  // Returns a copy of the line\n  dup: function() {\n    return Line.create(this.anchor, this.direction);\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Line.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.direction);\n  },\n\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }\n    var theta = this.direction.angleFrom(obj.direction);\n    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);\n  },\n\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements, B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, D = this.direction.elements;\n      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);\n      if (modPA === 0) return 0;\n      // Assumes direction vector is normalized\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta*cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var dist = this.distanceFrom(obj);\n    return (dist !== null && dist <= Sylvester.precision);\n  },\n\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function(point) {\n    if (!this.contains(point)) { return null; }\n    var P = point.elements || point;\n    var A = this.anchor.elements, D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n\n  // Returns true iff the line lies in the given plane\n  liesIn: function(plane) {\n    return plane.contains(this);\n  },\n\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function(obj) {\n    if (obj.normal) { return obj.intersects(this); }\n    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);\n  },\n\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }\n    if (!this.intersects(obj)) { return null; }\n    var P = this.anchor.elements, X = this.direction.elements,\n        Q = obj.anchor.elements, Y = obj.direction.elements;\n    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;\n    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;\n    var XdotX = X1*X1 + X2*X2 + X3*X3;\n    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;\n    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);\n  },\n\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function(obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return (P === null) ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) { return this.intersectionWith(obj); }\n      if (this.isParallelTo(obj)) { return null; }\n      var D = this.direction.elements, E = obj.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];\n      // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      if (this.contains(P)) { return Vector.create(P); }\n      var A = this.anchor.elements, D = this.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];\n      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),\n          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([\n        P[0] + V.elements[0] * k,\n        P[1] + V.elements[1] * k,\n        (P[2] || 0) + V.elements[2] * k\n      ]);\n    }\n  },\n\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function(t, line) {\n    // If we're working in 2D\n    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, D = this.direction.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Line.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],\n      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],\n      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]\n    ]);\n  },\n\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function() {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, D = this.direction.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the line's direction vector to its anchor, then mirror that in the plane\n      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);\n    }\n  },\n\n  // Set the line's anchor point and direction.\n  setVectors: function(anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n    if (anchor.elements.length == 2) {anchor.elements.push(0); }\n    if (direction.elements.length == 2) { direction.elements.push(0); }\n    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }\n    var mod = direction.modulus();\n    if (mod === 0) { return null; }\n    this.anchor = anchor;\n    this.direction = Vector.create([\n      direction.elements[0] / mod,\n      direction.elements[1] / mod,\n      direction.elements[2] / mod\n    ]);\n    return this;\n  }\n};\n\n// Constructor function\nLine.create = function(anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n};\n\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\n\nmodule.exports = Line;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}