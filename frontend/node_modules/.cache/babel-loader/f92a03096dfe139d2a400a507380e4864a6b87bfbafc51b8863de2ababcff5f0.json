{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst NOOP = function () {};\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client;\n    this.idleListener = idleListener;\n    this.timeoutId = timeoutId;\n  }\n}\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback;\n  }\n}\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n  let rej;\n  let res;\n  const cb = function (err, client) {\n    err ? rej(err) : res(client);\n  };\n  const result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  }).catch(err => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err);\n    throw err;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n    pool._remove(client);\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client);\n  };\n}\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super();\n    this.options = Object.assign({}, options);\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      });\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false\n      });\n    }\n    this.options.max = this.options.max || this.options.poolSize || 10;\n    this.options.min = this.options.min || 0;\n    this.options.maxUses = this.options.maxUses || Infinity;\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;\n    this.log = this.options.log || function () {};\n    this.Client = this.options.Client || Client || require('pg').Client;\n    this.Promise = this.options.Promise || global.Promise;\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000;\n    }\n    this._clients = [];\n    this._idle = [];\n    this._expired = new WeakSet();\n    this._pendingQueue = [];\n    this._endCallback = undefined;\n    this.ending = false;\n    this.ended = false;\n  }\n  _isFull() {\n    return this._clients.length >= this.options.max;\n  }\n  _isAboveMin() {\n    return this._clients.length > this.options.min;\n  }\n  _pulseQueue() {\n    this.log('pulse queue');\n    if (this.ended) {\n      this.log('pulse queue ended');\n      return;\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending');\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client);\n        });\n      }\n      if (!this._clients.length) {\n        this.ended = true;\n        this._endCallback();\n      }\n      return;\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests');\n      return;\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return;\n    }\n    const pendingItem = this._pendingQueue.shift();\n    if (this._idle.length) {\n      const idleItem = this._idle.pop();\n      clearTimeout(idleItem.timeoutId);\n      const client = idleItem.client;\n      client.ref && client.ref();\n      const idleListener = idleItem.idleListener;\n      return this._acquireClient(client, pendingItem, idleListener, false);\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem);\n    }\n    throw new Error('unexpected condition');\n  }\n  _remove(client, callback) {\n    const removed = removeWhere(this._idle, item => item.client === client);\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId);\n    }\n    this._clients = this._clients.filter(c => c !== client);\n    const context = this;\n    client.end(() => {\n      context.emit('remove', client);\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n    const response = promisify(this.Promise, cb);\n    const result = response.result;\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue());\n      }\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback));\n        return result;\n      }\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid);\n        response.callback(err, res, done);\n      };\n      const pendingItem = new PendingItem(queueCallback);\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, i => i.callback === queueCallback);\n        pendingItem.timedOut = true;\n        response.callback(new Error('timeout exceeded when trying to connect'));\n      }, this.options.connectionTimeoutMillis);\n      if (tid.unref) {\n        tid.unref();\n      }\n      this._pendingQueue.push(pendingItem);\n      return result;\n    }\n    this.newClient(new PendingItem(response.callback));\n    return result;\n  }\n  newClient(pendingItem) {\n    const client = new this.Client(this.options);\n    this._clients.push(client);\n    const idleListener = makeIdleListener(this, client);\n    this.log('checking client timeout');\n\n    // connection timeout logic\n    let tid;\n    let timeoutHit = false;\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout');\n        timeoutHit = true;\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end();\n      }, this.options.connectionTimeoutMillis);\n    }\n    this.log('connecting new client');\n    client.connect(err => {\n      if (tid) {\n        clearTimeout(tid);\n      }\n      client.on('error', idleListener);\n      if (err) {\n        this.log('client failed to connect', err);\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter(c => c !== client);\n        if (timeoutHit) {\n          err = new Error('Connection terminated due to connection timeout', {\n            cause: err\n          });\n        }\n\n        // this client won’t be released, so move on immediately\n        this._pulseQueue();\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP);\n        }\n      } else {\n        this.log('new client connected');\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime');\n            this._expired.add(client);\n            const idleIndex = this._idle.findIndex(idleItem => idleItem.client === client);\n            if (idleIndex !== -1) {\n              this._acquireClient(client, new PendingItem((err, client, clientRelease) => clientRelease()), idleListener, false);\n            }\n          }, this.options.maxLifetimeSeconds * 1000);\n          maxLifetimeTimeout.unref();\n          client.once('end', () => clearTimeout(maxLifetimeTimeout));\n        }\n        return this._acquireClient(client, pendingItem, idleListener, true);\n      }\n    });\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client);\n    }\n    this.emit('acquire', client);\n    client.release = this._releaseOnce(client, idleListener);\n    client.removeListener('error', idleListener);\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, err => {\n          if (err) {\n            client.release(err);\n            return pendingItem.callback(err, undefined, NOOP);\n          }\n          pendingItem.callback(undefined, client, client.release);\n        });\n      } else {\n        pendingItem.callback(undefined, client, client.release);\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release);\n      } else {\n        client.release();\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false;\n    return err => {\n      if (released) {\n        throwOnDoubleRelease();\n      }\n      released = true;\n      this._release(client, idleListener, err);\n    };\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener);\n    client._poolUseCount = (client._poolUseCount || 0) + 1;\n    this.emit('release', err, client);\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client');\n      }\n      return this._remove(client, this._pulseQueue.bind(this));\n    }\n    const isExpired = this._expired.has(client);\n    if (isExpired) {\n      this.log('remove expired client');\n      this._expired.delete(client);\n      return this._remove(client, this._pulseQueue.bind(this));\n    }\n\n    // idle timeout\n    let tid;\n    if (this.options.idleTimeoutMillis && this._isAboveMin()) {\n      tid = setTimeout(() => {\n        this.log('remove idle client');\n        this._remove(client, this._pulseQueue.bind(this));\n      }, this.options.idleTimeoutMillis);\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref();\n      }\n    }\n    if (this.options.allowExitOnIdle) {\n      client.unref();\n    }\n    this._idle.push(new IdleItem(client, idleListener, tid));\n    this._pulseQueue();\n  }\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text);\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n      });\n      return response.result;\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values;\n      values = undefined;\n    }\n    const response = promisify(this.Promise, cb);\n    cb = response.callback;\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err);\n      }\n      let clientReleased = false;\n      const onError = err => {\n        if (clientReleased) {\n          return;\n        }\n        clientReleased = true;\n        client.release(err);\n        cb(err);\n      };\n      client.once('error', onError);\n      this.log('dispatching query');\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched');\n          client.removeListener('error', onError);\n          if (clientReleased) {\n            return;\n          }\n          clientReleased = true;\n          client.release(err);\n          if (err) {\n            return cb(err);\n          }\n          return cb(undefined, res);\n        });\n      } catch (err) {\n        client.release(err);\n        return cb(err);\n      }\n    });\n    return response.result;\n  }\n  end(cb) {\n    this.log('ending');\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n    this.ending = true;\n    const promised = promisify(this.Promise, cb);\n    this._endCallback = promised.callback;\n    this._pulseQueue();\n    return promised.result;\n  }\n  get waitingCount() {\n    return this._pendingQueue.length;\n  }\n  get idleCount() {\n    return this._idle.length;\n  }\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);\n  }\n  get totalCount() {\n    return this._clients.length;\n  }\n}\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","NOOP","removeWhere","list","predicate","i","findIndex","undefined","splice","IdleItem","constructor","client","idleListener","timeoutId","PendingItem","callback","throwOnDoubleRelease","Error","promisify","Promise","result","rej","res","cb","err","resolve","reject","catch","captureStackTrace","makeIdleListener","pool","removeListener","on","log","_remove","emit","Pool","options","Client","Object","assign","defineProperty","configurable","enumerable","writable","value","password","ssl","key","max","poolSize","min","maxUses","Infinity","allowExitOnIdle","maxLifetimeSeconds","global","idleTimeoutMillis","_clients","_idle","_expired","WeakSet","_pendingQueue","_endCallback","ending","ended","_isFull","length","_isAboveMin","_pulseQueue","slice","map","item","pendingItem","shift","idleItem","pop","clearTimeout","ref","_acquireClient","newClient","removed","filter","c","context","end","connect","response","process","nextTick","connectionTimeoutMillis","push","queueCallback","done","tid","setTimeout","timedOut","unref","timeoutHit","connection","stream","destroy","cause","maxLifetimeTimeout","add","idleIndex","clientRelease","once","isNew","release","_releaseOnce","verify","released","_release","_poolUseCount","_queryable","_ending","bind","isExpired","has","delete","query","text","values","setImmediate","clientReleased","onError","promised","waitingCount","idleCount","expiredCount","reduce","acc","totalCount","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/pg-pool/index.js"],"sourcesContent":["'use strict'\nconst EventEmitter = require('events').EventEmitter\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch((err) => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err)\n    throw err\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.min = this.options.min || 0\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || require('pg').Client\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _isAboveMin() {\n    return this._clients.length > this.options.min\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client, callback) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    const context = this\n    client.end(() => {\n      context.emit('remove', client)\n\n      if (typeof callback === 'function') {\n        callback()\n      }\n    })\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      if (tid.unref) {\n        tid.unref()\n      }\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err = new Error('Connection terminated due to connection timeout', { cause: err })\n        }\n\n        // this client won’t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis && this._isAboveMin()) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client, this._pulseQueue.bind(this))\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}