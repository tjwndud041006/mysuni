{"ast":null,"code":"import world from './world.js';\nimport api from './methods/index.js';\nclass View {\n  constructor(document, pointer, groups = {}) {\n    // invisible props\n    let props = [['document', document], ['world', world], ['_groups', groups], ['_cache', null], ['viewType', 'View']];\n    props.forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true\n      });\n    });\n    this.ptrs = pointer;\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document;\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document);\n    }\n    return docs;\n  }\n  get pointer() {\n    return this.ptrs;\n  }\n  get methods() {\n    return this.world.methods;\n  }\n  get model() {\n    return this.world.model;\n  }\n  get hooks() {\n    return this.world.hooks;\n  }\n  get isView() {\n    return true; //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0;\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length;\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let {\n      docs,\n      ptrs,\n      document\n    } = this;\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n]);\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a;\n      start = start || 0;\n      end = end || (document[n] || []).length;\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id;\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id;\n        }\n      }\n      return [n, start, end, id, endId];\n    });\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer);\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = [];\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr;\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n];\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n];\n        }\n      });\n      if (cache.length > 0) {\n        m._cache = cache;\n      }\n    }\n    m.world = this.world;\n    return m;\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer);\n  }\n  fromText(input) {\n    const {\n      methods\n    } = this;\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world);\n    let doc = new View(document);\n    doc.world = this.world;\n    doc.compute(['normal', 'freeze', 'lexicon']);\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger');\n    }\n    doc.compute('unfreeze');\n    return doc;\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0); //node 17: structuredClone(document);\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term);\n        term.tags = new Set(term.tags);\n        return term;\n      });\n    });\n    // clone only sub-document ?\n    let m = this.update(this.pointer);\n    m.document = document;\n    m._cache = this._cache; //clone this too?\n    return m;\n  }\n}\nObject.assign(View.prototype, api);\nexport default View;","map":{"version":3,"names":["world","api","View","constructor","document","pointer","groups","props","forEach","a","Object","defineProperty","value","writable","ptrs","docs","methods","one","getDoc","model","hooks","isView","found","length","fullPointer","pointers","map","_d","n","start","end","id","endId","update","m","_cache","cache","ptr","i","toView","fromText","input","tokenize","fromString","doc","compute","preTagger","clone","slice","terms","term","assign","tags","Set","prototype"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/API/View.js"],"sourcesContent":["import world from './world.js'\nimport api from './methods/index.js'\n\nclass View {\n  constructor(document, pointer, groups = {}) {\n    // invisible props\n    let props = [\n      ['document', document],\n      ['world', world],\n      ['_groups', groups],\n      ['_cache', null],\n      ['viewType', 'View'],\n    ]\n    props.forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true,\n      })\n    })\n    this.ptrs = pointer\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document)\n    }\n    return docs\n  }\n  get pointer() {\n    return this.ptrs\n  }\n  get methods() {\n    return this.world.methods\n  }\n  get model() {\n    return this.world.model\n  }\n  get hooks() {\n    return this.world.hooks\n  }\n  get isView() {\n    return true //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let { docs, ptrs, document } = this\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n])\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a\n      start = start || 0\n      end = end || (document[n] || []).length\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id\n        }\n      }\n      return [n, start, end, id, endId]\n    })\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer)\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = []\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n]\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n]\n        }\n      })\n      if (cache.length > 0) {\n        m._cache = cache\n      }\n    }\n    m.world = this.world\n    return m\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer)\n  }\n  fromText(input) {\n    const { methods } = this\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world)\n    let doc = new View(document)\n    doc.world = this.world\n    doc.compute(['normal', 'freeze', 'lexicon'])\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger')\n    }\n    doc.compute('unfreeze')\n    return doc\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0) //node 17: structuredClone(document);\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term)\n        term.tags = new Set(term.tags)\n        return term\n      })\n    })\n    // clone only sub-document ?\n    let m = this.update(this.pointer)\n    m.document = document\n    m._cache = this._cache //clone this too?\n    return m\n  }\n}\nObject.assign(View.prototype, api)\nexport default View\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}