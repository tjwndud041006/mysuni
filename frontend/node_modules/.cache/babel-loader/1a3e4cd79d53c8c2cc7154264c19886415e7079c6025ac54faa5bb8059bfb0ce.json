{"ast":null,"code":"const byComma = function (doc) {\n  let commas = doc.match('@hasComma');\n  // remove any non-clause uses\n  commas = commas.filter(m => {\n    // don't split the first word\n    if (m.growLeft('.').wordCount() === 1) {\n      return false;\n    }\n    // don't split the last word\n    if (m.growRight('. .').wordCount() === 1) {\n      return false;\n    }\n    let more = m.grow('.'); // grow by 1 word in either direction\n    more = more.ifNo('@hasComma @hasComma'); //fun, cool...\n    more = more.ifNo('@hasComma (and|or) .'); //cool, and fun\n    more = more.ifNo('(#City && @hasComma) #Country'); //'toronto, canada'\n    more = more.ifNo('(#WeekDay && @hasComma) #Date'); //'tuesday, march 2nd'\n    more = more.ifNo('(#Date+ && @hasComma) #Value'); //'july 6, 1992'\n    more = more.ifNo('(#Adjective && @hasComma) #Adjective'); //nice, pretty\n    // more = more.ifNo('@hasComma (too|also)$') //at end of sentence\n    return more.found;\n  });\n  return doc.splitAfter(commas);\n};\n\n// should we split-out a clause (in brackets)?\nconst splitParentheses = function (doc) {\n  let matches = doc.parentheses();\n  matches = matches.filter(m => {\n    return m.wordCount() >= 3 && m.has('#Verb') && m.has('#Noun');\n  });\n  return doc.splitOn(matches);\n};\n\n// split-out a long quotion, but not 'inline quotes'.\nconst splitQuotes = function (doc) {\n  let matches = doc.quotations();\n  matches = matches.filter(m => {\n    return m.wordCount() >= 3 && m.has('#Verb') && m.has('#Noun');\n  });\n  return doc.splitOn(matches);\n};\nconst clauses = function (n) {\n  let found = this;\n  found = splitParentheses(found);\n  found = splitQuotes(found);\n  found = byComma(found);\n  found = found.splitAfter('(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)');\n\n  // i said\n  found = found.splitAfter('^#Pronoun (said|says)');\n  // ... said John.\n  found = found.splitBefore('(said|says) #ProperNoun$');\n\n  // ... if it was\n  found = found.splitBefore('. . if .{4}');\n\n  // various conjunctions\n  found = found.splitBefore('and while');\n  found = found.splitBefore('now that');\n  found = found.splitBefore('ever since');\n  found = found.splitBefore('(supposing|although)');\n  found = found.splitBefore('even (while|if|though)');\n  found = found.splitBefore('(whereas|whose)');\n  // found = found.splitBefore('as (far|long|much|soon) as')\n  found = found.splitBefore('as (though|if)');\n  found = found.splitBefore('(til|until)');\n\n  // it is cool but it is ..\n  let m = found.match('#Verb .* [but] .* #Verb', 0);\n  if (m.found) {\n    found = found.splitBefore(m);\n  }\n  // it is cool and it is ..\n  // let conjunctions = found.if('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction')\n  // found = found.splitBefore(conjunctions)\n\n  // if it is this then that\n  let condition = found.if('if .{2,9} then .').match('then');\n  found = found.splitBefore(condition);\n\n  // // misc clause partitions\n  // found = found.splitBefore('as well as .')\n  // found = found.splitBefore('such as .')\n  // found = found.splitBefore('in addition to .')\n\n  // // semicolons, dashes\n  // found = found.splitAfter('@hasSemicolon')\n  // found = found.splitAfter('@hasDash')\n\n  // //\n  // found = found.splitBefore('which (were|are|will)')\n\n  // // he said [...]\n  // found = found.splitAfter('#Noun (said|say|says)')\n\n  // passive voice verb - '.. which was robbed is empty'\n  // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')\n  // if (passive.found) {\n  //   found = found.splitAfter(passive)\n  // }\n  // //which the boy robbed\n  // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')\n  // if (passive.found) {\n  //   found = found.splitAfter(passive)\n  // }\n  // does there appear to have relative/subordinate clause still?\n  // let tooLong = found.filter(d => d.wordCount() > 5 && d.match('#Verb+').length >= 2)\n  // if (tooLong.found) {\n  //   // and after the ..\n  //   found = found.splitBefore('#Conjunction #Preposition')\n\n  //   // let m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+')\n  //   // found = found.splitOn(m.eq(0))\n  // }\n  if (typeof n === 'number') {\n    found = found.get(n);\n  }\n  return found;\n};\nexport default clauses;","map":{"version":3,"names":["byComma","doc","commas","match","filter","m","growLeft","wordCount","growRight","more","grow","ifNo","found","splitAfter","splitParentheses","matches","parentheses","has","splitOn","splitQuotes","quotations","clauses","n","splitBefore","condition","if","get"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/chunker/api/clauses.js"],"sourcesContent":["const byComma = function (doc) {\n  let commas = doc.match('@hasComma')\n  // remove any non-clause uses\n  commas = commas.filter(m => {\n    // don't split the first word\n    if (m.growLeft('.').wordCount() === 1) {\n      return false\n    }\n    // don't split the last word\n    if (m.growRight('. .').wordCount() === 1) {\n      return false\n    }\n    let more = m.grow('.') // grow by 1 word in either direction\n    more = more.ifNo('@hasComma @hasComma') //fun, cool...\n    more = more.ifNo('@hasComma (and|or) .') //cool, and fun\n    more = more.ifNo('(#City && @hasComma) #Country') //'toronto, canada'\n    more = more.ifNo('(#WeekDay && @hasComma) #Date') //'tuesday, march 2nd'\n    more = more.ifNo('(#Date+ && @hasComma) #Value') //'july 6, 1992'\n    more = more.ifNo('(#Adjective && @hasComma) #Adjective') //nice, pretty\n    // more = more.ifNo('@hasComma (too|also)$') //at end of sentence\n    return more.found\n  })\n  return doc.splitAfter(commas)\n}\n\n// should we split-out a clause (in brackets)?\nconst splitParentheses = function (doc) {\n  let matches = doc.parentheses()\n  matches = matches.filter(m => {\n    return m.wordCount() >= 3 && m.has('#Verb') && m.has('#Noun')\n  })\n  return doc.splitOn(matches)\n}\n\n// split-out a long quotion, but not 'inline quotes'.\nconst splitQuotes = function (doc) {\n  let matches = doc.quotations()\n  matches = matches.filter(m => {\n    return m.wordCount() >= 3 && m.has('#Verb') && m.has('#Noun')\n  })\n  return doc.splitOn(matches)\n}\n\nconst clauses = function (n) {\n  let found = this\n\n  found = splitParentheses(found)\n  found = splitQuotes(found)\n\n  found = byComma(found)\n\n  found = found.splitAfter('(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)')\n\n  // i said\n  found = found.splitAfter('^#Pronoun (said|says)')\n  // ... said John.\n  found = found.splitBefore('(said|says) #ProperNoun$')\n\n  // ... if it was\n  found = found.splitBefore('. . if .{4}')\n\n  // various conjunctions\n  found = found.splitBefore('and while')\n  found = found.splitBefore('now that')\n  found = found.splitBefore('ever since')\n  found = found.splitBefore('(supposing|although)')\n  found = found.splitBefore('even (while|if|though)')\n  found = found.splitBefore('(whereas|whose)')\n  // found = found.splitBefore('as (far|long|much|soon) as')\n  found = found.splitBefore('as (though|if)')\n  found = found.splitBefore('(til|until)')\n\n  // it is cool but it is ..\n  let m = found.match('#Verb .* [but] .* #Verb', 0)\n  if (m.found) {\n    found = found.splitBefore(m)\n  }\n  // it is cool and it is ..\n  // let conjunctions = found.if('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction')\n  // found = found.splitBefore(conjunctions)\n\n  // if it is this then that\n  let condition = found.if('if .{2,9} then .').match('then')\n  found = found.splitBefore(condition)\n\n  // // misc clause partitions\n  // found = found.splitBefore('as well as .')\n  // found = found.splitBefore('such as .')\n  // found = found.splitBefore('in addition to .')\n\n  // // semicolons, dashes\n  // found = found.splitAfter('@hasSemicolon')\n  // found = found.splitAfter('@hasDash')\n\n  // //\n  // found = found.splitBefore('which (were|are|will)')\n\n  // // he said [...]\n  // found = found.splitAfter('#Noun (said|say|says)')\n\n  // passive voice verb - '.. which was robbed is empty'\n  // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')\n  // if (passive.found) {\n  //   found = found.splitAfter(passive)\n  // }\n  // //which the boy robbed\n  // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')\n  // if (passive.found) {\n  //   found = found.splitAfter(passive)\n  // }\n  // does there appear to have relative/subordinate clause still?\n  // let tooLong = found.filter(d => d.wordCount() > 5 && d.match('#Verb+').length >= 2)\n  // if (tooLong.found) {\n  //   // and after the ..\n  //   found = found.splitBefore('#Conjunction #Preposition')\n\n  //   // let m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+')\n  //   // found = found.splitOn(m.eq(0))\n  // }\n  if (typeof n === 'number') {\n    found = found.get(n)\n  }\n  return found\n}\n\nexport default clauses\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}