{"ast":null,"code":"import { cleanAppend, cleanPrepend } from './lib/insert.js';\nimport uuid from '../compute/uuid.js';\n// are we inserting inside a contraction?\n// expand it first\nconst expand = function (m) {\n  if (m.has('@hasContraction') && typeof m.contractions === 'function') {\n    //&& m.after('^.').has('@hasContraction')\n    let more = m.grow('@hasContraction');\n    more.contractions().expand();\n  }\n};\nconst isArray = arr => Object.prototype.toString.call(arr) === '[object Array]';\n\n// set new ids for each terms\nconst addIds = function (terms) {\n  terms = terms.map(term => {\n    term.id = uuid(term);\n    return term;\n  });\n  return terms;\n};\nconst getTerms = function (input, world) {\n  const {\n    methods\n  } = world;\n  // create our terms from a string\n  if (typeof input === 'string') {\n    return methods.one.tokenize.fromString(input, world)[0]; //assume one sentence\n  }\n  //allow a view object\n  if (typeof input === 'object' && input.isView) {\n    return input.clone().docs[0] || []; //assume one sentence\n  }\n  //allow an array of terms, too\n  if (isArray(input)) {\n    return isArray(input[0]) ? input[0] : input;\n  }\n  return [];\n};\nconst insert = function (input, view, prepend) {\n  const {\n    document,\n    world\n  } = view;\n  view.uncache();\n  // insert words at end of each doc\n  let ptrs = view.fullPointer;\n  let selfPtrs = view.fullPointer;\n  view.forEach((m, i) => {\n    let ptr = m.fullPointer[0];\n    let [n] = ptr;\n    // add-in the words\n    let home = document[n];\n    let terms = getTerms(input, world);\n    // are we inserting nothing?\n    if (terms.length === 0) {\n      return;\n    }\n    terms = addIds(terms);\n    if (prepend) {\n      expand(view.update([ptr]).firstTerm());\n      cleanPrepend(home, ptr, terms, document);\n    } else {\n      expand(view.update([ptr]).lastTerm());\n      cleanAppend(home, ptr, terms, document);\n    }\n    // harden the pointer\n    if (document[n] && document[n][ptr[1]]) {\n      ptr[3] = document[n][ptr[1]].id;\n    }\n    // change self backwards by len\n    selfPtrs[i] = ptr;\n    // extend the pointer\n    ptr[2] += terms.length;\n    ptrs[i] = ptr;\n  });\n  let doc = view.toView(ptrs);\n  // shift our self pointer, if necessary\n  view.ptrs = selfPtrs;\n  // try to tag them, too\n  doc.compute(['id', 'index', 'freeze', 'lexicon']);\n  if (doc.world.compute.preTagger) {\n    doc.compute('preTagger');\n  }\n  doc.compute('unfreeze');\n  return doc;\n};\nconst fns = {\n  insertAfter: function (input) {\n    return insert(input, this, false);\n  },\n  insertBefore: function (input) {\n    return insert(input, this, true);\n  }\n};\nfns.append = fns.insertAfter;\nfns.prepend = fns.insertBefore;\nfns.insert = fns.insertAfter;\nexport default fns;","map":{"version":3,"names":["cleanAppend","cleanPrepend","uuid","expand","m","has","contractions","more","grow","isArray","arr","Object","prototype","toString","call","addIds","terms","map","term","id","getTerms","input","world","methods","one","tokenize","fromString","isView","clone","docs","insert","view","prepend","document","uncache","ptrs","fullPointer","selfPtrs","forEach","i","ptr","n","home","length","update","firstTerm","lastTerm","doc","toView","compute","preTagger","fns","insertAfter","insertBefore","append"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/change/api/insert.js"],"sourcesContent":["import { cleanAppend, cleanPrepend } from './lib/insert.js'\nimport uuid from '../compute/uuid.js'\n// are we inserting inside a contraction?\n// expand it first\nconst expand = function (m) {\n  if (m.has('@hasContraction') && typeof m.contractions === 'function') {\n    //&& m.after('^.').has('@hasContraction')\n    let more = m.grow('@hasContraction')\n    more.contractions().expand()\n  }\n}\n\nconst isArray = arr => Object.prototype.toString.call(arr) === '[object Array]'\n\n// set new ids for each terms\nconst addIds = function (terms) {\n  terms = terms.map(term => {\n    term.id = uuid(term)\n    return term\n  })\n  return terms\n}\n\nconst getTerms = function (input, world) {\n  const { methods } = world\n  // create our terms from a string\n  if (typeof input === 'string') {\n    return methods.one.tokenize.fromString(input, world)[0] //assume one sentence\n  }\n  //allow a view object\n  if (typeof input === 'object' && input.isView) {\n    return input.clone().docs[0] || [] //assume one sentence\n  }\n  //allow an array of terms, too\n  if (isArray(input)) {\n    return isArray(input[0]) ? input[0] : input\n  }\n  return []\n}\n\nconst insert = function (input, view, prepend) {\n  const { document, world } = view\n  view.uncache()\n  // insert words at end of each doc\n  let ptrs = view.fullPointer\n  let selfPtrs = view.fullPointer\n  view.forEach((m, i) => {\n    let ptr = m.fullPointer[0]\n    let [n] = ptr\n    // add-in the words\n    let home = document[n]\n    let terms = getTerms(input, world)\n    // are we inserting nothing?\n    if (terms.length === 0) {\n      return\n    }\n    terms = addIds(terms)\n    if (prepend) {\n      expand(view.update([ptr]).firstTerm())\n      cleanPrepend(home, ptr, terms, document)\n    } else {\n      expand(view.update([ptr]).lastTerm())\n      cleanAppend(home, ptr, terms, document)\n    }\n    // harden the pointer\n    if (document[n] && document[n][ptr[1]]) {\n      ptr[3] = document[n][ptr[1]].id\n    }\n    // change self backwards by len\n    selfPtrs[i] = ptr\n    // extend the pointer\n    ptr[2] += terms.length\n    ptrs[i] = ptr\n  })\n  let doc = view.toView(ptrs)\n  // shift our self pointer, if necessary\n  view.ptrs = selfPtrs\n  // try to tag them, too\n  doc.compute(['id', 'index', 'freeze', 'lexicon'])\n  if (doc.world.compute.preTagger) {\n    doc.compute('preTagger')\n  }\n  doc.compute('unfreeze')\n  return doc\n}\n\nconst fns = {\n  insertAfter: function (input) {\n    return insert(input, this, false)\n  },\n  insertBefore: function (input) {\n    return insert(input, this, true)\n  },\n}\nfns.append = fns.insertAfter\nfns.prepend = fns.insertBefore\nfns.insert = fns.insertAfter\n\nexport default fns\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}