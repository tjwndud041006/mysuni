{"ast":null,"code":"import methods from './lib/_sort.js';\n// aliases\nconst seqNames = new Set(['index', 'sequence', 'seq', 'sequential', 'chron', 'chronological']);\nconst freqNames = new Set(['freq', 'frequency', 'topk', 'repeats']);\nconst alphaNames = new Set(['alpha', 'alphabetical']);\n\n// support function as parameter\nconst customSort = function (view, fn) {\n  let ptrs = view.fullPointer;\n  ptrs = ptrs.sort((a, b) => {\n    a = view.update([a]);\n    b = view.update([b]);\n    return fn(a, b);\n  });\n  view.ptrs = ptrs; //mutate original\n  return view;\n};\n\n/** re-arrange the order of the matches (in place) */\nconst sort = function (input) {\n  let {\n    docs,\n    pointer\n  } = this;\n  this.uncache();\n  if (typeof input === 'function') {\n    return customSort(this, input);\n  }\n  input = input || 'alpha';\n  let ptrs = pointer || docs.map((_d, n) => [n]);\n  let arr = docs.map((terms, n) => {\n    return {\n      index: n,\n      words: terms.length,\n      normal: terms.map(t => t.machine || t.normal || '').join(' '),\n      pointer: ptrs[n]\n    };\n  });\n  // 'chronological' sorting\n  if (seqNames.has(input)) {\n    input = 'sequential';\n  }\n  // alphabetical sorting\n  if (alphaNames.has(input)) {\n    input = 'alpha';\n  }\n  // sort by frequency\n  if (freqNames.has(input)) {\n    arr = methods.byFreq(arr);\n    return this.update(arr.map(o => o.pointer));\n  }\n  // apply sort method on each phrase\n  if (typeof methods[input] === 'function') {\n    arr = arr.sort(methods[input]);\n    return this.update(arr.map(o => o.pointer));\n  }\n  return this;\n};\n\n/** reverse the order of the matches, but not the words or index */\nconst reverse = function () {\n  let ptrs = this.pointer || this.docs.map((_d, n) => [n]);\n  ptrs = [].concat(ptrs);\n  ptrs = ptrs.reverse();\n  if (this._cache) {\n    this._cache = this._cache.reverse();\n  }\n  return this.update(ptrs);\n};\n\n/** remove any duplicate matches */\nconst unique = function () {\n  let already = new Set();\n  let res = this.filter(m => {\n    let txt = m.text('machine');\n    if (already.has(txt)) {\n      return false;\n    }\n    already.add(txt);\n    return true;\n  });\n  // this.ptrs = res.ptrs //mutate original?\n  return res; //.compute('index')\n};\nexport default {\n  unique,\n  reverse,\n  sort\n};","map":{"version":3,"names":["methods","seqNames","Set","freqNames","alphaNames","customSort","view","fn","ptrs","fullPointer","sort","a","b","update","input","docs","pointer","uncache","map","_d","n","arr","terms","index","words","length","normal","t","machine","join","has","byFreq","o","reverse","concat","_cache","unique","already","res","filter","m","txt","text","add"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/change/api/sort.js"],"sourcesContent":["import methods from './lib/_sort.js'\n// aliases\nconst seqNames = new Set(['index', 'sequence', 'seq', 'sequential', 'chron', 'chronological'])\nconst freqNames = new Set(['freq', 'frequency', 'topk', 'repeats'])\nconst alphaNames = new Set(['alpha', 'alphabetical'])\n\n// support function as parameter\nconst customSort = function (view, fn) {\n  let ptrs = view.fullPointer\n  ptrs = ptrs.sort((a, b) => {\n    a = view.update([a])\n    b = view.update([b])\n    return fn(a, b)\n  })\n  view.ptrs = ptrs //mutate original\n  return view\n}\n\n/** re-arrange the order of the matches (in place) */\nconst sort = function (input) {\n  let { docs, pointer } = this\n  this.uncache()\n  if (typeof input === 'function') {\n    return customSort(this, input)\n  }\n  input = input || 'alpha'\n  let ptrs = pointer || docs.map((_d, n) => [n])\n  let arr = docs.map((terms, n) => {\n    return {\n      index: n,\n      words: terms.length,\n      normal: terms.map(t => t.machine || t.normal || '').join(' '),\n      pointer: ptrs[n],\n    }\n  })\n  // 'chronological' sorting\n  if (seqNames.has(input)) {\n    input = 'sequential'\n  }\n  // alphabetical sorting\n  if (alphaNames.has(input)) {\n    input = 'alpha'\n  }\n  // sort by frequency\n  if (freqNames.has(input)) {\n    arr = methods.byFreq(arr)\n    return this.update(arr.map(o => o.pointer))\n  }\n  // apply sort method on each phrase\n  if (typeof methods[input] === 'function') {\n    arr = arr.sort(methods[input])\n    return this.update(arr.map(o => o.pointer))\n  }\n  return this\n}\n\n/** reverse the order of the matches, but not the words or index */\nconst reverse = function () {\n  let ptrs = this.pointer || this.docs.map((_d, n) => [n])\n  ptrs = [].concat(ptrs)\n  ptrs = ptrs.reverse()\n  if (this._cache) {\n    this._cache = this._cache.reverse()\n  }\n  return this.update(ptrs)\n}\n\n/** remove any duplicate matches */\nconst unique = function () {\n  let already = new Set()\n  let res = this.filter(m => {\n    let txt = m.text('machine')\n    if (already.has(txt)) {\n      return false\n    }\n    already.add(txt)\n    return true\n  })\n  // this.ptrs = res.ptrs //mutate original?\n  return res//.compute('index')\n}\n\nexport default { unique, reverse, sort }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}