{"ast":null,"code":"const postPunct = /[,)\"';:\\-–—.…]/;\nconst setContraction = function (m, suffix) {\n  if (!m.found) {\n    return;\n  }\n  let terms = m.termList();\n  //avoid any problematic punctuation\n  for (let i = 0; i < terms.length - 1; i++) {\n    const t = terms[i];\n    if (postPunct.test(t.post)) {\n      return;\n    }\n  }\n  // set first word as full text\n  terms[0].implicit = terms[0].normal;\n  terms[0].text += suffix;\n  terms[0].normal += suffix;\n  // clean-up the others\n  terms.slice(1).forEach(t => {\n    t.implicit = t.normal;\n    t.text = '';\n    t.normal = '';\n  });\n  for (let i = 0; i < terms.length - 1; i++) {\n    terms[i].post = terms[i].post.replace(/ /, '');\n  }\n};\n\n/** turn 'i am' into i'm */\nconst contract = function () {\n  let doc = this.not('@hasContraction');\n  // we are -> we're\n  let m = doc.match('(we|they|you) are');\n  setContraction(m, `'re`);\n  // they will -> they'll\n  m = doc.match('(he|she|they|it|we|you) will');\n  setContraction(m, `'ll`);\n  // she is -> she's\n  m = doc.match('(he|she|they|it|we) is');\n  setContraction(m, `'s`);\n  // spencer is -> spencer's\n  m = doc.match('#Person is');\n  setContraction(m, `'s`);\n  // spencer would -> spencer'd\n  m = doc.match('#Person would');\n  setContraction(m, `'d`);\n  // would not -> wouldn't\n  m = doc.match('(is|was|had|would|should|could|do|does|have|has|can) not');\n  setContraction(m, `n't`);\n  // i have -> i've\n  m = doc.match('(i|we|they) have');\n  setContraction(m, `'ve`);\n  // would have -> would've\n  m = doc.match('(would|should|could) have');\n  setContraction(m, `'ve`);\n  // i am -> i'm\n  m = doc.match('i am');\n  setContraction(m, `'m`);\n  // going to -> gonna\n  m = doc.match('going to');\n  return this;\n};\nexport default contract;","map":{"version":3,"names":["postPunct","setContraction","m","suffix","found","terms","termList","i","length","t","test","post","implicit","normal","text","slice","forEach","replace","contract","doc","not","match"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/2-two/contraction-two/api/contract.js"],"sourcesContent":["const postPunct = /[,)\"';:\\-–—.…]/\n\nconst setContraction = function (m, suffix) {\n  if (!m.found) {\n    return\n  }\n  let terms = m.termList()\n  //avoid any problematic punctuation\n  for (let i = 0; i < terms.length - 1; i++) {\n    const t = terms[i]\n    if (postPunct.test(t.post)) {\n      return\n    }\n  }\n  // set first word as full text\n  terms[0].implicit = terms[0].normal\n  terms[0].text += suffix\n  terms[0].normal += suffix\n  // clean-up the others\n  terms.slice(1).forEach(t => {\n    t.implicit = t.normal\n    t.text = ''\n    t.normal = ''\n  })\n  for (let i = 0; i < terms.length - 1; i++) {\n    terms[i].post = terms[i].post.replace(/ /, '')\n  }\n}\n\n/** turn 'i am' into i'm */\nconst contract = function () {\n  let doc = this.not('@hasContraction')\n  // we are -> we're\n  let m = doc.match('(we|they|you) are')\n  setContraction(m, `'re`)\n  // they will -> they'll\n  m = doc.match('(he|she|they|it|we|you) will')\n  setContraction(m, `'ll`)\n  // she is -> she's\n  m = doc.match('(he|she|they|it|we) is')\n  setContraction(m, `'s`)\n  // spencer is -> spencer's\n  m = doc.match('#Person is')\n  setContraction(m, `'s`)\n  // spencer would -> spencer'd\n  m = doc.match('#Person would')\n  setContraction(m, `'d`)\n  // would not -> wouldn't\n  m = doc.match('(is|was|had|would|should|could|do|does|have|has|can) not')\n  setContraction(m, `n't`)\n  // i have -> i've\n  m = doc.match('(i|we|they) have')\n  setContraction(m, `'ve`)\n  // would have -> would've\n  m = doc.match('(would|should|could) have')\n  setContraction(m, `'ve`)\n  // i am -> i'm\n  m = doc.match('i am')\n  setContraction(m, `'m`)\n  // going to -> gonna\n  m = doc.match('going to')\n  return this\n}\nexport default contract\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}