{"ast":null,"code":"const os = require('os');\nlet Threads = null;\ntry {\n  Threads = require('webworker-threads');\n} catch (e) {\n  // Silently set Threads to null\n  Threads = null;\n}\nfunction checkThreadSupport() {\n  if (typeof Threads === 'undefined') {\n    throw new Error('parallel classification requires the optional dependency webworker-threads');\n  }\n}\nfunction docsToFeatures(docs) {\n  const parsedDocs = [];\n  for (let i = 0; i < docs.length; i++) {\n    const features = [];\n    for (const feature in FEATURES) {\n      // eslint-disable-line\n      if (docs[i].observation.indexOf(feature) > -1) {\n        features.push(1);\n      } else {\n        features.push(0);\n      }\n    }\n    parsedDocs.push({\n      index: docs[i].index,\n      features\n    });\n  }\n  return JSON.stringify(parsedDocs);\n}\n\n// Convert docs to observation objects\nfunction docsToObs(docs, lastAdded, stemmer, keepStops) {\n  const obsDocs = [];\n  for (let i = lastAdded; i < docs.length; i++) {\n    let observation = this.docs[i].text;\n    if (typeof observation === 'string') {\n      observation = stemmer.tokenizeAndStem(observation, keepStops);\n    }\n    obsDocs.push({\n      index: i,\n      observation\n    });\n  }\n  return obsDocs;\n}\nfunction emitEvents(self, docFeatures, totalDocs) {\n  for (let j = self.lastAdded; j < totalDocs; j++) {\n    self.classifier.addExample(docFeatures[j], self.docs[j].label);\n    self.events.emit('trainedWithDocument', {\n      index: j,\n      total: totalDocs,\n      doc: self.docs[j]\n    });\n    self.lastAdded++;\n  }\n}\nfunction trainParallel(numThreads, callback) {\n  checkThreadSupport();\n  if (!callback) {\n    callback = numThreads;\n    numThreads = undefined;\n  }\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length;\n  }\n  const totalDocs = this.docs.length;\n  const threadPool = Threads.createPool(numThreads);\n  const docFeatures = {};\n  let finished = 0;\n  const self = this;\n\n  // Init pool; send the features array and the parsing function\n  threadPool.all.eval('var FEATURES = ' + JSON.stringify(this.features));\n  threadPool.all.eval(docsToFeatures);\n  const obsDocs = docsToObs(this.docs, this.lastAdded, this.stemmer, this.keepStops);\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    setTimeout(function () {\n      self.events.emit('processedBatch', {\n        size: docs.length,\n        docs: totalDocs,\n        batches: numThreads,\n        index: finished\n      });\n    });\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features;\n    }\n  };\n\n  // Called when all batches finish processing\n  const onFinished = function (err) {\n    if (err) {\n      threadPool.destroy();\n      return callback(err);\n    }\n    emitEvents(self, docFeatures, totalDocs);\n    self.events.emit('doneTraining', true);\n    self.classifier.train();\n    threadPool.destroy();\n    callback(null);\n  };\n\n  // Split the docs and start processing\n  const batchSize = Math.ceil(obsDocs.length / numThreads);\n  let lastError;\n  for (let i = 0; i < numThreads; i++) {\n    const batchDocs = obsDocs.slice(i * batchSize, (i + 1) * batchSize);\n    const batchJson = JSON.stringify(batchDocs);\n    threadPool.any.eval('docsToFeatures(' + batchJson + ')', function (err, docs) {\n      lastError = err || lastError;\n      finished++;\n      if (docs) {\n        docs = JSON.parse(docs);\n        onFeaturesResult(docs);\n      }\n      if (finished >= numThreads) {\n        onFinished(lastError);\n      }\n    });\n  }\n}\nfunction trainParallelBatches(options) {\n  checkThreadSupport();\n  let numThreads = options && options.numThreads;\n  let batchSize = options && options.batchSize;\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length;\n  }\n  if (isNaN(batchSize)) {\n    batchSize = 2500;\n  }\n  const totalDocs = this.docs.length;\n  const threadPool = Threads.createPool(numThreads);\n  const docFeatures = {};\n  let finished = 0;\n  const self = this;\n  let abort = false;\n  const onError = function (err) {\n    if (!err || abort) return;\n    abort = true;\n    threadPool.destroy(true);\n    self.events.emit('doneTrainingError', err);\n  };\n\n  // Init pool; send the features array and the parsing function\n  const str = JSON.stringify(this.features);\n  threadPool.all.eval('var FEATURES = ' + str + ';', onError);\n  threadPool.all.eval(docsToFeatures, onError);\n\n  // Convert docs to observation objects\n  let obsDocs = [];\n  for (let i = this.lastAdded; i < totalDocs; i++) {\n    let observation = this.docs[i].text;\n    if (typeof observation === 'string') {\n      observation = this.stemmer.tokenizeAndStem(observation, this.keepStops);\n    }\n    obsDocs.push({\n      index: i,\n      observation\n    });\n  }\n\n  // Split the docs in batches\n  const obsBatches = [];\n  let i = 0;\n  while (true) {\n    const batch = obsDocs.slice(i * batchSize, (i + 1) * batchSize);\n    if (!batch || !batch.length) break;\n    obsBatches.push(batch);\n    i++;\n  }\n  obsDocs = null;\n  self.events.emit('startedTraining', {\n    docs: totalDocs,\n    batches: obsBatches.length\n  });\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    self.events.emit('processedBatch', {\n      size: docs.length,\n      docs: totalDocs,\n      batches: obsBatches.length,\n      index: finished\n    });\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features;\n    }\n  };\n\n  // Called when all batches finish processing\n  const onFinished = function () {\n    threadPool.destroy(true);\n    abort = true;\n    emitEvents(self, docFeatures, totalDocs);\n    self.events.emit('doneTraining', true);\n    self.classifier.train();\n  };\n\n  // Called to send the next batch to be processed\n  let batchIndex = 0;\n  const sendNext = function () {\n    if (abort) return;\n    if (batchIndex >= obsBatches.length) {\n      return;\n    }\n    sendBatch(JSON.stringify(obsBatches[batchIndex]));\n    batchIndex++;\n  };\n\n  // Called to send a batch of docs to the threads\n  const sendBatch = function (batchJson) {\n    if (abort) return;\n    threadPool.any.eval('docsToFeatures(' + batchJson + ');', function (err, docs) {\n      if (err) {\n        return onError(err);\n      }\n      finished++;\n      if (docs) {\n        docs = JSON.parse(docs);\n        setTimeout(onFeaturesResult.bind(null, docs));\n      }\n      if (finished >= obsBatches.length) {\n        setTimeout(onFinished);\n      }\n      setTimeout(sendNext);\n    });\n  };\n\n  // Start processing\n  for (let i = 0; i < numThreads; i++) {\n    sendNext();\n  }\n}\nfunction retrainParallel(numThreads, callback) {\n  checkThreadSupport();\n  this.classifier = new this.classifier.constructor();\n  this.lastAdded = 0;\n  this.trainParallel(numThreads, callback);\n}\nmodule.exports = {\n  Threads,\n  trainParallel,\n  trainParallelBatches,\n  retrainParallel\n};","map":{"version":3,"names":["os","require","Threads","e","checkThreadSupport","Error","docsToFeatures","docs","parsedDocs","i","length","features","feature","FEATURES","observation","indexOf","push","index","JSON","stringify","docsToObs","lastAdded","stemmer","keepStops","obsDocs","text","tokenizeAndStem","emitEvents","self","docFeatures","totalDocs","j","classifier","addExample","label","events","emit","total","doc","trainParallel","numThreads","callback","undefined","isNaN","cpus","threadPool","createPool","finished","all","eval","onFeaturesResult","setTimeout","size","batches","onFinished","err","destroy","train","batchSize","Math","ceil","lastError","batchDocs","slice","batchJson","any","parse","trainParallelBatches","options","abort","onError","str","obsBatches","batch","batchIndex","sendNext","sendBatch","bind","retrainParallel","constructor","module","exports"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/natural/lib/natural/classifiers/classifier_train_parallel.js"],"sourcesContent":["const os = require('os')\n\nlet Threads = null\n\ntry {\n  Threads = require('webworker-threads')\n} catch (e) {\n  // Silently set Threads to null\n  Threads = null\n}\n\nfunction checkThreadSupport () {\n  if (typeof Threads === 'undefined') {\n    throw new Error('parallel classification requires the optional dependency webworker-threads')\n  }\n}\n\nfunction docsToFeatures (docs) {\n  const parsedDocs = []\n\n  for (let i = 0; i < docs.length; i++) {\n    const features = []\n\n    for (const feature in FEATURES) { // eslint-disable-line\n      if (docs[i].observation.indexOf(feature) > -1) { features.push(1) } else { features.push(0) }\n    }\n\n    parsedDocs.push({\n      index: docs[i].index,\n      features\n    })\n  }\n\n  return JSON.stringify(parsedDocs)\n}\n\n// Convert docs to observation objects\nfunction docsToObs (docs, lastAdded, stemmer, keepStops) {\n  const obsDocs = []\n  for (let i = lastAdded; i < docs.length; i++) {\n    let observation = this.docs[i].text\n    if (typeof observation === 'string') {\n      observation = stemmer.tokenizeAndStem(observation, keepStops)\n    }\n    obsDocs.push({\n      index: i,\n      observation\n    })\n  }\n  return obsDocs\n}\n\nfunction emitEvents (self, docFeatures, totalDocs) {\n  for (let j = self.lastAdded; j < totalDocs; j++) {\n    self.classifier.addExample(docFeatures[j], self.docs[j].label)\n    self.events.emit('trainedWithDocument', {\n      index: j,\n      total: totalDocs,\n      doc: self.docs[j]\n    })\n    self.lastAdded++\n  }\n}\n\nfunction trainParallel (numThreads, callback) {\n  checkThreadSupport()\n\n  if (!callback) {\n    callback = numThreads\n    numThreads = undefined\n  }\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length\n  }\n\n  const totalDocs = this.docs.length\n  const threadPool = Threads.createPool(numThreads)\n  const docFeatures = {}\n  let finished = 0\n  const self = this\n\n  // Init pool; send the features array and the parsing function\n  threadPool.all.eval('var FEATURES = ' + JSON.stringify(this.features))\n  threadPool.all.eval(docsToFeatures)\n\n  const obsDocs = docsToObs(this.docs, this.lastAdded, this.stemmer, this.keepStops)\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    setTimeout(function () {\n      self.events.emit('processedBatch', {\n        size: docs.length,\n        docs: totalDocs,\n        batches: numThreads,\n        index: finished\n      })\n    })\n\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features\n    }\n  }\n\n  // Called when all batches finish processing\n  const onFinished = function (err) {\n    if (err) {\n      threadPool.destroy()\n      return callback(err)\n    }\n\n    emitEvents(self, docFeatures, totalDocs)\n    self.events.emit('doneTraining', true)\n    self.classifier.train()\n\n    threadPool.destroy()\n    callback(null)\n  }\n\n  // Split the docs and start processing\n  const batchSize = Math.ceil(obsDocs.length / numThreads)\n  let lastError\n\n  for (let i = 0; i < numThreads; i++) {\n    const batchDocs = obsDocs.slice(i * batchSize, (i + 1) * batchSize)\n    const batchJson = JSON.stringify(batchDocs)\n\n    threadPool.any.eval('docsToFeatures(' + batchJson + ')', function (err, docs) {\n      lastError = err || lastError\n      finished++\n\n      if (docs) {\n        docs = JSON.parse(docs)\n        onFeaturesResult(docs)\n      }\n\n      if (finished >= numThreads) {\n        onFinished(lastError)\n      }\n    })\n  }\n}\n\nfunction trainParallelBatches (options) {\n  checkThreadSupport()\n\n  let numThreads = options && options.numThreads\n  let batchSize = options && options.batchSize\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length\n  }\n\n  if (isNaN(batchSize)) {\n    batchSize = 2500\n  }\n\n  const totalDocs = this.docs.length\n  const threadPool = Threads.createPool(numThreads)\n  const docFeatures = {}\n  let finished = 0\n  const self = this\n\n  let abort = false\n  const onError = function (err) {\n    if (!err || abort) return\n    abort = true\n    threadPool.destroy(true)\n    self.events.emit('doneTrainingError', err)\n  }\n\n  // Init pool; send the features array and the parsing function\n  const str = JSON.stringify(this.features)\n  threadPool.all.eval('var FEATURES = ' + str + ';', onError)\n  threadPool.all.eval(docsToFeatures, onError)\n\n  // Convert docs to observation objects\n  let obsDocs = []\n  for (let i = this.lastAdded; i < totalDocs; i++) {\n    let observation = this.docs[i].text\n    if (typeof observation === 'string') { observation = this.stemmer.tokenizeAndStem(observation, this.keepStops) }\n    obsDocs.push({\n      index: i,\n      observation\n    })\n  }\n\n  // Split the docs in batches\n  const obsBatches = []\n  let i = 0\n  while (true) {\n    const batch = obsDocs.slice(i * batchSize, (i + 1) * batchSize)\n    if (!batch || !batch.length) break\n    obsBatches.push(batch)\n    i++\n  }\n  obsDocs = null\n  self.events.emit('startedTraining', {\n    docs: totalDocs,\n    batches: obsBatches.length\n  })\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    self.events.emit('processedBatch', {\n      size: docs.length,\n      docs: totalDocs,\n      batches: obsBatches.length,\n      index: finished\n    })\n\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features\n    }\n  }\n\n  // Called when all batches finish processing\n  const onFinished = function () {\n    threadPool.destroy(true)\n    abort = true\n\n    emitEvents(self, docFeatures, totalDocs)\n    self.events.emit('doneTraining', true)\n    self.classifier.train()\n  }\n\n  // Called to send the next batch to be processed\n  let batchIndex = 0\n  const sendNext = function () {\n    if (abort) return\n    if (batchIndex >= obsBatches.length) {\n      return\n    }\n\n    sendBatch(JSON.stringify(obsBatches[batchIndex]))\n    batchIndex++\n  }\n\n  // Called to send a batch of docs to the threads\n  const sendBatch = function (batchJson) {\n    if (abort) return\n    threadPool.any.eval('docsToFeatures(' + batchJson + ');', function (err, docs) {\n      if (err) {\n        return onError(err)\n      }\n\n      finished++\n\n      if (docs) {\n        docs = JSON.parse(docs)\n        setTimeout(onFeaturesResult.bind(null, docs))\n      }\n\n      if (finished >= obsBatches.length) {\n        setTimeout(onFinished)\n      }\n\n      setTimeout(sendNext)\n    })\n  }\n\n  // Start processing\n  for (let i = 0; i < numThreads; i++) {\n    sendNext()\n  }\n}\n\nfunction retrainParallel (numThreads, callback) {\n  checkThreadSupport()\n\n  this.classifier = new (this.classifier.constructor)()\n  this.lastAdded = 0\n  this.trainParallel(numThreads, callback)\n}\n\nmodule.exports = {\n  Threads,\n  trainParallel,\n  trainParallelBatches,\n  retrainParallel\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}