{"ast":null,"code":"import View from './API/View.js';\nimport tmpWrld from './API/world.js';\nimport version from './_version.js';\nimport extend from './API/extend.js';\nimport { verbose } from './API/_lib.js';\nimport handleInputs from './API/inputs.js';\nlet world = Object.assign({}, tmpWrld);\nconst nlp = function (input, lex) {\n  if (lex) {\n    nlp.addWords(lex);\n  }\n  let doc = handleInputs(input, View, world);\n  if (input) {\n    doc.compute(world.hooks);\n  }\n  return doc;\n};\nObject.defineProperty(nlp, '_world', {\n  value: world,\n  writable: true\n});\n\n/** don't run the POS-tagger */\nnlp.tokenize = function (input, lex) {\n  const {\n    compute\n  } = this._world;\n  // add user-given words to lexicon\n  if (lex) {\n    nlp.addWords(lex);\n  }\n  // run the tokenizer\n  let doc = handleInputs(input, View, world);\n  // give contractions a shot, at least\n  if (compute.contractions) {\n    doc.compute(['alias', 'normal', 'machine', 'contractions']); //run it if we've got it\n  }\n  return doc;\n};\n\n/** extend compromise functionality */\nnlp.plugin = function (plugin) {\n  extend(plugin, this._world, View, this);\n  return this;\n};\nnlp.extend = nlp.plugin;\n\n/** reach-into compromise internals */\nnlp.world = function () {\n  return this._world;\n};\nnlp.model = function () {\n  return this._world.model;\n};\nnlp.methods = function () {\n  return this._world.methods;\n};\nnlp.hooks = function () {\n  return this._world.hooks;\n};\n\n/** log the decision-making to console */\nnlp.verbose = verbose;\n/** current library release version */\nnlp.version = version;\nexport default nlp;","map":{"version":3,"names":["View","tmpWrld","version","extend","verbose","handleInputs","world","Object","assign","nlp","input","lex","addWords","doc","compute","hooks","defineProperty","value","writable","tokenize","_world","contractions","plugin","model","methods"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/nlp.js"],"sourcesContent":["import View from './API/View.js'\nimport tmpWrld from './API/world.js'\nimport version from './_version.js'\nimport extend from './API/extend.js'\nimport { verbose } from './API/_lib.js'\nimport handleInputs from './API/inputs.js'\n\nlet world = Object.assign({}, tmpWrld)\n\nconst nlp = function (input, lex) {\n  if (lex) {\n    nlp.addWords(lex)\n  }\n  let doc = handleInputs(input, View, world)\n  if (input) {\n    doc.compute(world.hooks)\n  }\n  return doc\n}\nObject.defineProperty(nlp, '_world', {\n  value: world,\n  writable: true,\n})\n\n/** don't run the POS-tagger */\nnlp.tokenize = function (input, lex) {\n  const { compute } = this._world\n  // add user-given words to lexicon\n  if (lex) {\n    nlp.addWords(lex)\n  }\n  // run the tokenizer\n  let doc = handleInputs(input, View, world)\n  // give contractions a shot, at least\n  if (compute.contractions) {\n    doc.compute(['alias', 'normal', 'machine', 'contractions']) //run it if we've got it\n  }\n  return doc\n}\n\n/** extend compromise functionality */\nnlp.plugin = function (plugin) {\n  extend(plugin, this._world, View, this)\n  return this\n}\nnlp.extend = nlp.plugin\n\n\n/** reach-into compromise internals */\nnlp.world = function () {\n  return this._world\n}\nnlp.model = function () {\n  return this._world.model\n}\nnlp.methods = function () {\n  return this._world.methods\n}\nnlp.hooks = function () {\n  return this._world.hooks\n}\n\n/** log the decision-making to console */\nnlp.verbose = verbose\n/** current library release version */\nnlp.version = version\n\nexport default nlp\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,eAAe;AAChC,OAAOC,OAAO,MAAM,gBAAgB;AACpC,OAAOC,OAAO,MAAM,eAAe;AACnC,OAAOC,MAAM,MAAM,iBAAiB;AACpC,SAASC,OAAO,QAAQ,eAAe;AACvC,OAAOC,YAAY,MAAM,iBAAiB;AAE1C,IAAIC,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAAC;AAEtC,MAAMQ,GAAG,GAAG,SAAAA,CAAUC,KAAK,EAAEC,GAAG,EAAE;EAChC,IAAIA,GAAG,EAAE;IACPF,GAAG,CAACG,QAAQ,CAACD,GAAG,CAAC;EACnB;EACA,IAAIE,GAAG,GAAGR,YAAY,CAACK,KAAK,EAAEV,IAAI,EAAEM,KAAK,CAAC;EAC1C,IAAII,KAAK,EAAE;IACTG,GAAG,CAACC,OAAO,CAACR,KAAK,CAACS,KAAK,CAAC;EAC1B;EACA,OAAOF,GAAG;AACZ,CAAC;AACDN,MAAM,CAACS,cAAc,CAACP,GAAG,EAAE,QAAQ,EAAE;EACnCQ,KAAK,EAAEX,KAAK;EACZY,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACAT,GAAG,CAACU,QAAQ,GAAG,UAAUT,KAAK,EAAEC,GAAG,EAAE;EACnC,MAAM;IAAEG;EAAQ,CAAC,GAAG,IAAI,CAACM,MAAM;EAC/B;EACA,IAAIT,GAAG,EAAE;IACPF,GAAG,CAACG,QAAQ,CAACD,GAAG,CAAC;EACnB;EACA;EACA,IAAIE,GAAG,GAAGR,YAAY,CAACK,KAAK,EAAEV,IAAI,EAAEM,KAAK,CAAC;EAC1C;EACA,IAAIQ,OAAO,CAACO,YAAY,EAAE;IACxBR,GAAG,CAACC,OAAO,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC,EAAC;EAC9D;EACA,OAAOD,GAAG;AACZ,CAAC;;AAED;AACAJ,GAAG,CAACa,MAAM,GAAG,UAAUA,MAAM,EAAE;EAC7BnB,MAAM,CAACmB,MAAM,EAAE,IAAI,CAACF,MAAM,EAAEpB,IAAI,EAAE,IAAI,CAAC;EACvC,OAAO,IAAI;AACb,CAAC;AACDS,GAAG,CAACN,MAAM,GAAGM,GAAG,CAACa,MAAM;;AAGvB;AACAb,GAAG,CAACH,KAAK,GAAG,YAAY;EACtB,OAAO,IAAI,CAACc,MAAM;AACpB,CAAC;AACDX,GAAG,CAACc,KAAK,GAAG,YAAY;EACtB,OAAO,IAAI,CAACH,MAAM,CAACG,KAAK;AAC1B,CAAC;AACDd,GAAG,CAACe,OAAO,GAAG,YAAY;EACxB,OAAO,IAAI,CAACJ,MAAM,CAACI,OAAO;AAC5B,CAAC;AACDf,GAAG,CAACM,KAAK,GAAG,YAAY;EACtB,OAAO,IAAI,CAACK,MAAM,CAACL,KAAK;AAC1B,CAAC;;AAED;AACAN,GAAG,CAACL,OAAO,GAAGA,OAAO;AACrB;AACAK,GAAG,CAACP,OAAO,GAAGA,OAAO;AAErB,eAAeO,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}