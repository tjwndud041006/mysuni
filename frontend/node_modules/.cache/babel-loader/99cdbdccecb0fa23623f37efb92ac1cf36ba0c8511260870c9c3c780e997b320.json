{"ast":null,"code":"// # MemJS utility functions\n\nvar header = require('./header');\nvar bufferify = function (val) {\n  return Buffer.isBuffer(val) ? val : Buffer.from(val);\n};\nexports.makeRequestBuffer = function (opcode, key, extras, value, opaque) {\n  key = bufferify(key);\n  extras = bufferify(extras);\n  value = bufferify(value);\n  var buf = Buffer.alloc(24 + key.length + extras.length + value.length);\n  buf.fill();\n  var requestHeader = {\n    magic: 0x80,\n    opcode: opcode,\n    keyLength: key.length,\n    extrasLength: extras.length,\n    totalBodyLength: key.length + value.length + extras.length,\n    opaque: opaque\n  };\n  header.toBuffer(requestHeader).copy(buf);\n  extras.copy(buf, 24);\n  key.copy(buf, 24 + extras.length);\n  value.copy(buf, 24 + extras.length + key.length);\n  return buf;\n};\nexports.makeAmountInitialAndExpiration = function (amount, amountIfEmpty, expiration) {\n  var buf = Buffer.alloc(20);\n  buf.writeUInt32BE(0, 0);\n  buf.writeUInt32BE(amount, 4);\n  buf.writeUInt32BE(0, 8);\n  buf.writeUInt32BE(amountIfEmpty, 12);\n  buf.writeUInt32BE(expiration, 16);\n  return buf;\n};\nexports.makeExpiration = function (expiration) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(expiration, 0);\n  return buf;\n};\nexports.hashCode = function (str) {\n  var ret, i, len;\n  for (ret = 0, i = 0, len = str.length; i < len; i++) {\n    ret = 31 * ret + str.charCodeAt(i) << 0;\n  }\n  return Math.abs(ret);\n};\nexports.parseMessage = function (dataBuf) {\n  if (dataBuf.length < 24) {\n    return false;\n  }\n  var responseHeader = header.fromBuffer(dataBuf);\n  if (dataBuf.length < responseHeader.totalBodyLength + 24 || responseHeader.totalBodyLength < responseHeader.keyLength + responseHeader.extrasLength) {\n    return false;\n  }\n  var pointer = 24;\n  var extras = dataBuf.slice(pointer, pointer + responseHeader.extrasLength);\n  pointer += responseHeader.extrasLength;\n  var key = dataBuf.slice(pointer, pointer + responseHeader.keyLength);\n  pointer += responseHeader.keyLength;\n  var val = dataBuf.slice(pointer, 24 + responseHeader.totalBodyLength);\n  return {\n    header: responseHeader,\n    key: key,\n    extras: extras,\n    val: val\n  };\n};\nexports.merge = function (original, deflt) {\n  var attr, originalValue;\n  for (attr in deflt) {\n    if (deflt.hasOwnProperty(attr)) {\n      originalValue = original[attr];\n      if (originalValue === undefined || originalValue === null) {\n        original[attr] = deflt[attr];\n      }\n    }\n  }\n  return original;\n};\n\n// timestamp provides a monotonic timestamp with millisecond accuracy, useful\n// for timers.\nexports.timestamp = function () {\n  var times = process.hrtime();\n  return times[0] * 1000 + Math.round(times[1] / 1000000);\n};\nif (!Buffer.concat) {\n  Buffer.concat = function (list, length) {\n    if (!Array.isArray(list)) {\n      throw new Error('Usage: Buffer.concat(list, [length])');\n    }\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n    if (list.length === 1) {\n      return list[0];\n    }\n    var i, buf;\n    if (typeof length !== 'number') {\n      length = 0;\n      for (i = 0; i < list.length; i++) {\n        buf = list[i];\n        length += buf.length;\n      }\n    }\n    var buffer = Buffer.alloc(length);\n    var pos = 0;\n    for (i = 0; i < list.length; i++) {\n      buf = list[i];\n      buf.copy(buffer, pos);\n      pos += buf.length;\n    }\n    return buffer;\n  };\n}","map":{"version":3,"names":["header","require","bufferify","val","Buffer","isBuffer","from","exports","makeRequestBuffer","opcode","key","extras","value","opaque","buf","alloc","length","fill","requestHeader","magic","keyLength","extrasLength","totalBodyLength","toBuffer","copy","makeAmountInitialAndExpiration","amount","amountIfEmpty","expiration","writeUInt32BE","makeExpiration","hashCode","str","ret","i","len","charCodeAt","Math","abs","parseMessage","dataBuf","responseHeader","fromBuffer","pointer","slice","merge","original","deflt","attr","originalValue","hasOwnProperty","undefined","timestamp","times","process","hrtime","round","concat","list","Array","isArray","Error","buffer","pos"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/memjs/lib/memjs/utils.js"],"sourcesContent":["// # MemJS utility functions\n\nvar header = require('./header');\n\nvar bufferify = function(val) {\n  return Buffer.isBuffer(val) ? val : Buffer.from(val);\n};\n\nexports.makeRequestBuffer = function(opcode, key, extras, value, opaque) {\n  key = bufferify(key);\n  extras = bufferify(extras);\n  value = bufferify(value);\n  var buf = Buffer.alloc(24 + key.length + extras.length + value.length);\n  buf.fill();\n  var requestHeader = {\n    magic: 0x80,\n    opcode: opcode,\n    keyLength: key.length,\n    extrasLength: extras.length,\n    totalBodyLength: key.length + value.length + extras.length,\n    opaque: opaque\n  };\n  header.toBuffer(requestHeader).copy(buf);\n  extras.copy(buf, 24);\n  key.copy(buf, 24 + extras.length);\n  value.copy(buf, 24 + extras.length + key.length);\n  return buf;\n};\n\nexports.makeAmountInitialAndExpiration = function(amount, amountIfEmpty, expiration) {\n  var buf = Buffer.alloc(20);\n  buf.writeUInt32BE(0, 0);\n  buf.writeUInt32BE(amount, 4);\n  buf.writeUInt32BE(0, 8);\n  buf.writeUInt32BE(amountIfEmpty, 12);\n  buf.writeUInt32BE(expiration, 16);\n  return buf;\n};\n\nexports.makeExpiration = function(expiration) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(expiration, 0);\n  return buf;\n};\n\nexports.hashCode = function(str) {\n  var ret, i, len;\n  for(ret = 0, i = 0, len = str.length; i < len; i++) {\n    ret = (31 * ret + str.charCodeAt(i)) << 0;\n  }\n  return Math.abs(ret);\n};\n\nexports.parseMessage = function(dataBuf) {\n  if (dataBuf.length < 24) {\n    return false;\n  }\n  var responseHeader = header.fromBuffer(dataBuf);\n  if (dataBuf.length < responseHeader.totalBodyLength + 24 ||\n      responseHeader.totalBodyLength <\n        responseHeader.keyLength + responseHeader.extrasLength) {\n    return false;\n  }\n\n  var pointer = 24;\n  var extras = dataBuf.slice(pointer, pointer + responseHeader.extrasLength);\n  pointer += responseHeader.extrasLength;\n  var key = dataBuf.slice(pointer, pointer + responseHeader.keyLength);\n  pointer += responseHeader.keyLength;\n  var val = dataBuf.slice(pointer, 24 + responseHeader.totalBodyLength);\n\n  return {header: responseHeader, key: key, extras: extras, val: val};\n};\n\nexports.merge = function(original, deflt) {\n  var attr, originalValue;\n  for (attr in deflt) {\n    if (deflt.hasOwnProperty(attr)) {\n      originalValue = original[attr];\n\n      if (originalValue === undefined || originalValue === null) {\n        original[attr] = deflt[attr];\n      }\n    }\n  }\n  return original;\n};\n\n// timestamp provides a monotonic timestamp with millisecond accuracy, useful\n// for timers.\nexports.timestamp = function() {\n  var times = process.hrtime();\n  return (times[0] * 1000) + Math.round((times[1] / 1000000));\n};\n\nif(!Buffer.concat) {\n  Buffer.concat = function(list, length) {\n    if (!Array.isArray(list)) {\n      throw new Error('Usage: Buffer.concat(list, [length])');\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n    if (list.length === 1) {\n      return list[0];\n    }\n\n    var i, buf;\n\n    if (typeof length !== 'number') {\n      length = 0;\n      for (i = 0; i < list.length; i++) {\n        buf = list[i];\n        length += buf.length;\n      }\n    }\n\n    var buffer = Buffer.alloc(length);\n    var pos = 0;\n    for (i = 0; i < list.length; i++) {\n      buf = list[i];\n      buf.copy(buffer, pos);\n      pos += buf.length;\n    }\n    return buffer;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}