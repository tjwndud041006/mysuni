{"ast":null,"code":"// edited by Spencer Kelly\n// credit to https://github.com/BrunoRB/ahocorasick by Bruno Roberto Búrigo.\n\nconst tokenize = function (phrase, world) {\n  const {\n    methods,\n    model\n  } = world;\n  let terms = methods.one.tokenize.splitTerms(phrase, model).map(t => methods.one.tokenize.splitWhitespace(t, model));\n  return terms.map(term => term.text.toLowerCase());\n};\n\n// turn an array or object into a compressed aho-corasick structure\nconst buildTrie = function (phrases, world) {\n  // const tokenize=methods.one.\n  let goNext = [{}];\n  let endAs = [null];\n  let failTo = [0];\n  let xs = [];\n  let n = 0;\n  phrases.forEach(function (phrase) {\n    let curr = 0;\n    // let wordsB = phrase.split(/ /g).filter(w => w)\n    let words = tokenize(phrase, world);\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i];\n      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {\n        curr = goNext[curr][word];\n      } else {\n        n++;\n        goNext[curr][word] = n;\n        goNext[n] = {};\n        curr = n;\n        endAs[n] = null;\n      }\n    }\n    endAs[curr] = [words.length];\n  });\n  // f(s) = 0 for all states of depth 1 (the ones from which the 0 state can transition to)\n  for (let word in goNext[0]) {\n    n = goNext[0][word];\n    failTo[n] = 0;\n    xs.push(n);\n  }\n  while (xs.length) {\n    let r = xs.shift();\n    // for each symbol a such that g(r, a) = s\n    let keys = Object.keys(goNext[r]);\n    for (let i = 0; i < keys.length; i += 1) {\n      let word = keys[i];\n      let s = goNext[r][word];\n      xs.push(s);\n      // set state = f(r)\n      n = failTo[r];\n      while (n > 0 && !goNext[n].hasOwnProperty(word)) {\n        n = failTo[n];\n      }\n      if (goNext.hasOwnProperty(n)) {\n        let fs = goNext[n][word];\n        failTo[s] = fs;\n        if (endAs[fs]) {\n          endAs[s] = endAs[s] || [];\n          endAs[s] = endAs[s].concat(endAs[fs]);\n        }\n      } else {\n        failTo[s] = 0;\n      }\n    }\n  }\n  return {\n    goNext,\n    endAs,\n    failTo\n  };\n};\nexport default buildTrie;\n\n// console.log(buildTrie(['smart and cool', 'smart and nice']))","map":{"version":3,"names":["tokenize","phrase","world","methods","model","terms","one","splitTerms","map","t","splitWhitespace","term","text","toLowerCase","buildTrie","phrases","goNext","endAs","failTo","xs","n","forEach","curr","words","i","length","word","hasOwnProperty","push","r","shift","keys","Object","s","fs","concat"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/lookup/api/buildTrie/index.js"],"sourcesContent":["// edited by Spencer Kelly\n// credit to https://github.com/BrunoRB/ahocorasick by Bruno Roberto Búrigo.\n\nconst tokenize = function (phrase, world) {\n  const { methods, model } = world\n  let terms = methods.one.tokenize.splitTerms(phrase, model).map(t => methods.one.tokenize.splitWhitespace(t, model))\n  return terms.map(term => term.text.toLowerCase())\n}\n\n// turn an array or object into a compressed aho-corasick structure\nconst buildTrie = function (phrases, world) {\n\n  // const tokenize=methods.one.\n  let goNext = [{}]\n  let endAs = [null]\n  let failTo = [0]\n\n  let xs = []\n  let n = 0\n  phrases.forEach(function (phrase) {\n    let curr = 0\n    // let wordsB = phrase.split(/ /g).filter(w => w)\n    let words = tokenize(phrase, world)\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i]\n      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {\n        curr = goNext[curr][word]\n      } else {\n        n++\n        goNext[curr][word] = n\n        goNext[n] = {}\n        curr = n\n        endAs[n] = null\n      }\n    }\n    endAs[curr] = [words.length]\n  })\n  // f(s) = 0 for all states of depth 1 (the ones from which the 0 state can transition to)\n  for (let word in goNext[0]) {\n    n = goNext[0][word]\n    failTo[n] = 0\n    xs.push(n)\n  }\n\n  while (xs.length) {\n    let r = xs.shift()\n    // for each symbol a such that g(r, a) = s\n    let keys = Object.keys(goNext[r])\n    for (let i = 0; i < keys.length; i += 1) {\n      let word = keys[i]\n      let s = goNext[r][word]\n      xs.push(s)\n      // set state = f(r)\n      n = failTo[r]\n      while (n > 0 && !goNext[n].hasOwnProperty(word)) {\n        n = failTo[n]\n      }\n      if (goNext.hasOwnProperty(n)) {\n        let fs = goNext[n][word]\n        failTo[s] = fs\n        if (endAs[fs]) {\n          endAs[s] = endAs[s] || []\n          endAs[s] = endAs[s].concat(endAs[fs])\n        }\n      } else {\n        failTo[s] = 0\n      }\n    }\n  }\n  return { goNext, endAs, failTo }\n}\nexport default buildTrie\n\n// console.log(buildTrie(['smart and cool', 'smart and nice']))\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}