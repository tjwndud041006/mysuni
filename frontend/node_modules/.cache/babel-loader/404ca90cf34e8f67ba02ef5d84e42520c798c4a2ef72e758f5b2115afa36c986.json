{"ast":null,"code":"import { hasHyphen, splitHyphens } from './01-hyphens.js';\nimport combineRanges from './03-ranges.js';\nimport combineSlashes from './02-slashes.js';\nconst wordlike = /\\S/;\nconst isBoundary = /^[!?.]+$/;\nconst naiiveSplit = /(\\S+)/;\nlet notWord = ['.', '?', '!', ':', ';', '-', '–', '—', '--', '...', '(', ')', '[', ']', '\"', \"'\", '`', '«', '»', '*', '•'];\nnotWord = notWord.reduce((h, c) => {\n  h[c] = true;\n  return h;\n}, {});\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\n\n//turn a string into an array of strings (naiive for now, lumped later)\nconst splitWords = function (str, model) {\n  let result = [];\n  let arr = [];\n  //start with a naiive split\n  str = str || '';\n  if (typeof str === 'number') {\n    str = String(str);\n  }\n  if (isArray(str)) {\n    return str;\n  }\n  const words = str.split(naiiveSplit);\n  for (let i = 0; i < words.length; i++) {\n    //split 'one-two'\n    if (hasHyphen(words[i], model) === true) {\n      arr = arr.concat(splitHyphens(words[i]));\n      continue;\n    }\n    arr.push(words[i]);\n  }\n  //greedy merge whitespace+arr to the right\n  let carry = '';\n  for (let i = 0; i < arr.length; i++) {\n    let word = arr[i];\n    //if it's more than a whitespace\n    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {\n      //put whitespace on end of previous term, if possible\n      if (result.length > 0) {\n        result[result.length - 1] += carry;\n        result.push(word);\n      } else {\n        //otherwise, but whitespace before\n        result.push(carry + word);\n      }\n      carry = '';\n    } else {\n      carry += word;\n    }\n  }\n  //handle last one\n  if (carry) {\n    if (result.length === 0) {\n      result[0] = '';\n    }\n    result[result.length - 1] += carry; //put it on the end\n  }\n  // combine 'one / two'\n  result = combineSlashes(result);\n  result = combineRanges(result);\n  // remove empty results\n  result = result.filter(s => s);\n  return result;\n};\nexport default splitWords;","map":{"version":3,"names":["hasHyphen","splitHyphens","combineRanges","combineSlashes","wordlike","isBoundary","naiiveSplit","notWord","reduce","h","c","isArray","arr","Object","prototype","toString","call","splitWords","str","model","result","String","words","split","i","length","concat","push","carry","word","test","hasOwnProperty","filter","s"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/tokenize/methods/02-terms/index.js"],"sourcesContent":["import { hasHyphen, splitHyphens } from './01-hyphens.js'\nimport combineRanges from './03-ranges.js'\nimport combineSlashes from './02-slashes.js'\n\nconst wordlike = /\\S/\nconst isBoundary = /^[!?.]+$/\nconst naiiveSplit = /(\\S+)/\n\nlet notWord = [\n  '.',\n  '?',\n  '!',\n  ':',\n  ';',\n  '-',\n  '–',\n  '—',\n  '--',\n  '...',\n  '(',\n  ')',\n  '[',\n  ']',\n  '\"',\n  \"'\",\n  '`',\n  '«',\n  '»',\n  '*',\n  '•',\n]\nnotWord = notWord.reduce((h, c) => {\n  h[c] = true\n  return h\n}, {})\n\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\n//turn a string into an array of strings (naiive for now, lumped later)\nconst splitWords = function (str, model) {\n  let result = []\n  let arr = []\n  //start with a naiive split\n  str = str || ''\n  if (typeof str === 'number') {\n    str = String(str)\n  }\n  if (isArray(str)) {\n    return str\n  }\n  const words = str.split(naiiveSplit)\n  for (let i = 0; i < words.length; i++) {\n    //split 'one-two'\n    if (hasHyphen(words[i], model) === true) {\n      arr = arr.concat(splitHyphens(words[i]))\n      continue\n    }\n    arr.push(words[i])\n  }\n  //greedy merge whitespace+arr to the right\n  let carry = ''\n  for (let i = 0; i < arr.length; i++) {\n    let word = arr[i]\n    //if it's more than a whitespace\n    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {\n      //put whitespace on end of previous term, if possible\n      if (result.length > 0) {\n        result[result.length - 1] += carry\n        result.push(word)\n      } else {\n        //otherwise, but whitespace before\n        result.push(carry + word)\n      }\n      carry = ''\n    } else {\n      carry += word\n    }\n  }\n  //handle last one\n  if (carry) {\n    if (result.length === 0) {\n      result[0] = ''\n    }\n    result[result.length - 1] += carry //put it on the end\n  }\n  // combine 'one / two'\n  result = combineSlashes(result)\n  result = combineRanges(result)\n  // remove empty results\n  result = result.filter(s => s)\n  return result\n}\nexport default splitWords\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}