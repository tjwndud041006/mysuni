{"ast":null,"code":"const shouldSkip = function (last) {\n  // is it our only choice?\n  if (last.length <= 1) {\n    return false;\n  }\n  let obj = last.parse()[0] || {};\n  return obj.isSubordinate;\n};\n\n// try to chop-out any obvious conditional phrases\n// he wore, [if it was raining], a raincoat.\nconst noSubClause = function (before) {\n  let parts = before.clauses();\n  parts = parts.filter((m, i) => {\n    // if it was raining..\n    if (m.has('^(if|unless|while|but|for|per|at|by|that|which|who|from)')) {\n      return false;\n    }\n    // bowed to her,\n    if (i > 0 && m.has('^#Verb . #Noun+$')) {\n      return false;\n    }\n    // the fog, suddenly increasing in..\n    if (i > 0 && m.has('^#Adverb')) {\n      return false;\n    }\n    return true;\n  });\n  // don't drop the whole thing.\n  if (parts.length === 0) {\n    return before;\n  }\n  return parts;\n};\n\n//\nconst lastNoun = function (vb) {\n  let before = vb.before();\n  // try to drop any mid-sentence clauses\n  before = noSubClause(before);\n  // parse-out our preceding nouns\n  let nouns = before.nouns();\n  // look for any dead-ringers\n  let last = nouns.last();\n  // i/she/he/they are very strong\n  let pronoun = last.match('(i|he|she|we|you|they)');\n  if (pronoun.found) {\n    return pronoun.nouns();\n  }\n  // these are also good hints\n  let det = nouns.if('^(that|this|those)');\n  if (det.found) {\n    return det;\n  }\n  if (nouns.found === false) {\n    det = before.match('^(that|this|those)');\n    if (det.found) {\n      return det;\n    }\n  }\n\n  // should we skip a subbordinate clause or two?\n  last = nouns.last();\n  if (shouldSkip(last)) {\n    nouns.remove(last);\n    last = nouns.last();\n  }\n  // i suppose we can skip two?\n  if (shouldSkip(last)) {\n    nouns.remove(last);\n    last = nouns.last();\n  }\n  return last;\n};\nconst isPlural = function (subj, vb) {\n  // 'we are' vs 'he is'\n  if (vb.has('(are|were|does)')) {\n    return true;\n  }\n  if (subj.has('(those|they|we)')) {\n    return true;\n  }\n  if (subj.found && subj.isPlural) {\n    return subj.isPlural().found;\n  }\n  return false;\n};\nconst getSubject = function (vb) {\n  let subj = lastNoun(vb);\n  return {\n    subject: subj,\n    plural: isPlural(subj, vb)\n  };\n};\nexport default getSubject;","map":{"version":3,"names":["shouldSkip","last","length","obj","parse","isSubordinate","noSubClause","before","parts","clauses","filter","m","i","has","lastNoun","vb","nouns","pronoun","match","found","det","if","remove","isPlural","subj","getSubject","subject","plural"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/3-three/verbs/api/parse/getSubject.js"],"sourcesContent":["const shouldSkip = function (last) {\n  // is it our only choice?\n  if (last.length <= 1) {\n    return false\n  }\n  let obj = last.parse()[0] || {}\n  return obj.isSubordinate\n}\n\n// try to chop-out any obvious conditional phrases\n// he wore, [if it was raining], a raincoat.\nconst noSubClause = function (before) {\n  let parts = before.clauses()\n  parts = parts.filter((m, i) => {\n    // if it was raining..\n    if (m.has('^(if|unless|while|but|for|per|at|by|that|which|who|from)')) {\n      return false\n    }\n    // bowed to her,\n    if (i > 0 && m.has('^#Verb . #Noun+$')) {\n      return false\n    }\n    // the fog, suddenly increasing in..\n    if (i > 0 && m.has('^#Adverb')) {\n      return false\n    }\n    return true\n  })\n  // don't drop the whole thing.\n  if (parts.length === 0) {\n    return before\n  }\n  return parts\n}\n\n//\nconst lastNoun = function (vb) {\n  let before = vb.before()\n  // try to drop any mid-sentence clauses\n  before = noSubClause(before)\n  // parse-out our preceding nouns\n  let nouns = before.nouns()\n  // look for any dead-ringers\n  let last = nouns.last()\n  // i/she/he/they are very strong\n  let pronoun = last.match('(i|he|she|we|you|they)')\n  if (pronoun.found) {\n    return pronoun.nouns()\n  }\n  // these are also good hints\n  let det = nouns.if('^(that|this|those)')\n  if (det.found) {\n    return det\n  }\n  if (nouns.found === false) {\n    det = before.match('^(that|this|those)')\n    if (det.found) {\n      return det\n    }\n  }\n\n  // should we skip a subbordinate clause or two?\n  last = nouns.last()\n  if (shouldSkip(last)) {\n    nouns.remove(last)\n    last = nouns.last()\n  }\n  // i suppose we can skip two?\n  if (shouldSkip(last)) {\n    nouns.remove(last)\n    last = nouns.last()\n  }\n  return last\n}\n\nconst isPlural = function (subj, vb) {\n  // 'we are' vs 'he is'\n  if (vb.has('(are|were|does)')) {\n    return true\n  }\n  if (subj.has('(those|they|we)')) {\n    return true\n  }\n  if (subj.found && subj.isPlural) {\n    return subj.isPlural().found\n  }\n  return false\n}\n\nconst getSubject = function (vb) {\n  let subj = lastNoun(vb)\n  return {\n    subject: subj,\n    plural: isPlural(subj, vb),\n  }\n}\nexport default getSubject\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}