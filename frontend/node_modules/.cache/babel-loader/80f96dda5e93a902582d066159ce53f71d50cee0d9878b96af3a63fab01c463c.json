{"ast":null,"code":"import Histogram from './histogram.js';\nimport encoding from '../encoding.js';\nconst config = {\n  NODE_SEP: ';',\n  KEY_VAL: ':',\n  STRING_SEP: ',',\n  TERMINAL_PREFIX: '!',\n  BASE: 36\n};\n// Return packed representation of Trie as a string.\n// Return packed representation of Trie as a string.\n//\n// Each node of the Trie is output on a single line.\n//\n// For example Trie(\"the them there thesis this\"):\n// {\n//    \"th\": {\n//      \"is\": 1,\n//      \"e\": {\n//        \"\": 1,\n//        \"m\": 1,\n//        \"re\": 1,\n//        \"sis\": 1\n//      }\n//    }\n//  }\n//\n// Would be reperesented as:\n//\n// th0\n// e0is\n// !m,re,sis\n//\n// The line begins with a '!' iff it is a terminal node of the Trie.\n// For each string property in a node, the string is listed, along\n// with a (relative!) line number of the node that string references.\n// Terminal strings (those without child node references) are\n// separated by ',' characters.\nconst nodeLine = function (self, node) {\n  let line = '',\n    sep = '';\n  if (self.isTerminal(node)) {\n    line += config.TERMINAL_PREFIX;\n  }\n  const props = self.nodeProps(node);\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    if (typeof node[prop] === 'number') {\n      line += sep + prop;\n      sep = config.STRING_SEP;\n      continue;\n    }\n    if (self.syms[node[prop]._n]) {\n      line += sep + prop + self.syms[node[prop]._n];\n      sep = '';\n      continue;\n    }\n    let ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount);\n    // Large reference to smaller string suffix -> duplicate suffix\n    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {\n      ref = node[prop]._g;\n      line += sep + prop + ref;\n      sep = config.STRING_SEP;\n      continue;\n    }\n    line += sep + prop + ref;\n    sep = '';\n  }\n  return line;\n};\nconst analyzeRefs = function (self, node) {\n  if (self.visited(node)) {\n    return;\n  }\n  const props = self.nodeProps(node, true);\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    const ref = node._n - node[prop]._n - 1;\n    // Count the number of single-character relative refs\n    if (ref < config.BASE) {\n      self.histRel.add(ref);\n    }\n    // Count the number of characters saved by converting an absolute\n    // reference to a one-character symbol.\n    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1);\n    analyzeRefs(self, node[prop]);\n  }\n};\nconst symbolCount = function (self) {\n  self.histAbs = self.histAbs.highest(config.BASE);\n  const savings = [];\n  savings[-1] = 0;\n  let best = 0,\n    sCount = 0;\n  const defSize = 3 + encoding.toAlphaCode(self.nodeCount).length;\n  for (let sym = 0; sym < config.BASE; sym++) {\n    if (self.histAbs[sym] === undefined) {\n      break;\n    }\n    savings[sym] = self.histAbs[sym][1] - defSize - self.histRel.countOf(config.BASE - sym - 1) + savings[sym - 1];\n    if (savings[sym] >= best) {\n      best = savings[sym];\n      sCount = sym + 1;\n    }\n  }\n  return sCount;\n};\nconst numberNodes = function (self, node) {\n  // Topological sort into nodes array\n  if (node._n !== undefined) {\n    return;\n  }\n  const props = self.nodeProps(node, true);\n  for (let i = 0; i < props.length; i++) {\n    numberNodes(self, node[props[i]]); //recursive\n  }\n  node._n = self.pos++;\n  self.nodes.unshift(node);\n};\nconst pack = function (self) {\n  self.nodes = [];\n  self.nodeCount = 0;\n  self.syms = {};\n  self.symCount = 0;\n  self.pos = 0;\n  // Make sure we've combined all the common suffixes\n  self.optimize();\n  self.histAbs = new Histogram();\n  self.histRel = new Histogram();\n  numberNodes(self, self.root);\n  self.nodeCount = self.nodes.length;\n  self.prepDFS();\n  analyzeRefs(self, self.root);\n  self.symCount = symbolCount(self);\n  for (let sym = 0; sym < self.symCount; sym++) {\n    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym);\n  }\n  for (let i = 0; i < self.nodeCount; i++) {\n    self.nodes[i] = nodeLine(self, self.nodes[i]);\n  }\n  // Prepend symbols\n  for (let sym = self.symCount - 1; sym >= 0; sym--) {\n    self.nodes.unshift(encoding.toAlphaCode(sym) + config.KEY_VAL + encoding.toAlphaCode(self.nodeCount - self.histAbs[sym][0] - 1));\n  }\n  return self.nodes.join(config.NODE_SEP);\n};\nexport default pack;","map":{"version":3,"names":["Histogram","encoding","config","NODE_SEP","KEY_VAL","STRING_SEP","TERMINAL_PREFIX","BASE","nodeLine","self","node","line","sep","isTerminal","props","nodeProps","i","length","prop","syms","_n","ref","toAlphaCode","symCount","_g","analyzeRefs","visited","histRel","add","histAbs","symbolCount","highest","savings","best","sCount","defSize","nodeCount","sym","undefined","countOf","numberNodes","pos","nodes","unshift","pack","optimize","root","prepDFS","join"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/efrt/src/pack/pack.js"],"sourcesContent":["import Histogram from './histogram.js'\nimport encoding from '../encoding.js'\n\nconst config = {\n  NODE_SEP: ';',\n  KEY_VAL: ':',\n  STRING_SEP: ',',\n  TERMINAL_PREFIX: '!',\n  BASE: 36\n}\n// Return packed representation of Trie as a string.\n// Return packed representation of Trie as a string.\n//\n// Each node of the Trie is output on a single line.\n//\n// For example Trie(\"the them there thesis this\"):\n// {\n//    \"th\": {\n//      \"is\": 1,\n//      \"e\": {\n//        \"\": 1,\n//        \"m\": 1,\n//        \"re\": 1,\n//        \"sis\": 1\n//      }\n//    }\n//  }\n//\n// Would be reperesented as:\n//\n// th0\n// e0is\n// !m,re,sis\n//\n// The line begins with a '!' iff it is a terminal node of the Trie.\n// For each string property in a node, the string is listed, along\n// with a (relative!) line number of the node that string references.\n// Terminal strings (those without child node references) are\n// separated by ',' characters.\nconst nodeLine = function (self, node) {\n  let line = '',\n    sep = ''\n  if (self.isTerminal(node)) {\n    line += config.TERMINAL_PREFIX\n  }\n  const props = self.nodeProps(node)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    if (typeof node[prop] === 'number') {\n      line += sep + prop\n      sep = config.STRING_SEP\n      continue\n    }\n    if (self.syms[node[prop]._n]) {\n      line += sep + prop + self.syms[node[prop]._n]\n      sep = ''\n      continue\n    }\n    let ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount)\n    // Large reference to smaller string suffix -> duplicate suffix\n    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {\n      ref = node[prop]._g\n      line += sep + prop + ref\n      sep = config.STRING_SEP\n      continue\n    }\n    line += sep + prop + ref\n    sep = ''\n  }\n  return line\n}\n\nconst analyzeRefs = function (self, node) {\n  if (self.visited(node)) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    const ref = node._n - node[prop]._n - 1\n    // Count the number of single-character relative refs\n    if (ref < config.BASE) {\n      self.histRel.add(ref)\n    }\n    // Count the number of characters saved by converting an absolute\n    // reference to a one-character symbol.\n    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1)\n    analyzeRefs(self, node[prop])\n  }\n}\n\nconst symbolCount = function (self) {\n  self.histAbs = self.histAbs.highest(config.BASE)\n  const savings = []\n  savings[-1] = 0\n  let best = 0,\n    sCount = 0\n  const defSize = 3 + encoding.toAlphaCode(self.nodeCount).length\n  for (let sym = 0; sym < config.BASE; sym++) {\n    if (self.histAbs[sym] === undefined) {\n      break\n    }\n    savings[sym] =\n      self.histAbs[sym][1] -\n      defSize -\n      self.histRel.countOf(config.BASE - sym - 1) +\n      savings[sym - 1]\n    if (savings[sym] >= best) {\n      best = savings[sym]\n      sCount = sym + 1\n    }\n  }\n  return sCount\n}\n\nconst numberNodes = function (self, node) {\n  // Topological sort into nodes array\n  if (node._n !== undefined) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    numberNodes(self, node[props[i]]) //recursive\n  }\n  node._n = self.pos++\n  self.nodes.unshift(node)\n}\n\nconst pack = function (self) {\n  self.nodes = []\n  self.nodeCount = 0\n  self.syms = {}\n  self.symCount = 0\n  self.pos = 0\n  // Make sure we've combined all the common suffixes\n  self.optimize()\n  self.histAbs = new Histogram()\n  self.histRel = new Histogram()\n  numberNodes(self, self.root)\n  self.nodeCount = self.nodes.length\n  self.prepDFS()\n  analyzeRefs(self, self.root)\n  self.symCount = symbolCount(self)\n  for (let sym = 0; sym < self.symCount; sym++) {\n    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym)\n  }\n  for (let i = 0; i < self.nodeCount; i++) {\n    self.nodes[i] = nodeLine(self, self.nodes[i])\n  }\n  // Prepend symbols\n  for (let sym = self.symCount - 1; sym >= 0; sym--) {\n    self.nodes.unshift(\n      encoding.toAlphaCode(sym) +\n        config.KEY_VAL +\n        encoding.toAlphaCode(self.nodeCount - self.histAbs[sym][0] - 1)\n    )\n  }\n  return self.nodes.join(config.NODE_SEP)\n}\n\nexport default pack\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}