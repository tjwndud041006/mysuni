{"ast":null,"code":"import getUnion from './lib/union.js';\nimport getDifference from './lib/difference.js';\nimport getIntersection from './lib/intersection.js';\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\nconst getDoc = (m, view) => {\n  if (typeof m === 'string' || isArray(m)) {\n    return view.match(m);\n  }\n  if (!m) {\n    return view.none();\n  }\n  // support pre-parsed reg object\n  return m;\n};\n\n// 'harden' our json pointers, again\nconst addIds = function (ptrs, docs) {\n  return ptrs.map(ptr => {\n    let [n, start] = ptr;\n    if (docs[n] && docs[n][start]) {\n      ptr[3] = docs[n][start].id;\n    }\n    return ptr;\n  });\n};\nconst methods = {};\n\n// all parts, minus duplicates\nmethods.union = function (m) {\n  m = getDoc(m, this);\n  let ptrs = getUnion(this.fullPointer, m.fullPointer);\n  ptrs = addIds(ptrs, this.document);\n  return this.toView(ptrs);\n};\nmethods.and = methods.union;\n\n// only parts they both have\nmethods.intersection = function (m) {\n  m = getDoc(m, this);\n  let ptrs = getIntersection(this.fullPointer, m.fullPointer);\n  ptrs = addIds(ptrs, this.document);\n  return this.toView(ptrs);\n};\n\n// only parts of a that b does not have\nmethods.not = function (m) {\n  m = getDoc(m, this);\n  let ptrs = getDifference(this.fullPointer, m.fullPointer);\n  ptrs = addIds(ptrs, this.document);\n  return this.toView(ptrs);\n};\nmethods.difference = methods.not;\n\n// get opposite of a match\nmethods.complement = function () {\n  let doc = this.all();\n  let ptrs = getDifference(doc.fullPointer, this.fullPointer);\n  ptrs = addIds(ptrs, this.document);\n  return this.toView(ptrs);\n};\n\n// remove overlaps\nmethods.settle = function () {\n  let ptrs = this.fullPointer;\n  ptrs.forEach(ptr => {\n    ptrs = getUnion(ptrs, [ptr]);\n  });\n  ptrs = addIds(ptrs, this.document);\n  return this.update(ptrs);\n};\nconst addAPI = function (View) {\n  // add set/intersection/union\n  Object.assign(View.prototype, methods);\n};\nexport default addAPI;","map":{"version":3,"names":["getUnion","getDifference","getIntersection","isArray","arr","Object","prototype","toString","call","getDoc","m","view","match","none","addIds","ptrs","docs","map","ptr","n","start","id","methods","union","fullPointer","document","toView","and","intersection","not","difference","complement","doc","all","settle","forEach","update","addAPI","View","assign"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/pointers/api/index.js"],"sourcesContent":["import getUnion from './lib/union.js'\nimport getDifference from './lib/difference.js'\nimport getIntersection from './lib/intersection.js'\n\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\nconst getDoc = (m, view) => {\n  if (typeof m === 'string' || isArray(m)) {\n    return view.match(m)\n  }\n  if (!m) {\n    return view.none()\n  }\n  // support pre-parsed reg object\n  return m\n}\n\n// 'harden' our json pointers, again\nconst addIds = function (ptrs, docs) {\n  return ptrs.map(ptr => {\n    let [n, start] = ptr\n    if (docs[n] && docs[n][start]) {\n      ptr[3] = docs[n][start].id\n    }\n    return ptr\n  })\n}\n\nconst methods = {}\n\n// all parts, minus duplicates\nmethods.union = function (m) {\n  m = getDoc(m, this)\n  let ptrs = getUnion(this.fullPointer, m.fullPointer)\n  ptrs = addIds(ptrs, this.document)\n  return this.toView(ptrs)\n}\nmethods.and = methods.union\n\n// only parts they both have\nmethods.intersection = function (m) {\n  m = getDoc(m, this)\n  let ptrs = getIntersection(this.fullPointer, m.fullPointer)\n  ptrs = addIds(ptrs, this.document)\n  return this.toView(ptrs)\n}\n\n// only parts of a that b does not have\nmethods.not = function (m) {\n  m = getDoc(m, this)\n  let ptrs = getDifference(this.fullPointer, m.fullPointer)\n  ptrs = addIds(ptrs, this.document)\n  return this.toView(ptrs)\n}\nmethods.difference = methods.not\n\n// get opposite of a match\nmethods.complement = function () {\n  let doc = this.all()\n  let ptrs = getDifference(doc.fullPointer, this.fullPointer)\n  ptrs = addIds(ptrs, this.document)\n  return this.toView(ptrs)\n}\n\n// remove overlaps\nmethods.settle = function () {\n  let ptrs = this.fullPointer\n  ptrs.forEach(ptr => {\n    ptrs = getUnion(ptrs, [ptr])\n  })\n  ptrs = addIds(ptrs, this.document)\n  return this.update(ptrs)\n}\n\nconst addAPI = function (View) {\n  // add set/intersection/union\n  Object.assign(View.prototype, methods)\n}\nexport default addAPI\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}