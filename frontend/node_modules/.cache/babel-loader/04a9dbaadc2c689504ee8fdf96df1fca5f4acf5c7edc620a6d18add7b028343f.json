{"ast":null,"code":"const toText = function (term) {\n  let pre = term.pre || '';\n  let post = term.post || '';\n  return pre + term.text + post;\n};\nconst findStarts = function (doc, obj) {\n  let starts = {};\n  Object.keys(obj).forEach(reg => {\n    let m = doc.match(reg);\n    m.fullPointer.forEach(a => {\n      starts[a[3]] = {\n        fn: obj[reg],\n        end: a[2]\n      };\n    });\n  });\n  return starts;\n};\nconst wrap = function (doc, obj) {\n  // index ids to highlight\n  let starts = findStarts(doc, obj);\n  let text = '';\n  doc.docs.forEach((terms, n) => {\n    for (let i = 0; i < terms.length; i += 1) {\n      let t = terms[i];\n      // do a span tag\n      if (starts.hasOwnProperty(t.id)) {\n        let {\n          fn,\n          end\n        } = starts[t.id];\n        let m = doc.update([[n, i, end]]);\n        text += terms[i].pre || '';\n        text += fn(m);\n        i = end - 1;\n        text += terms[i].post || '';\n      } else {\n        text += toText(t);\n      }\n    }\n  });\n  return text;\n};\nexport default wrap;","map":{"version":3,"names":["toText","term","pre","post","text","findStarts","doc","obj","starts","Object","keys","forEach","reg","m","match","fullPointer","a","fn","end","wrap","docs","terms","n","i","length","t","hasOwnProperty","id","update"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/1-one/output/api/wrap.js"],"sourcesContent":["const toText = function (term) {\n  let pre = term.pre || ''\n  let post = term.post || ''\n  return pre + term.text + post\n}\n\nconst findStarts = function (doc, obj) {\n  let starts = {}\n  Object.keys(obj).forEach(reg => {\n    let m = doc.match(reg)\n    m.fullPointer.forEach(a => {\n      starts[a[3]] = { fn: obj[reg], end: a[2] }\n    })\n  })\n  return starts\n}\n\nconst wrap = function (doc, obj) {\n  // index ids to highlight\n  let starts = findStarts(doc, obj)\n  let text = ''\n  doc.docs.forEach((terms, n) => {\n    for (let i = 0; i < terms.length; i += 1) {\n      let t = terms[i]\n      // do a span tag\n      if (starts.hasOwnProperty(t.id)) {\n        let { fn, end } = starts[t.id]\n        let m = doc.update([[n, i, end]])\n        text += terms[i].pre || ''\n        text += fn(m)\n        i = end - 1\n        text += terms[i].post || ''\n      } else {\n        text += toText(t)\n      }\n    }\n  })\n  return text\n}\nexport default wrap"],"mappings":"AAAA,MAAMA,MAAM,GAAG,SAAAA,CAAUC,IAAI,EAAE;EAC7B,IAAIC,GAAG,GAAGD,IAAI,CAACC,GAAG,IAAI,EAAE;EACxB,IAAIC,IAAI,GAAGF,IAAI,CAACE,IAAI,IAAI,EAAE;EAC1B,OAAOD,GAAG,GAAGD,IAAI,CAACG,IAAI,GAAGD,IAAI;AAC/B,CAAC;AAED,MAAME,UAAU,GAAG,SAAAA,CAAUC,GAAG,EAAEC,GAAG,EAAE;EACrC,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfC,MAAM,CAACC,IAAI,CAACH,GAAG,CAAC,CAACI,OAAO,CAACC,GAAG,IAAI;IAC9B,IAAIC,CAAC,GAAGP,GAAG,CAACQ,KAAK,CAACF,GAAG,CAAC;IACtBC,CAAC,CAACE,WAAW,CAACJ,OAAO,CAACK,CAAC,IAAI;MACzBR,MAAM,CAACQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;QAAEC,EAAE,EAAEV,GAAG,CAACK,GAAG,CAAC;QAAEM,GAAG,EAAEF,CAAC,CAAC,CAAC;MAAE,CAAC;IAC5C,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOR,MAAM;AACf,CAAC;AAED,MAAMW,IAAI,GAAG,SAAAA,CAAUb,GAAG,EAAEC,GAAG,EAAE;EAC/B;EACA,IAAIC,MAAM,GAAGH,UAAU,CAACC,GAAG,EAAEC,GAAG,CAAC;EACjC,IAAIH,IAAI,GAAG,EAAE;EACbE,GAAG,CAACc,IAAI,CAACT,OAAO,CAAC,CAACU,KAAK,EAAEC,CAAC,KAAK;IAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MACxC,IAAIE,CAAC,GAAGJ,KAAK,CAACE,CAAC,CAAC;MAChB;MACA,IAAIf,MAAM,CAACkB,cAAc,CAACD,CAAC,CAACE,EAAE,CAAC,EAAE;QAC/B,IAAI;UAAEV,EAAE;UAAEC;QAAI,CAAC,GAAGV,MAAM,CAACiB,CAAC,CAACE,EAAE,CAAC;QAC9B,IAAId,CAAC,GAAGP,GAAG,CAACsB,MAAM,CAAC,CAAC,CAACN,CAAC,EAAEC,CAAC,EAAEL,GAAG,CAAC,CAAC,CAAC;QACjCd,IAAI,IAAIiB,KAAK,CAACE,CAAC,CAAC,CAACrB,GAAG,IAAI,EAAE;QAC1BE,IAAI,IAAIa,EAAE,CAACJ,CAAC,CAAC;QACbU,CAAC,GAAGL,GAAG,GAAG,CAAC;QACXd,IAAI,IAAIiB,KAAK,CAACE,CAAC,CAAC,CAACpB,IAAI,IAAI,EAAE;MAC7B,CAAC,MAAM;QACLC,IAAI,IAAIJ,MAAM,CAACyB,CAAC,CAAC;MACnB;IACF;EACF,CAAC,CAAC;EACF,OAAOrB,IAAI;AACb,CAAC;AACD,eAAee,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}