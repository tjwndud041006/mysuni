{"ast":null,"code":"const utils = {\n  /** */\n  termList: function () {\n    return this.methods.one.termList(this.docs);\n  },\n  /** return individual terms*/\n  terms: function (n) {\n    let m = this.match('.');\n    // this is a bit faster than .match('.') \n    // let ptrs = []\n    // this.docs.forEach((terms) => {\n    //   terms.forEach((term) => {\n    //     let [y, x] = term.index || []\n    //     ptrs.push([y, x, x + 1])\n    //   })\n    // })\n    // let m = this.update(ptrs)\n    return typeof n === 'number' ? m.eq(n) : m;\n  },\n  /** */\n  groups: function (group) {\n    if (group || group === 0) {\n      return this.update(this._groups[group] || []);\n    }\n    // return an object of Views\n    let res = {};\n    Object.keys(this._groups).forEach(k => {\n      res[k] = this.update(this._groups[k]);\n    });\n    // this._groups = null\n    return res;\n  },\n  /** */\n  eq: function (n) {\n    let ptr = this.pointer;\n    if (!ptr) {\n      ptr = this.docs.map((_doc, i) => [i]);\n    }\n    if (ptr[n]) {\n      return this.update([ptr[n]]);\n    }\n    return this.none();\n  },\n  /** */\n  first: function () {\n    return this.eq(0);\n  },\n  /** */\n  last: function () {\n    let n = this.fullPointer.length - 1;\n    return this.eq(n);\n  },\n  /** grab term[0] for every match */\n  firstTerms: function () {\n    return this.match('^.');\n  },\n  /** grab the last term for every match  */\n  lastTerms: function () {\n    return this.match('.$');\n  },\n  /** */\n  slice: function (min, max) {\n    let pntrs = this.pointer || this.docs.map((_o, n) => [n]);\n    pntrs = pntrs.slice(min, max);\n    return this.update(pntrs);\n  },\n  /** return a view of the entire document */\n  all: function () {\n    return this.update().toView();\n  },\n  /**  */\n  fullSentences: function () {\n    let ptrs = this.fullPointer.map(a => [a[0]]); //lazy!\n    return this.update(ptrs).toView();\n  },\n  /** return a view of no parts of the document */\n  none: function () {\n    return this.update([]);\n  },\n  /** are these two views looking at the same words? */\n  isDoc: function (b) {\n    if (!b || !b.isView) {\n      return false;\n    }\n    let aPtr = this.fullPointer;\n    let bPtr = b.fullPointer;\n    if (!aPtr.length === bPtr.length) {\n      return false;\n    }\n    // ensure pointers are the same\n    return aPtr.every((ptr, i) => {\n      if (!bPtr[i]) {\n        return false;\n      }\n      // ensure [n, start, end] are all the same\n      return ptr[0] === bPtr[i][0] && ptr[1] === bPtr[i][1] && ptr[2] === bPtr[i][2];\n    });\n  },\n  /** how many seperate terms does the document have? */\n  wordCount: function () {\n    return this.docs.reduce((count, terms) => {\n      count += terms.filter(t => t.text !== '').length;\n      return count;\n    }, 0);\n  },\n  // is the pointer the full sentence?\n  isFull: function () {\n    let ptrs = this.pointer;\n    if (!ptrs) {\n      return true;\n    }\n    // must start at beginning\n    if (ptrs.length === 0 || ptrs[0][0] !== 0) {\n      return false;\n    }\n    let wantTerms = 0;\n    let haveTerms = 0;\n    this.document.forEach(terms => wantTerms += terms.length);\n    this.docs.forEach(terms => haveTerms += terms.length);\n    return wantTerms === haveTerms;\n    // for (let i = 0; i < ptrs.length; i += 1) {\n    //   let [n, start, end] = ptrs[i]\n    //   // it's not the start\n    //   if (n !== i || start !== 0) {\n    //     return false\n    //   }\n    //   // it's too short\n    //   if (document[n].length > end) {\n    //     return false\n    //   }\n    // }\n    // return true\n  },\n  // return the nth elem of a doc\n  getNth: function (n) {\n    if (typeof n === 'number') {\n      return this.eq(n);\n    } else if (typeof n === 'string') {\n      return this.if(n);\n    }\n    return this;\n  }\n};\nutils.group = utils.groups;\nutils.fullSentence = utils.fullSentences;\nutils.sentence = utils.fullSentences;\nutils.lastTerm = utils.lastTerms;\nutils.firstTerm = utils.firstTerms;\nexport default utils;","map":{"version":3,"names":["utils","termList","methods","one","docs","terms","n","m","match","eq","groups","group","update","_groups","res","Object","keys","forEach","k","ptr","pointer","map","_doc","i","none","first","last","fullPointer","length","firstTerms","lastTerms","slice","min","max","pntrs","_o","all","toView","fullSentences","ptrs","a","isDoc","b","isView","aPtr","bPtr","every","wordCount","reduce","count","filter","t","text","isFull","wantTerms","haveTerms","document","getNth","if","fullSentence","sentence","lastTerm","firstTerm"],"sources":["/Users/seojuyoung/sunic/project/frontend/node_modules/compromise/src/API/methods/utils.js"],"sourcesContent":["const utils = {\n  /** */\n  termList: function () {\n    return this.methods.one.termList(this.docs)\n  },\n  /** return individual terms*/\n  terms: function (n) {\n    let m = this.match('.')\n    // this is a bit faster than .match('.') \n    // let ptrs = []\n    // this.docs.forEach((terms) => {\n    //   terms.forEach((term) => {\n    //     let [y, x] = term.index || []\n    //     ptrs.push([y, x, x + 1])\n    //   })\n    // })\n    // let m = this.update(ptrs)\n    return typeof n === 'number' ? m.eq(n) : m\n  },\n\n  /** */\n  groups: function (group) {\n    if (group || group === 0) {\n      return this.update(this._groups[group] || [])\n    }\n    // return an object of Views\n    let res = {}\n    Object.keys(this._groups).forEach(k => {\n      res[k] = this.update(this._groups[k])\n    })\n    // this._groups = null\n    return res\n  },\n  /** */\n  eq: function (n) {\n    let ptr = this.pointer\n    if (!ptr) {\n      ptr = this.docs.map((_doc, i) => [i])\n    }\n    if (ptr[n]) {\n      return this.update([ptr[n]])\n    }\n    return this.none()\n  },\n  /** */\n  first: function () {\n    return this.eq(0)\n  },\n  /** */\n  last: function () {\n    let n = this.fullPointer.length - 1\n    return this.eq(n)\n  },\n\n  /** grab term[0] for every match */\n  firstTerms: function () {\n    return this.match('^.')\n  },\n\n  /** grab the last term for every match  */\n  lastTerms: function () {\n    return this.match('.$')\n  },\n\n  /** */\n  slice: function (min, max) {\n    let pntrs = this.pointer || this.docs.map((_o, n) => [n])\n    pntrs = pntrs.slice(min, max)\n    return this.update(pntrs)\n  },\n\n  /** return a view of the entire document */\n  all: function () {\n    return this.update().toView()\n  },\n  /**  */\n  fullSentences: function () {\n    let ptrs = this.fullPointer.map(a => [a[0]]) //lazy!\n    return this.update(ptrs).toView()\n  },\n  /** return a view of no parts of the document */\n  none: function () {\n    return this.update([])\n  },\n\n  /** are these two views looking at the same words? */\n  isDoc: function (b) {\n    if (!b || !b.isView) {\n      return false\n    }\n    let aPtr = this.fullPointer\n    let bPtr = b.fullPointer\n    if (!aPtr.length === bPtr.length) {\n      return false\n    }\n    // ensure pointers are the same\n    return aPtr.every((ptr, i) => {\n      if (!bPtr[i]) {\n        return false\n      }\n      // ensure [n, start, end] are all the same\n      return ptr[0] === bPtr[i][0] && ptr[1] === bPtr[i][1] && ptr[2] === bPtr[i][2]\n    })\n  },\n\n  /** how many seperate terms does the document have? */\n  wordCount: function () {\n    return this.docs.reduce((count, terms) => {\n      count += terms.filter(t => t.text !== '').length\n      return count\n    }, 0)\n  },\n\n  // is the pointer the full sentence?\n  isFull: function () {\n    let ptrs = this.pointer\n    if (!ptrs) {\n      return true\n    }\n    // must start at beginning\n    if (ptrs.length === 0 || ptrs[0][0] !== 0) {\n      return false\n    }\n    let wantTerms = 0\n    let haveTerms = 0\n    this.document.forEach(terms => wantTerms += terms.length)\n    this.docs.forEach(terms => haveTerms += terms.length)\n    return wantTerms === haveTerms\n    // for (let i = 0; i < ptrs.length; i += 1) {\n    //   let [n, start, end] = ptrs[i]\n    //   // it's not the start\n    //   if (n !== i || start !== 0) {\n    //     return false\n    //   }\n    //   // it's too short\n    //   if (document[n].length > end) {\n    //     return false\n    //   }\n    // }\n    // return true\n  },\n\n  // return the nth elem of a doc\n  getNth: function (n) {\n    if (typeof n === 'number') {\n      return this.eq(n)\n    } else if (typeof n === 'string') {\n      return this.if(n)\n    }\n    return this\n  }\n\n}\nutils.group = utils.groups\nutils.fullSentence = utils.fullSentences\nutils.sentence = utils.fullSentences\nutils.lastTerm = utils.lastTerms\nutils.firstTerm = utils.firstTerms\nexport default utils\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}